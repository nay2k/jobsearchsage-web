import {
  Adder,
  FindNearestDirection,
  InternMap,
  arrayOfIndices,
  ascending,
  bisect_default,
  bisector,
  clamp,
  clean,
  cloneDeep,
  css,
  ensureArray,
  extent,
  filterDataByRange,
  flatten,
  getBoolean,
  getExtent,
  getMax,
  getMin,
  getNearest,
  getNumber,
  getStackedData,
  getStackedExtent,
  getStackedValues,
  getString,
  getValue,
  group,
  groupBy,
  index,
  injectGlobal,
  isArray,
  isEmpty,
  isEqual,
  isFunction,
  isNil,
  isNumber,
  isNumberWithinRange,
  isObject,
  isPlainObject,
  isString,
  isUndefined,
  max,
  mean,
  merge,
  merge2,
  min,
  minIndex,
  quantileSorted,
  range,
  shallowDiff,
  sortBy,
  sum,
  throttle,
  tickIncrement,
  tickStep,
  ticks,
  unique,
  without
} from "./chunk-7S7APBZD.js";
import {
  dispatch_default,
  interval_default,
  now,
  timeout_default,
  timer
} from "./chunk-TK5H2S67.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-PR4QN5HX.js";

// node_modules/parse-unit/index.js
var require_parse_unit = __commonJS({
  "node_modules/parse-unit/index.js"(exports, module) {
    module.exports = function parseUnit2(str, out) {
      if (!out)
        out = [0, ""];
      str = String(str);
      var num = parseFloat(str, 10);
      out[0] = num;
      out[1] = str.match(/[\d.\-\+]*\s*(.*)/)[1] || "";
      return out;
    };
  }
});

// node_modules/to-px/browser.js
var require_browser = __commonJS({
  "node_modules/to-px/browser.js"(exports, module) {
    "use strict";
    var parseUnit2 = require_parse_unit();
    module.exports = toPX;
    var PIXELS_PER_INCH = getSizeBrutal("in", document.body);
    function getPropertyInPX(element, prop) {
      var parts = parseUnit2(getComputedStyle(element).getPropertyValue(prop));
      return parts[0] * toPX(parts[1], element);
    }
    function getSizeBrutal(unit2, element) {
      var testDIV = document.createElement("div");
      testDIV.style["height"] = "128" + unit2;
      element.appendChild(testDIV);
      var size2 = getPropertyInPX(testDIV, "height") / 128;
      element.removeChild(testDIV);
      return size2;
    }
    function toPX(str, element) {
      if (!str) return null;
      element = element || document.body;
      str = (str + "" || "px").trim().toLowerCase();
      if (element === window || element === document) {
        element = document.body;
      }
      switch (str) {
        case "%":
          return element.clientHeight / 100;
        case "ch":
        case "ex":
          return getSizeBrutal(str, element);
        case "em":
          return getPropertyInPX(element, "font-size");
        case "rem":
          return getPropertyInPX(document.body, "font-size");
        case "vw":
          return window.innerWidth / 100;
        case "vh":
          return window.innerHeight / 100;
        case "vmin":
          return Math.min(window.innerWidth, window.innerHeight) / 100;
        case "vmax":
          return Math.max(window.innerWidth, window.innerHeight) / 100;
        case "in":
          return PIXELS_PER_INCH;
        case "cm":
          return PIXELS_PER_INCH / 2.54;
        case "mm":
          return PIXELS_PER_INCH / 25.4;
        case "pt":
          return PIXELS_PER_INCH / 72;
        case "pc":
          return PIXELS_PER_INCH / 6;
        case "px":
          return 1;
      }
      var parts = parseUnit2(str);
      if (!isNaN(parts[0]) && parts[1]) {
        var px = toPX(parts[1], element);
        return typeof px === "number" ? parts[0] * px : null;
      }
      return null;
    }
  }
});

// node_modules/striptags/src/striptags.js
var require_striptags = __commonJS({
  "node_modules/striptags/src/striptags.js"(exports, module) {
    "use strict";
    (function(global2) {
      if (typeof Symbol4 !== "function") {
        var Symbol4 = function(name2) {
          return name2;
        };
        Symbol4.nonNative = true;
      }
      const STATE_PLAINTEXT = Symbol4("plaintext");
      const STATE_HTML = Symbol4("html");
      const STATE_COMMENT = Symbol4("comment");
      const ALLOWED_TAGS_REGEX = /<(\w*)>/g;
      const NORMALIZE_TAG_REGEX = /<\/?([^\s\/>]+)/;
      function striptags3(html, allowable_tags, tag_replacement) {
        html = html || "";
        allowable_tags = allowable_tags || [];
        tag_replacement = tag_replacement || "";
        let context = init_context(allowable_tags, tag_replacement);
        return striptags_internal(html, context);
      }
      function init_striptags_stream(allowable_tags, tag_replacement) {
        allowable_tags = allowable_tags || [];
        tag_replacement = tag_replacement || "";
        let context = init_context(allowable_tags, tag_replacement);
        return function striptags_stream(html) {
          return striptags_internal(html || "", context);
        };
      }
      striptags3.init_streaming_mode = init_striptags_stream;
      function init_context(allowable_tags, tag_replacement) {
        allowable_tags = parse_allowable_tags(allowable_tags);
        return {
          allowable_tags,
          tag_replacement,
          state: STATE_PLAINTEXT,
          tag_buffer: "",
          depth: 0,
          in_quote_char: ""
        };
      }
      function striptags_internal(html, context) {
        if (typeof html != "string") {
          throw new TypeError("'html' parameter must be a string");
        }
        let allowable_tags = context.allowable_tags;
        let tag_replacement = context.tag_replacement;
        let state = context.state;
        let tag_buffer = context.tag_buffer;
        let depth = context.depth;
        let in_quote_char = context.in_quote_char;
        let output = "";
        for (let idx = 0, length = html.length; idx < length; idx++) {
          let char = html[idx];
          if (state === STATE_PLAINTEXT) {
            switch (char) {
              case "<":
                state = STATE_HTML;
                tag_buffer += char;
                break;
              default:
                output += char;
                break;
            }
          } else if (state === STATE_HTML) {
            switch (char) {
              case "<":
                if (in_quote_char) {
                  break;
                }
                depth++;
                break;
              case ">":
                if (in_quote_char) {
                  break;
                }
                if (depth) {
                  depth--;
                  break;
                }
                in_quote_char = "";
                state = STATE_PLAINTEXT;
                tag_buffer += ">";
                if (allowable_tags.has(normalize_tag(tag_buffer))) {
                  output += tag_buffer;
                } else {
                  output += tag_replacement;
                }
                tag_buffer = "";
                break;
              case '"':
              case "'":
                if (char === in_quote_char) {
                  in_quote_char = "";
                } else {
                  in_quote_char = in_quote_char || char;
                }
                tag_buffer += char;
                break;
              case "-":
                if (tag_buffer === "<!-") {
                  state = STATE_COMMENT;
                }
                tag_buffer += char;
                break;
              case " ":
              case "\n":
                if (tag_buffer === "<") {
                  state = STATE_PLAINTEXT;
                  output += "< ";
                  tag_buffer = "";
                  break;
                }
                tag_buffer += char;
                break;
              default:
                tag_buffer += char;
                break;
            }
          } else if (state === STATE_COMMENT) {
            switch (char) {
              case ">":
                if (tag_buffer.slice(-2) == "--") {
                  state = STATE_PLAINTEXT;
                }
                tag_buffer = "";
                break;
              default:
                tag_buffer += char;
                break;
            }
          }
        }
        context.state = state;
        context.tag_buffer = tag_buffer;
        context.depth = depth;
        context.in_quote_char = in_quote_char;
        return output;
      }
      function parse_allowable_tags(allowable_tags) {
        let tag_set = /* @__PURE__ */ new Set();
        if (typeof allowable_tags === "string") {
          let match;
          while (match = ALLOWED_TAGS_REGEX.exec(allowable_tags)) {
            tag_set.add(match[1]);
          }
        } else if (!Symbol4.nonNative && typeof allowable_tags[Symbol4.iterator] === "function") {
          tag_set = new Set(allowable_tags);
        } else if (typeof allowable_tags.forEach === "function") {
          allowable_tags.forEach(tag_set.add, tag_set);
        }
        return tag_set;
      }
      function normalize_tag(tag_buffer) {
        let match = NORMALIZE_TAG_REGEX.exec(tag_buffer);
        return match ? match[1].toLowerCase() : null;
      }
      if (typeof define === "function" && define.amd) {
        define(function module_factory() {
          return striptags3;
        });
      } else if (typeof module === "object" && module.exports) {
        module.exports = striptags3;
      } else {
        global2.striptags = striptags3;
      }
    })(exports);
  }
});

// node_modules/@unovis/vue/containers/xy-container/index.js
import { defineComponent as u2, toRefs as y3, ref as p, reactive as v, watch as f2, watchEffect as x3, toRaw as r, onMounted as h, onUnmounted as D2, provide as a5, createElementBlock as g, openBlock as A6, renderSlot as C2 } from "vue";

// node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/d3-selection/src/namespace.js
function namespace_default(name2) {
  var prefix = name2 += "", i8 = prefix.indexOf(":");
  if (i8 >= 0 && (prefix = name2.slice(0, i8)) !== "xmlns") name2 = name2.slice(i8 + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name2 } : name2;
}

// node_modules/d3-selection/src/creator.js
function creatorInherit(name2) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name2) : document2.createElementNS(uri, name2);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name2) {
  var fullname = namespace_default(name2);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/d3-selection/src/selection/select.js
function select_default(select2) {
  if (typeof select2 !== "function") select2 = selector_default(select2);
  for (var groups2 = this._groups, m30 = groups2.length, subgroups = new Array(m30), j6 = 0; j6 < m30; ++j6) {
    for (var group3 = groups2[j6], n = group3.length, subgroup = subgroups[j6] = new Array(n), node4, subnode, i8 = 0; i8 < n; ++i8) {
      if ((node4 = group3[i8]) && (subnode = select2.call(node4, node4.__data__, i8, group3))) {
        if ("__data__" in node4) subnode.__data__ = node4.__data__;
        subgroup[i8] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/array.js
function array(x21) {
  return x21 == null ? [] : Array.isArray(x21) ? x21 : Array.from(x21);
}

// node_modules/d3-selection/src/selectorAll.js
function empty() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select2) {
  return function() {
    return array(select2.apply(this, arguments));
  };
}
function selectAll_default(select2) {
  if (typeof select2 === "function") select2 = arrayAll(select2);
  else select2 = selectorAll_default(select2);
  for (var groups2 = this._groups, m30 = groups2.length, subgroups = [], parents = [], j6 = 0; j6 < m30; ++j6) {
    for (var group3 = groups2[j6], n = group3.length, node4, i8 = 0; i8 < n; ++i8) {
      if (node4 = group3[i8]) {
        subgroups.push(select2.call(node4, node4.__data__, i8, group3));
        parents.push(node4);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node4) {
    return node4.matches(selector);
  };
}

// node_modules/d3-selection/src/selection/selectChild.js
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/selectChildren.js
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function") match = matcher_default(match);
  for (var groups2 = this._groups, m30 = groups2.length, subgroups = new Array(m30), j6 = 0; j6 < m30; ++j6) {
    for (var group3 = groups2[j6], n = group3.length, subgroup = subgroups[j6] = [], node4, i8 = 0; i8 < n; ++i8) {
      if ((node4 = group3[i8]) && match.call(node4, node4.__data__, i8, group3)) {
        subgroup.push(node4);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update) {
  return new Array(update.length);
}

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/d3-selection/src/constant.js
function constant_default(x21) {
  return function() {
    return x21;
  };
}

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group3, enter, update, exit, data) {
  var i8 = 0, node4, groupLength = group3.length, dataLength = data.length;
  for (; i8 < dataLength; ++i8) {
    if (node4 = group3[i8]) {
      node4.__data__ = data[i8];
      update[i8] = node4;
    } else {
      enter[i8] = new EnterNode(parent, data[i8]);
    }
  }
  for (; i8 < groupLength; ++i8) {
    if (node4 = group3[i8]) {
      exit[i8] = node4;
    }
  }
}
function bindKey(parent, group3, enter, update, exit, data, key) {
  var i8, node4, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group3.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i8 = 0; i8 < groupLength; ++i8) {
    if (node4 = group3[i8]) {
      keyValues[i8] = keyValue = key.call(node4, node4.__data__, i8, group3) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i8] = node4;
      } else {
        nodeByKeyValue.set(keyValue, node4);
      }
    }
  }
  for (i8 = 0; i8 < dataLength; ++i8) {
    keyValue = key.call(parent, data[i8], i8, data) + "";
    if (node4 = nodeByKeyValue.get(keyValue)) {
      update[i8] = node4;
      node4.__data__ = data[i8];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i8] = new EnterNode(parent, data[i8]);
    }
  }
  for (i8 = 0; i8 < groupLength; ++i8) {
    if ((node4 = group3[i8]) && nodeByKeyValue.get(keyValues[i8]) === node4) {
      exit[i8] = node4;
    }
  }
}
function datum(node4) {
  return node4.__data__;
}
function data_default(value2, key) {
  if (!arguments.length) return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups2 = this._groups;
  if (typeof value2 !== "function") value2 = constant_default(value2);
  for (var m30 = groups2.length, update = new Array(m30), enter = new Array(m30), exit = new Array(m30), j6 = 0; j6 < m30; ++j6) {
    var parent = parents[j6], group3 = groups2[j6], groupLength = group3.length, data = arraylike(value2.call(parent, parent && parent.__data__, j6, parents)), dataLength = data.length, enterGroup = enter[j6] = new Array(dataLength), updateGroup = update[j6] = new Array(dataLength), exitGroup = exit[j6] = new Array(groupLength);
    bind(parent, group3, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength) ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove();
  else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

// node_modules/d3-selection/src/selection/merge.js
function merge_default(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m30 = Math.min(m0, m1), merges = new Array(m0), j6 = 0; j6 < m30; ++j6) {
    for (var group0 = groups0[j6], group1 = groups1[j6], n = group0.length, merge4 = merges[j6] = new Array(n), node4, i8 = 0; i8 < n; ++i8) {
      if (node4 = group0[i8] || group1[i8]) {
        merge4[i8] = node4;
      }
    }
  }
  for (; j6 < m0; ++j6) {
    merges[j6] = groups0[j6];
  }
  return new Selection(merges, this._parents);
}

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups2 = this._groups, j6 = -1, m30 = groups2.length; ++j6 < m30; ) {
    for (var group3 = groups2[j6], i8 = group3.length - 1, next = group3[i8], node4; --i8 >= 0; ) {
      if (node4 = group3[i8]) {
        if (next && node4.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node4, next);
        next = node4;
      }
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare) compare = ascending2;
  function compareNode(a7, b25) {
    return a7 && b25 ? compare(a7.__data__, b25.__data__) : !a7 - !b25;
  }
  for (var groups2 = this._groups, m30 = groups2.length, sortgroups = new Array(m30), j6 = 0; j6 < m30; ++j6) {
    for (var group3 = groups2[j6], n = group3.length, sortgroup = sortgroups[j6] = new Array(n), node4, i8 = 0; i8 < n; ++i8) {
      if (node4 = group3[i8]) {
        sortgroup[i8] = node4;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending2(a7, b25) {
  return a7 < b25 ? -1 : a7 > b25 ? 1 : a7 >= b25 ? 0 : NaN;
}

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups2 = this._groups, j6 = 0, m30 = groups2.length; j6 < m30; ++j6) {
    for (var group3 = groups2[j6], i8 = 0, n = group3.length; i8 < n; ++i8) {
      var node4 = group3[i8];
      if (node4) return node4;
    }
  }
  return null;
}

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size2 = 0;
  for (const node4 of this) ++size2;
  return size2;
}

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups2 = this._groups, j6 = 0, m30 = groups2.length; j6 < m30; ++j6) {
    for (var group3 = groups2[j6], i8 = 0, n = group3.length, node4; i8 < n; ++i8) {
      if (node4 = group3[i8]) callback.call(node4, node4.__data__, i8, group3);
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name2) {
  return function() {
    this.removeAttribute(name2);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name2, value2) {
  return function() {
    this.setAttribute(name2, value2);
  };
}
function attrConstantNS(fullname, value2) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value2);
  };
}
function attrFunction(name2, value2) {
  return function() {
    var v28 = value2.apply(this, arguments);
    if (v28 == null) this.removeAttribute(name2);
    else this.setAttribute(name2, v28);
  };
}
function attrFunctionNS(fullname, value2) {
  return function() {
    var v28 = value2.apply(this, arguments);
    if (v28 == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v28);
  };
}
function attr_default(name2, value2) {
  var fullname = namespace_default(name2);
  if (arguments.length < 2) {
    var node4 = this.node();
    return fullname.local ? node4.getAttributeNS(fullname.space, fullname.local) : node4.getAttribute(fullname);
  }
  return this.each((value2 == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value2 === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value2));
}

// node_modules/d3-selection/src/window.js
function window_default(node4) {
  return node4.ownerDocument && node4.ownerDocument.defaultView || node4.document && node4 || node4.defaultView;
}

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name2) {
  return function() {
    this.style.removeProperty(name2);
  };
}
function styleConstant(name2, value2, priority) {
  return function() {
    this.style.setProperty(name2, value2, priority);
  };
}
function styleFunction(name2, value2, priority) {
  return function() {
    var v28 = value2.apply(this, arguments);
    if (v28 == null) this.style.removeProperty(name2);
    else this.style.setProperty(name2, v28, priority);
  };
}
function style_default(name2, value2, priority) {
  return arguments.length > 1 ? this.each((value2 == null ? styleRemove : typeof value2 === "function" ? styleFunction : styleConstant)(name2, value2, priority == null ? "" : priority)) : styleValue(this.node(), name2);
}
function styleValue(node4, name2) {
  return node4.style.getPropertyValue(name2) || window_default(node4).getComputedStyle(node4, null).getPropertyValue(name2);
}

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name2) {
  return function() {
    delete this[name2];
  };
}
function propertyConstant(name2, value2) {
  return function() {
    this[name2] = value2;
  };
}
function propertyFunction(name2, value2) {
  return function() {
    var v28 = value2.apply(this, arguments);
    if (v28 == null) delete this[name2];
    else this[name2] = v28;
  };
}
function property_default(name2, value2) {
  return arguments.length > 1 ? this.each((value2 == null ? propertyRemove : typeof value2 === "function" ? propertyFunction : propertyConstant)(name2, value2)) : this.node()[name2];
}

// node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node4) {
  return node4.classList || new ClassList(node4);
}
function ClassList(node4) {
  this._node = node4;
  this._names = classArray(node4.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name2) {
    var i8 = this._names.indexOf(name2);
    if (i8 < 0) {
      this._names.push(name2);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name2) {
    var i8 = this._names.indexOf(name2);
    if (i8 >= 0) {
      this._names.splice(i8, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name2) {
    return this._names.indexOf(name2) >= 0;
  }
};
function classedAdd(node4, names) {
  var list = classList(node4), i8 = -1, n = names.length;
  while (++i8 < n) list.add(names[i8]);
}
function classedRemove(node4, names) {
  var list = classList(node4), i8 = -1, n = names.length;
  while (++i8 < n) list.remove(names[i8]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value2) {
  return function() {
    (value2.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name2, value2) {
  var names = classArray(name2 + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i8 = -1, n = names.length;
    while (++i8 < n) if (!list.contains(names[i8])) return false;
    return true;
  }
  return this.each((typeof value2 === "function" ? classedFunction : value2 ? classedTrue : classedFalse)(names, value2));
}

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value2) {
  return function() {
    this.textContent = value2;
  };
}
function textFunction(value2) {
  return function() {
    var v28 = value2.apply(this, arguments);
    this.textContent = v28 == null ? "" : v28;
  };
}
function text_default(value2) {
  return arguments.length ? this.each(value2 == null ? textRemove : (typeof value2 === "function" ? textFunction : textConstant)(value2)) : this.node().textContent;
}

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value2) {
  return function() {
    this.innerHTML = value2;
  };
}
function htmlFunction(value2) {
  return function() {
    var v28 = value2.apply(this, arguments);
    this.innerHTML = v28 == null ? "" : v28;
  };
}
function html_default(value2) {
  return arguments.length ? this.each(value2 == null ? htmlRemove : (typeof value2 === "function" ? htmlFunction : htmlConstant)(value2)) : this.node().innerHTML;
}

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/d3-selection/src/selection/append.js
function append_default(name2) {
  var create2 = typeof name2 === "function" ? name2 : creator_default(name2);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name2, before) {
  var create2 = typeof name2 === "function" ? name2 : creator_default(name2), select2 = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}

// node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value2) {
  return arguments.length ? this.property("__data__", value2) : this.node().__data__;
}

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t4) {
    var name2 = "", i8 = t4.indexOf(".");
    if (i8 >= 0) name2 = t4.slice(i8 + 1), t4 = t4.slice(0, i8);
    return { type: t4, name: name2 };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j6 = 0, i8 = -1, m30 = on.length, o2; j6 < m30; ++j6) {
      if (o2 = on[j6], (!typename.type || o2.type === typename.type) && o2.name === typename.name) {
        this.removeEventListener(o2.type, o2.listener, o2.options);
      } else {
        on[++i8] = o2;
      }
    }
    if (++i8) on.length = i8;
    else delete this.__on;
  };
}
function onAdd(typename, value2, options) {
  return function() {
    var on = this.__on, o2, listener = contextListener(value2);
    if (on) for (var j6 = 0, m30 = on.length; j6 < m30; ++j6) {
      if ((o2 = on[j6]).type === typename.type && o2.name === typename.name) {
        this.removeEventListener(o2.type, o2.listener, o2.options);
        this.addEventListener(o2.type, o2.listener = listener, o2.options = options);
        o2.value = value2;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o2 = { type: typename.type, name: typename.name, value: value2, listener, options };
    if (!on) this.__on = [o2];
    else on.push(o2);
  };
}
function on_default(typename, value2, options) {
  var typenames = parseTypenames(typename + ""), i8, n = typenames.length, t4;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j6 = 0, m30 = on.length, o2; j6 < m30; ++j6) {
      for (i8 = 0, o2 = on[j6]; i8 < n; ++i8) {
        if ((t4 = typenames[i8]).type === o2.type && t4.name === o2.name) {
          return o2.value;
        }
      }
    }
    return;
  }
  on = value2 ? onAdd : onRemove;
  for (i8 = 0; i8 < n; ++i8) this.each(on(typenames[i8], value2, options));
  return this;
}

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node4, type2, params) {
  var window2 = window_default(node4), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type2, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params) event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type2, false, false);
  }
  node4.dispatchEvent(event);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function dispatch_default2(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups2 = this._groups, j6 = 0, m30 = groups2.length; j6 < m30; ++j6) {
    for (var group3 = groups2[j6], i8 = 0, n = group3.length, node4; i8 < n; ++i8) {
      if (node4 = group3[i8]) yield node4;
    }
  }
}

// node_modules/d3-selection/src/selection/index.js
var root = [null];
function Selection(groups2, parents) {
  this._groups = groups2;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default2,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}

// node_modules/d3-selection/src/local.js
var nextId = 0;
function local() {
  return new Local();
}
function Local() {
  this._ = "@" + (++nextId).toString(36);
}
Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node4) {
    var id2 = this._;
    while (!(id2 in node4)) if (!(node4 = node4.parentNode)) return;
    return node4[id2];
  },
  set: function(node4, value2) {
    return node4[this._] = value2;
  },
  remove: function(node4) {
    return this._ in node4 && delete node4[this._];
  },
  toString: function() {
    return this._;
  }
};

// node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}

// node_modules/d3-selection/src/pointer.js
function pointer_default(event, node4) {
  event = sourceEvent_default(event);
  if (node4 === void 0) node4 = event.currentTarget;
  if (node4) {
    var svg = node4.ownerSVGElement || node4;
    if (svg.createSVGPoint) {
      var point13 = svg.createSVGPoint();
      point13.x = event.clientX, point13.y = event.clientY;
      point13 = point13.matrixTransform(node4.getScreenCTM().inverse());
      return [point13.x, point13.y];
    }
    if (node4.getBoundingClientRect) {
      var rect2 = node4.getBoundingClientRect();
      return [event.clientX - rect2.left - node4.clientLeft, event.clientY - rect2.top - node4.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}

// node_modules/@unovis/ts/types/component.js
var ComponentType;
(function(ComponentType2) {
  ComponentType2[ComponentType2["SVG"] = 0] = "SVG";
  ComponentType2[ComponentType2["HTML"] = 1] = "HTML";
})(ComponentType || (ComponentType = {}));
var Sizing;
(function(Sizing2) {
  Sizing2["Fit"] = "fit";
  Sizing2["Extend"] = "extend";
  Sizing2["FitWidth"] = "fit_width";
})(Sizing || (Sizing = {}));

// node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js
var resizeObservers = [];

// node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js
var hasActiveObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.activeTargets.length > 0;
  });
};

// node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js
var hasSkippedObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.skippedTargets.length > 0;
  });
};

// node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js
var msg = "ResizeObserver loop completed with undelivered notifications.";
var deliverResizeLoopError = function() {
  var event;
  if (typeof ErrorEvent === "function") {
    event = new ErrorEvent("error", {
      message: msg
    });
  } else {
    event = document.createEvent("Event");
    event.initEvent("error", false, false);
    event.message = msg;
  }
  window.dispatchEvent(event);
};

// node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js
var ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions2) {
  ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));

// node_modules/@juggle/resize-observer/lib/utils/freeze.js
var freeze = function(obj) {
  return Object.freeze(obj);
};

// node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js
var ResizeObserverSize = /* @__PURE__ */ (function() {
  function ResizeObserverSize2(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze(this);
  }
  return ResizeObserverSize2;
})();

// node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js
var DOMRectReadOnly = (function() {
  function DOMRectReadOnly2(x21, y25, width, height) {
    this.x = x21;
    this.y = y25;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze(this);
  }
  DOMRectReadOnly2.prototype.toJSON = function() {
    var _a = this, x21 = _a.x, y25 = _a.y, top2 = _a.top, right3 = _a.right, bottom2 = _a.bottom, left3 = _a.left, width = _a.width, height = _a.height;
    return { x: x21, y: y25, top: top2, right: right3, bottom: bottom2, left: left3, width, height };
  };
  DOMRectReadOnly2.fromRect = function(rectangle) {
    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };
  return DOMRectReadOnly2;
})();

// node_modules/@juggle/resize-observer/lib/utils/element.js
var isSVG = function(target) {
  return target instanceof SVGElement && "getBBox" in target;
};
var isHidden = function(target) {
  if (isSVG(target)) {
    var _a = target.getBBox(), width = _a.width, height = _a.height;
    return !width && !height;
  }
  var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement = function(obj) {
  var _a;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function(target) {
  switch (target.tagName) {
    case "INPUT":
      if (target.type !== "image") {
        break;
      }
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return true;
  }
  return false;
};

// node_modules/@juggle/resize-observer/lib/utils/global.js
var global = typeof window !== "undefined" ? window : {};

// node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js
var cache = /* @__PURE__ */ new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global.navigator && global.navigator.userAgent);
var parseDimension = function(pixel) {
  return parseFloat(pixel || "0");
};
var size = function(inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
  devicePixelContentBoxSize: size(),
  borderBoxSize: size(),
  contentBoxSize: size(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function(target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache.has(target) && !forceRecalculation) {
    return cache.get(target);
  }
  if (isHidden(target)) {
    cache.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === "border-box";
  var switchSizes = verticalRegexp.test(cs.writingMode || "");
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop2 = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight2 = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom2 = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft2 = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft2 + borderRight2;
  var verticalBorderArea = borderTop2 + borderBottom2;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze({
    devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache.set(target, boxes);
  return boxes;
};
var calculateBoxSize = function(target, observedBox, forceRecalculation) {
  var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};

// node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js
var ResizeObserverEntry = /* @__PURE__ */ (function() {
  function ResizeObserverEntry2(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze([boxes.borderBoxSize]);
    this.contentBoxSize = freeze([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry2;
})();

// node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js
var calculateDepthForNode = function(node4) {
  if (isHidden(node4)) {
    return Infinity;
  }
  var depth = 0;
  var parent = node4.parentNode;
  while (parent) {
    depth += 1;
    parent = parent.parentNode;
  }
  return depth;
};

// node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js
var broadcastActiveObservations = function() {
  var shallowestDepth = Infinity;
  var callbacks2 = [];
  resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries = [];
    ro.activeTargets.forEach(function processTarget(ot) {
      var entry = new ResizeObserverEntry(ot.target);
      var targetDepth2 = calculateDepthForNode(ot.target);
      entries.push(entry);
      ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
      if (targetDepth2 < shallowestDepth) {
        shallowestDepth = targetDepth2;
      }
    });
    callbacks2.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });
  for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
};

// node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js
var gatherActiveObservationsAtDepth = function(depth) {
  resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot) {
      if (ot.isActive()) {
        if (calculateDepthForNode(ot.target) > depth) {
          ro.activeTargets.push(ot);
        } else {
          ro.skippedTargets.push(ot);
        }
      }
    });
  });
};

// node_modules/@juggle/resize-observer/lib/utils/process.js
var process = function() {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth);
  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth);
  }
  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }
  return depth > 0;
};

// node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js
var trigger;
var callbacks = [];
var notify = function() {
  return callbacks.splice(0).forEach(function(cb) {
    return cb();
  });
};
var queueMicroTask = function(callback) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode("");
    var config = { characterData: true };
    new MutationObserver(function() {
      return notify();
    }).observe(el_1, config);
    trigger = function() {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback);
  trigger();
};

// node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js
var queueResizeObserver = function(cb) {
  queueMicroTask(function ResizeObserver3() {
    requestAnimationFrame(cb);
  });
};

// node_modules/@juggle/resize-observer/lib/utils/scheduler.js
var watching = 0;
var isWatching = function() {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
var events = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
];
var time = function(timeout) {
  if (timeout === void 0) {
    timeout = 0;
  }
  return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = (function() {
  function Scheduler2() {
    var _this = this;
    this.stopped = true;
    this.listener = function() {
      return _this.schedule();
    };
  }
  Scheduler2.prototype.run = function(timeout) {
    var _this = this;
    if (timeout === void 0) {
      timeout = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time(timeout);
    queueResizeObserver(function() {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = process();
      } finally {
        scheduled = false;
        timeout = until - time();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this.run(1e3);
        } else if (timeout > 0) {
          _this.run(timeout);
        } else {
          _this.start();
        }
      }
    });
  };
  Scheduler2.prototype.schedule = function() {
    this.stop();
    this.run();
  };
  Scheduler2.prototype.observe = function() {
    var _this = this;
    var cb = function() {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : global.addEventListener("DOMContentLoaded", cb);
  };
  Scheduler2.prototype.start = function() {
    var _this = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function(name2) {
        return global.addEventListener(name2, _this.listener, true);
      });
    }
  };
  Scheduler2.prototype.stop = function() {
    var _this = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function(name2) {
        return global.removeEventListener(name2, _this.listener, true);
      });
      this.stopped = true;
    }
  };
  return Scheduler2;
})();
var scheduler = new Scheduler();
var updateCount = function(n) {
  !watching && n > 0 && scheduler.start();
  watching += n;
  !watching && scheduler.stop();
};

// node_modules/@juggle/resize-observer/lib/ResizeObservation.js
var skipNotifyOnElement = function(target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
};
var ResizeObservation = (function() {
  function ResizeObservation2(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  ResizeObservation2.prototype.isActive = function() {
    var size2 = calculateBoxSize(this.target, this.observedBox, true);
    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size2;
    }
    if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation2;
})();

// node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js
var ResizeObserverDetail = /* @__PURE__ */ (function() {
  function ResizeObserverDetail2(resizeObserver, callback) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback;
  }
  return ResizeObserverDetail2;
})();

// node_modules/@juggle/resize-observer/lib/ResizeObserverController.js
var observerMap = /* @__PURE__ */ new WeakMap();
var getObservationIndex = function(observationTargets, target) {
  for (var i8 = 0; i8 < observationTargets.length; i8 += 1) {
    if (observationTargets[i8].target === target) {
      return i8;
    }
  }
  return -1;
};
var ResizeObserverController = (function() {
  function ResizeObserverController2() {
  }
  ResizeObserverController2.connect = function(resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  };
  ResizeObserverController2.observe = function(resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && resizeObservers.push(detail);
      detail.observationTargets.push(new ResizeObservation(target, options && options.box));
      updateCount(1);
      scheduler.schedule();
    }
  };
  ResizeObserverController2.unobserve = function(resizeObserver, target) {
    var detail = observerMap.get(resizeObserver);
    var index3 = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;
    if (index3 >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index3, 1);
      updateCount(-1);
    }
  };
  ResizeObserverController2.disconnect = function(resizeObserver) {
    var _this = this;
    var detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function(ot) {
      return _this.unobserve(resizeObserver, ot.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };
  return ResizeObserverController2;
})();

// node_modules/@juggle/resize-observer/lib/ResizeObserver.js
var ResizeObserver = (function() {
  function ResizeObserver3(callback) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (typeof callback !== "function") {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }
    ResizeObserverController.connect(this, callback);
  }
  ResizeObserver3.prototype.observe = function(target, options) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.observe(this, target, options);
  };
  ResizeObserver3.prototype.unobserve = function(target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.unobserve(this, target);
  };
  ResizeObserver3.prototype.disconnect = function() {
    ResizeObserverController.disconnect(this);
  };
  ResizeObserver3.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  };
  return ResizeObserver3;
})();

// node_modules/@unovis/ts/utils/resize-observer.js
var ResizeObserver2 = globalThis.ResizeObserver || ResizeObserver;

// node_modules/@unovis/ts/core/container/config.js
var ContainerDefaultConfig = {
  duration: void 0,
  margin: {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  },
  padding: {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  },
  sizing: Sizing.Fit,
  width: void 0,
  height: void 0,
  svgDefs: void 0,
  ariaLabel: void 0
};

// node_modules/@unovis/ts/core/container/index.js
var ContainerCore = class _ContainerCore {
  constructor(element) {
    this._defaultConfig = ContainerDefaultConfig;
    this._isFirstRender = true;
    this._renderAnimationFrameId = null;
    this._container = element;
    const container = select_default2(this._container);
    container.attr("role", "figure");
    this.svg = container.append("svg").style("display", "block").attr("xmlns", "http://www.w3.org/2000/svg").attr("height", _ContainerCore.DEFAULT_CONTAINER_HEIGHT).attr("aria-hidden", true);
    this._svgDefs = this.svg.append("defs");
    this._svgDefsExternal = this.svg.append("defs");
    this.element = this.svg.node();
  }
  updateContainer(config) {
    var _a;
    this.prevConfig = this.config;
    this.config = merge2(this._defaultConfig, config);
    if ((config === null || config === void 0 ? void 0 : config.svgDefs) !== ((_a = this.prevConfig) === null || _a === void 0 ? void 0 : _a.svgDefs)) {
      this._svgDefsExternal.selectAll("*").remove();
      this._svgDefsExternal.html(config.svgDefs);
    }
  }
  // The `_preRender` step should be used to perform some actions before rendering.
  // For example, calculating scales, setting component sizes, etc ...
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  _preRender() {
  }
  // The `_render` step should be used to perform the actual rendering
  _render(duration) {
    const { config } = this;
    select_default2(this._container).attr("aria-label", config.ariaLabel);
    this._isFirstRender = false;
  }
  // Warning: Some Containers (i.e. Single Container) may override this method, so if you introduce any changes here,
  // make sure to check that other containers didn't break after them.
  render(duration = this.config.duration) {
    const width = this.config.width || this.containerWidth;
    const height = this.config.height || this.containerHeight;
    this.svg.attr("width", width).attr("height", height);
    if (!this._resizeObserver)
      this._setUpResizeObserver();
    cancelAnimationFrame(this._renderAnimationFrameId);
    this._renderAnimationFrameId = requestAnimationFrame(() => {
      this._preRender();
      this._render(duration);
    });
  }
  get containerWidth() {
    return this.config.width ? this.element.clientWidth : this._container.clientWidth || this._container.getBoundingClientRect().width;
  }
  get containerHeight() {
    return this.config.height ? this.element.clientHeight : this._container.clientHeight || this._container.getBoundingClientRect().height || _ContainerCore.DEFAULT_CONTAINER_HEIGHT;
  }
  get width() {
    return clamp(this.containerWidth - this.config.margin.left - this.config.margin.right, 0, Number.POSITIVE_INFINITY);
  }
  get height() {
    return clamp(this.containerHeight - this.config.margin.top - this.config.margin.bottom, 0, Number.POSITIVE_INFINITY);
  }
  _removeAllChildren() {
    while (this.element.firstChild) {
      this.element.removeChild(this.element.firstChild);
    }
  }
  _onResize() {
    const { config } = this;
    const redrawOnResize = config.sizing === Sizing.Fit || config.sizing === Sizing.FitWidth;
    if (redrawOnResize)
      this.render(0);
  }
  _setUpResizeObserver() {
    if (this._resizeObserver)
      return;
    const containerRect = this._container.getBoundingClientRect();
    this._containerSize = { width: containerRect.width, height: containerRect.height };
    this._resizeObserver = new ResizeObserver2((entries, observer) => {
      cancelAnimationFrame(this._resizeObserverAnimationFrameId);
      this._resizeObserverAnimationFrameId = requestAnimationFrame(() => {
        const resizedContainerRect = this._container.getBoundingClientRect();
        const resizedContainerSize = { width: resizedContainerRect.width, height: resizedContainerRect.height };
        const hasSizeChanged = !isEqual(this._containerSize, resizedContainerSize);
        if (hasSizeChanged && resizedContainerSize.width && resizedContainerSize.height) {
          this._containerSize = resizedContainerSize;
          this._onResize();
        }
      });
    });
    this._resizeObserver.observe(this._container);
  }
  destroy() {
    var _a;
    cancelAnimationFrame(this._renderAnimationFrameId);
    cancelAnimationFrame(this._resizeObserverAnimationFrameId);
    (_a = this._resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    this.svg.remove();
  }
};
ContainerCore.DEFAULT_CONTAINER_HEIGHT = 300;

// node_modules/@unovis/ts/utils/misc.js
var import_to_px = __toESM(require_browser(), 1);
function guid() {
  const s42 = () => Math.floor((1 + crypto.getRandomValues(new Uint32Array(1))[0]) * 65536).toString(16).substring(1);
  return `${s42() + s42()}-${s42()}-${s42()}-${s42()}-${s42()}${s42()}${s42()}`;
}
function isStringCSSVariable(s12) {
  return isString(s12) ? s12.substring(0, 6) === "var(--" : false;
}
function getCSSVariableValue(s12, context) {
  if (!isString(s12))
    return "";
  const variableName = s12.substr(4, s12.length - 5);
  return getComputedStyle(context).getPropertyValue(variableName);
}
function getCSSVariableValueInPixels(s12, context) {
  const val = getCSSVariableValue(s12, context);
  return (0, import_to_px.default)(val);
}
function getPixelValue(v28) {
  return typeof v28 === "number" ? v28 : (0, import_to_px.default)(v28);
}
function rectIntersect(rect1, rect2, tolerancePx = 0) {
  const [left1, top1, right1, bottom1] = [
    rect1.x + tolerancePx,
    rect1.y + rect1.height - 2 * tolerancePx,
    rect1.x + rect1.width - 2 * tolerancePx,
    rect1.y + tolerancePx
  ];
  const [left22, top2, right22, bottom2] = [
    rect2.x + tolerancePx,
    rect2.y + rect2.height - 2 * tolerancePx,
    rect2.x + rect2.width - 2 * tolerancePx,
    rect2.y + tolerancePx
  ];
  return !(top1 < bottom2 || top2 < bottom1 || right1 < left22 || right22 < left1);
}
function parseUnit(value2, basis2 = 0) {
  if (!value2)
    return 0;
  else if (typeof value2 === "number")
    return value2;
  else if (value2.endsWith("%"))
    return basis2 * parseFloat(value2) / 100;
  else if (value2.endsWith("px"))
    return parseFloat(value2);
  else
    return parseFloat(value2) || 0;
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m30, l7;
  format2 = (format2 + "").trim().toLowerCase();
  return (m30 = reHex.exec(format2)) ? (l7 = m30[1].length, m30 = parseInt(m30[1], 16), l7 === 6 ? rgbn(m30) : l7 === 3 ? new Rgb(m30 >> 8 & 15 | m30 >> 4 & 240, m30 >> 4 & 15 | m30 & 240, (m30 & 15) << 4 | m30 & 15, 1) : l7 === 8 ? rgba(m30 >> 24 & 255, m30 >> 16 & 255, m30 >> 8 & 255, (m30 & 255) / 255) : l7 === 4 ? rgba(m30 >> 12 & 15 | m30 >> 8 & 240, m30 >> 8 & 15 | m30 >> 4 & 240, m30 >> 4 & 15 | m30 & 240, ((m30 & 15) << 4 | m30 & 15) / 255) : null) : (m30 = reRgbInteger.exec(format2)) ? new Rgb(m30[1], m30[2], m30[3], 1) : (m30 = reRgbPercent.exec(format2)) ? new Rgb(m30[1] * 255 / 100, m30[2] * 255 / 100, m30[3] * 255 / 100, 1) : (m30 = reRgbaInteger.exec(format2)) ? rgba(m30[1], m30[2], m30[3], m30[4]) : (m30 = reRgbaPercent.exec(format2)) ? rgba(m30[1] * 255 / 100, m30[2] * 255 / 100, m30[3] * 255 / 100, m30[4]) : (m30 = reHslPercent.exec(format2)) ? hsla(m30[1], m30[2] / 100, m30[3] / 100, 1) : (m30 = reHslaPercent.exec(format2)) ? hsla(m30[1], m30[2] / 100, m30[3] / 100, m30[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r4, g15, b25, a7) {
  if (a7 <= 0) r4 = g15 = b25 = NaN;
  return new Rgb(r4, g15, b25, a7);
}
function rgbConvert(o2) {
  if (!(o2 instanceof Color)) o2 = color(o2);
  if (!o2) return new Rgb();
  o2 = o2.rgb();
  return new Rgb(o2.r, o2.g, o2.b, o2.opacity);
}
function rgb(r4, g15, b25, opacity) {
  return arguments.length === 1 ? rgbConvert(r4) : new Rgb(r4, g15, b25, opacity == null ? 1 : opacity);
}
function Rgb(r4, g15, b25, opacity) {
  this.r = +r4;
  this.g = +g15;
  this.b = +b25;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k17) {
    k17 = k17 == null ? brighter : Math.pow(brighter, k17);
    return new Rgb(this.r * k17, this.g * k17, this.b * k17, this.opacity);
  },
  darker(k17) {
    k17 = k17 == null ? darker : Math.pow(darker, k17);
    return new Rgb(this.r * k17, this.g * k17, this.b * k17, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a7 = clampa(this.opacity);
  return `${a7 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a7 === 1 ? ")" : `, ${a7})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value2) {
  return Math.max(0, Math.min(255, Math.round(value2) || 0));
}
function hex(value2) {
  value2 = clampi(value2);
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla(h17, s12, l7, a7) {
  if (a7 <= 0) h17 = s12 = l7 = NaN;
  else if (l7 <= 0 || l7 >= 1) h17 = s12 = NaN;
  else if (s12 <= 0) h17 = NaN;
  return new Hsl(h17, s12, l7, a7);
}
function hslConvert(o2) {
  if (o2 instanceof Hsl) return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Color)) o2 = color(o2);
  if (!o2) return new Hsl();
  if (o2 instanceof Hsl) return o2;
  o2 = o2.rgb();
  var r4 = o2.r / 255, g15 = o2.g / 255, b25 = o2.b / 255, min7 = Math.min(r4, g15, b25), max8 = Math.max(r4, g15, b25), h17 = NaN, s12 = max8 - min7, l7 = (max8 + min7) / 2;
  if (s12) {
    if (r4 === max8) h17 = (g15 - b25) / s12 + (g15 < b25) * 6;
    else if (g15 === max8) h17 = (b25 - r4) / s12 + 2;
    else h17 = (r4 - g15) / s12 + 4;
    s12 /= l7 < 0.5 ? max8 + min7 : 2 - max8 - min7;
    h17 *= 60;
  } else {
    s12 = l7 > 0 && l7 < 1 ? 0 : h17;
  }
  return new Hsl(h17, s12, l7, o2.opacity);
}
function hsl(h17, s12, l7, opacity) {
  return arguments.length === 1 ? hslConvert(h17) : new Hsl(h17, s12, l7, opacity == null ? 1 : opacity);
}
function Hsl(h17, s12, l7, opacity) {
  this.h = +h17;
  this.s = +s12;
  this.l = +l7;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k17) {
    k17 = k17 == null ? brighter : Math.pow(brighter, k17);
    return new Hsl(this.h, this.s, this.l * k17, this.opacity);
  },
  darker(k17) {
    k17 = k17 == null ? darker : Math.pow(darker, k17);
    return new Hsl(this.h, this.s, this.l * k17, this.opacity);
  },
  rgb() {
    var h17 = this.h % 360 + (this.h < 0) * 360, s12 = isNaN(h17) || isNaN(this.s) ? 0 : this.s, l7 = this.l, m210 = l7 + (l7 < 0.5 ? l7 : 1 - l7) * s12, m1 = 2 * l7 - m210;
    return new Rgb(
      hsl2rgb(h17 >= 240 ? h17 - 240 : h17 + 120, m1, m210),
      hsl2rgb(h17, m1, m210),
      hsl2rgb(h17 < 120 ? h17 + 240 : h17 - 120, m1, m210),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a7 = clampa(this.opacity);
    return `${a7 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a7 === 1 ? ")" : `, ${a7})`}`;
  }
}));
function clamph(value2) {
  value2 = (value2 || 0) % 360;
  return value2 < 0 ? value2 + 360 : value2;
}
function clampt(value2) {
  return Math.max(0, Math.min(1, value2 || 0));
}
function hsl2rgb(h17, m1, m210) {
  return (h17 < 60 ? m1 + (m210 - m1) * h17 / 60 : h17 < 180 ? m210 : h17 < 240 ? m1 + (m210 - m1) * (240 - h17) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o2) {
  if (o2 instanceof Lab) return new Lab(o2.l, o2.a, o2.b, o2.opacity);
  if (o2 instanceof Hcl) return hcl2lab(o2);
  if (!(o2 instanceof Rgb)) o2 = rgbConvert(o2);
  var r4 = rgb2lrgb(o2.r), g15 = rgb2lrgb(o2.g), b25 = rgb2lrgb(o2.b), y25 = xyz2lab((0.2225045 * r4 + 0.7168786 * g15 + 0.0606169 * b25) / Yn), x21, z3;
  if (r4 === g15 && g15 === b25) x21 = z3 = y25;
  else {
    x21 = xyz2lab((0.4360747 * r4 + 0.3850649 * g15 + 0.1430804 * b25) / Xn);
    z3 = xyz2lab((0.0139322 * r4 + 0.0971045 * g15 + 0.7141733 * b25) / Zn);
  }
  return new Lab(116 * y25 - 16, 500 * (x21 - y25), 200 * (y25 - z3), o2.opacity);
}
function lab(l7, a7, b25, opacity) {
  return arguments.length === 1 ? labConvert(l7) : new Lab(l7, a7, b25, opacity == null ? 1 : opacity);
}
function Lab(l7, a7, b25, opacity) {
  this.l = +l7;
  this.a = +a7;
  this.b = +b25;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend(Color, {
  brighter(k17) {
    return new Lab(this.l + K * (k17 == null ? 1 : k17), this.a, this.b, this.opacity);
  },
  darker(k17) {
    return new Lab(this.l - K * (k17 == null ? 1 : k17), this.a, this.b, this.opacity);
  },
  rgb() {
    var y25 = (this.l + 16) / 116, x21 = isNaN(this.a) ? y25 : y25 + this.a / 500, z3 = isNaN(this.b) ? y25 : y25 - this.b / 200;
    x21 = Xn * lab2xyz(x21);
    y25 = Yn * lab2xyz(y25);
    z3 = Zn * lab2xyz(z3);
    return new Rgb(
      lrgb2rgb(3.1338561 * x21 - 1.6168667 * y25 - 0.4906146 * z3),
      lrgb2rgb(-0.9787684 * x21 + 1.9161415 * y25 + 0.033454 * z3),
      lrgb2rgb(0.0719453 * x21 - 0.2289914 * y25 + 1.4052427 * z3),
      this.opacity
    );
  }
}));
function xyz2lab(t4) {
  return t4 > t3 ? Math.pow(t4, 1 / 3) : t4 / t2 + t0;
}
function lab2xyz(t4) {
  return t4 > t1 ? t4 * t4 * t4 : t2 * (t4 - t0);
}
function lrgb2rgb(x21) {
  return 255 * (x21 <= 31308e-7 ? 12.92 * x21 : 1.055 * Math.pow(x21, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x21) {
  return (x21 /= 255) <= 0.04045 ? x21 / 12.92 : Math.pow((x21 + 0.055) / 1.055, 2.4);
}
function hclConvert(o2) {
  if (o2 instanceof Hcl) return new Hcl(o2.h, o2.c, o2.l, o2.opacity);
  if (!(o2 instanceof Lab)) o2 = labConvert(o2);
  if (o2.a === 0 && o2.b === 0) return new Hcl(NaN, 0 < o2.l && o2.l < 100 ? 0 : NaN, o2.l, o2.opacity);
  var h17 = Math.atan2(o2.b, o2.a) * degrees;
  return new Hcl(h17 < 0 ? h17 + 360 : h17, Math.sqrt(o2.a * o2.a + o2.b * o2.b), o2.l, o2.opacity);
}
function hcl(h17, c6, l7, opacity) {
  return arguments.length === 1 ? hclConvert(h17) : new Hcl(h17, c6, l7, opacity == null ? 1 : opacity);
}
function Hcl(h17, c6, l7, opacity) {
  this.h = +h17;
  this.c = +c6;
  this.l = +l7;
  this.opacity = +opacity;
}
function hcl2lab(o2) {
  if (isNaN(o2.h)) return new Lab(o2.l, 0, 0, o2.opacity);
  var h17 = o2.h * radians;
  return new Lab(o2.l, Math.cos(h17) * o2.c, Math.sin(h17) * o2.c, o2.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter(k17) {
    return new Hcl(this.h, this.c, this.l + K * (k17 == null ? 1 : k17), this.opacity);
  },
  darker(k17) {
    return new Hcl(this.h, this.c, this.l - K * (k17 == null ? 1 : k17), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o2) {
  if (o2 instanceof Cubehelix) return new Cubehelix(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Rgb)) o2 = rgbConvert(o2);
  var r4 = o2.r / 255, g15 = o2.g / 255, b25 = o2.b / 255, l7 = (BC_DA * b25 + ED * r4 - EB * g15) / (BC_DA + ED - EB), bl = b25 - l7, k17 = (E * (g15 - l7) - C * bl) / D, s12 = Math.sqrt(k17 * k17 + bl * bl) / (E * l7 * (1 - l7)), h17 = s12 ? Math.atan2(k17, bl) * degrees - 120 : NaN;
  return new Cubehelix(h17 < 0 ? h17 + 360 : h17, s12, l7, o2.opacity);
}
function cubehelix(h17, s12, l7, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h17) : new Cubehelix(h17, s12, l7, opacity == null ? 1 : opacity);
}
function Cubehelix(h17, s12, l7, opacity) {
  this.h = +h17;
  this.s = +s12;
  this.l = +l7;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter(k17) {
    k17 = k17 == null ? brighter : Math.pow(brighter, k17);
    return new Cubehelix(this.h, this.s, this.l * k17, this.opacity);
  },
  darker(k17) {
    k17 = k17 == null ? darker : Math.pow(darker, k17);
    return new Cubehelix(this.h, this.s, this.l * k17, this.opacity);
  },
  rgb() {
    var h17 = isNaN(this.h) ? 0 : (this.h + 120) * radians, l7 = +this.l, a7 = isNaN(this.s) ? 0 : this.s * l7 * (1 - l7), cosh3 = Math.cos(h17), sinh3 = Math.sin(h17);
    return new Rgb(
      255 * (l7 + a7 * (A * cosh3 + B * sinh3)),
      255 * (l7 + a7 * (C * cosh3 + D * sinh3)),
      255 * (l7 + a7 * (E * cosh3)),
      this.opacity
    );
  }
}));

// node_modules/@unovis/ts/styles/colors.js
var colors = (globalThis === null || globalThis === void 0 ? void 0 : globalThis.UNOVIS_COLORS) || ["#4D8CFD", "#FF6B7E", "#F4B83E", "#A6CC74", "#00C19A", "#6859BE"];
var colorsDark = (globalThis === null || globalThis === void 0 ? void 0 : globalThis.UNOVIS_COLORS_DARK) || ["#4D8CFD", "#FF6B7E", "#FFC16D", "#A6CC74", "#00C19A", "#7887E0"];
var getCSSColorVariable = (suffix) => {
  return `--vis-${isNumber(suffix) ? `color${suffix % colors.length}` : suffix}`;
};
function getLighterColor(hex2, percentage = 0.4) {
  const c6 = hsl(hex2);
  c6.l = c6.l * (1 + percentage);
  return c6.formatHex();
}
function getDarkerColor(hex2, percentageL = 0.4, percentageS = 0.6) {
  const c6 = hsl(hex2);
  c6.s = c6.s * (1 - percentageS);
  c6.l = c6.l * (1 - percentageL);
  return c6.formatHex();
}

// node_modules/@unovis/ts/styles/patterns.js
var PATTERN_SIZE_PX = 10;
var fills = [
  { id: "stripes-diagonal", svg: '<path d="M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2" stroke="#000"/>' },
  { id: "dots", svg: '<path d="m0-1.5a1 1 0 010 3m10-3a1 1 0 000 3M5 3.5a1 1 0 010 3 1 1 0 010-3M0 8.5 a1 1 0 010 3m10-3a1 1 0 000 3" fill"#000"/>' },
  { id: "stripes-vertical", svg: '<path d="M 5,-1 L5,11" stroke="#000"/>' },
  { id: "crosshatch", svg: '<path d="M0 0L10 10ZM10 0L0 10Z" stroke="#000"/>' },
  { id: "waves", svg: '<path d="M0 4Q2.5 1 5 4 7.5 7 10 4v2Q7.5 9 5 6 2.5 3 0 6Z" fill="#000"/>' },
  { id: "circles", svg: '<circle cx="5" cy="5" r="3" stroke="#000" fill="#fff"/>' }
];
var lines = [
  { id: "circle", marker: '<circle cx="5" cy="5" r="5"/>', dashArray: [] },
  { id: "triangle", marker: '<path d="M5,0 L10,9 L0,9Z">', dashArray: [9, 1] },
  { id: "diamond", marker: '<path d="M 0 5 L5 0 L 10 5 L 5 10 L 0 5Z">', dashArray: [2] },
  { id: "arrow", marker: '<path d="M4 0 0 0 6 5 0 10 4 10 10 5Z">', dashArray: [2, 3, 8, 3] },
  { id: "square", marker: '<rect x="1" y="1" width="8" height="8"/>', dashArray: [6] },
  { id: "star", marker: '<path d="m2 9 3-9 3 9L0 3h10Z"/>', dashArray: [1, 6] }
];
function getPatternVariable(p13) {
  return `vis-${`pattern-${p13.svg ? "fill" : "marker"}`}-${p13.id}`;
}
var maskDef = (p13) => `<mask id="${getPatternVariable(p13)}">
    <pattern id="${p13.id}" viewBox="0 0 10 10" width="${PATTERN_SIZE_PX}" height="${PATTERN_SIZE_PX}" patternUnits="userSpaceOnUse">
      <rect width="100%" height="100%" fill="#fff"/>
      ${p13.svg}
    </pattern>
    <rect x="-50%" y="-50%" width="200%" height="200%" fill="url(#${p13.id})"/>
  </mask>`;
var markerDef = (p13, i8) => `<marker id="${getPatternVariable(p13)}"
    fill="var(${getCSSColorVariable(i8)})"
    markerUnits="userSpaceOnUse"
    refX="5"
    refY="5"
    markerWidth="${PATTERN_SIZE_PX}"
    markerHeight="${PATTERN_SIZE_PX}">
    ${p13.marker}
  </marker>`;
function injectSVGDefs() {
  const svgDefs = fills.map(maskDef).concat(lines.map(markerDef)).join("");
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.setAttribute("height", "100%");
  svg.setAttribute("width", "100%");
  svg.style.position = "fixed";
  svg.style.zIndex = "-99999999";
  svg.innerHTML = `<defs>${svgDefs}</defs>`;
  document.body.appendChild(svg);
}
if (typeof window !== "undefined")
  injectSVGDefs();

// node_modules/@unovis/ts/styles/index.js
var UNOVIS_ICON_FONT_FAMILY_DEFAULT = (globalThis === null || globalThis === void 0 ? void 0 : globalThis.UNOVIS_ICON_FONT_FAMILY) || "FontAwesome";
var UNOVIS_FONT_WH_RATIO_DEFAULT = (globalThis === null || globalThis === void 0 ? void 0 : globalThis.UNOVIS_FONT_W2H_RATIO_DEFAULT) || 0.5;
var UNOVIS_TEXT_SEPARATOR_DEFAULT = (globalThis === null || globalThis === void 0 ? void 0 : globalThis.UNOVIS_TEXT_SEPARATOR_DEFAULT) || [" ", "-", ".", ","];
var UNOVIS_TEXT_HYPHEN_CHARACTER_DEFAULT = (globalThis === null || globalThis === void 0 ? void 0 : globalThis.UNOVIS_TEXT_HYPHEN_CHARACTER_DEFAULT) || "-";
var UNOVIS_TEXT_DEFAULT = (globalThis === null || globalThis === void 0 ? void 0 : globalThis.UNOVIS_TEXT_DEFAULT) || {
  // If you change these defaults, don't forget to update the values in the `UnovisText` type in `types/text.ts`
  text: "",
  fontSize: 12,
  fontFamily: "var(--vis-font-family)",
  lineHeight: 1.25,
  marginTop: 0,
  marginBottom: 0
};
var variables = injectGlobal`
  :root {
    label: vis-root-styles;
    --vis-font-family: Inter, Arial, "Helvetica Neue", Helvetica, sans-serif;
    --vis-font-wh-ratio: ${UNOVIS_FONT_WH_RATIO_DEFAULT};
    --vis-color-main: var(${getCSSColorVariable(0)});
    --vis-color-main-light: ${getLighterColor(colors[0])};
    --vis-color-main-dark: ${getDarkerColor(colors[0])};
    --vis-color-grey: #2a2a2a;
    ${colors.map((c6, i8) => `${getCSSColorVariable(i8)}: ${c6};`)}
    ${colorsDark.map((c6, i8) => `--vis-dark-color${i8}: ${c6};`)}
    ${fills.map((p13, i8) => `
      --${getPatternVariable(p13)}: url(#${getPatternVariable(p13)});
      --vis-pattern-fill${i8}: var(--${getPatternVariable(p13)});
    `)}
    ${lines.map((p13, i8) => {
  var _a;
  return `
      --${getPatternVariable(p13)}: url(#${getPatternVariable(p13)});
      --vis-pattern-marker${i8}: var(--${getPatternVariable(p13)});
      --vis-pattern-dasharray${i8}: ${(_a = p13.dashArray) === null || _a === void 0 ? void 0 : _a.join(" ")};
    `;
})}

    body.theme-dark {
      ${colors.map((c6, i8) => `${getCSSColorVariable(i8)}: var(--vis-dark-color${i8});`)}
    }

    body.theme-patterns {
      ${fills.map((_17, i8) => `path[style*="fill: var(${getCSSColorVariable(i8)})"]  {
        mask: var(--vis-pattern-fill${i8});
      }`)}
      ${lines.map((_17, i8) => `
      path[stroke="var(${getCSSColorVariable(i8)})"]:not([style*="fill"]),
      path[style*="stroke: var(${getCSSColorVariable(i8)})"]:not([style*="fill"]) {
        marker: var(--vis-pattern-marker${i8});
        stroke-dasharray: var(--vis-pattern-dasharray${i8});
      }
    `)}
}
`;
function getFontWidthToHeightRatio(context = window === null || window === void 0 ? void 0 : window.document.body) {
  return context ? +getCSSVariableValue("var(--vis-font-wh-ratio)", context) : UNOVIS_FONT_WH_RATIO_DEFAULT;
}

// node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node4, name2, id2, index3, group3, timing) {
  var schedules = node4.__transition;
  if (!schedules) node4.__transition = {};
  else if (id2 in schedules) return;
  create(node4, id2, {
    name: name2,
    index: index3,
    // For context during callback.
    group: group3,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node4, id2) {
  var schedule = get(node4, id2);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}
function set(node4, id2) {
  var schedule = get(node4, id2);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}
function get(node4, id2) {
  var schedule = node4.__transition;
  if (!schedule || !(schedule = schedule[id2])) throw new Error("transition not found");
  return schedule;
}
function create(node4, id2, self) {
  var schedules = node4.__transition, tween;
  schedules[id2] = self;
  self.timer = timer(schedule, 0, self.time);
  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start2, self.delay, self.time);
    if (self.delay <= elapsed) start2(elapsed - self.delay);
  }
  function start2(elapsed) {
    var i8, j6, n, o2;
    if (self.state !== SCHEDULED) return stop();
    for (i8 in schedules) {
      o2 = schedules[i8];
      if (o2.name !== self.name) continue;
      if (o2.state === STARTED) return timeout_default(start2);
      if (o2.state === RUNNING) {
        o2.state = ENDED;
        o2.timer.stop();
        o2.on.call("interrupt", node4, node4.__data__, o2.index, o2.group);
        delete schedules[i8];
      } else if (+i8 < id2) {
        o2.state = ENDED;
        o2.timer.stop();
        o2.on.call("cancel", node4, node4.__data__, o2.index, o2.group);
        delete schedules[i8];
      }
    }
    timeout_default(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick2, self.delay, self.time);
        tick2(elapsed);
      }
    });
    self.state = STARTING;
    self.on.call("start", node4, node4.__data__, self.index, self.group);
    if (self.state !== STARTING) return;
    self.state = STARTED;
    tween = new Array(n = self.tween.length);
    for (i8 = 0, j6 = -1; i8 < n; ++i8) {
      if (o2 = self.tween[i8].value.call(node4, node4.__data__, self.index, self.group)) {
        tween[++j6] = o2;
      }
    }
    tween.length = j6 + 1;
  }
  function tick2(elapsed) {
    var t4 = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i8 = -1, n = tween.length;
    while (++i8 < n) {
      tween[i8].call(node4, t4);
    }
    if (self.state === ENDING) {
      self.on.call("end", node4, node4.__data__, self.index, self.group);
      stop();
    }
  }
  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id2];
    for (var i8 in schedules) return;
    delete node4.__transition;
  }
}

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node4, name2) {
  var schedules = node4.__transition, schedule, active, empty3 = true, i8;
  if (!schedules) return;
  name2 = name2 == null ? null : name2 + "";
  for (i8 in schedules) {
    if ((schedule = schedules[i8]).name !== name2) {
      empty3 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node4, node4.__data__, schedule.index, schedule.group);
    delete schedules[i8];
  }
  if (empty3) delete node4.__transition;
}

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name2) {
  return this.each(function() {
    interrupt_default(this, name2);
  });
}

// node_modules/d3-interpolate/src/basis.js
function basis(t13, v0, v1, v28, v32) {
  var t22 = t13 * t13, t32 = t22 * t13;
  return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v28 + t32 * v32) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t4) {
    var i8 = t4 <= 0 ? t4 = 0 : t4 >= 1 ? (t4 = 1, n - 1) : Math.floor(t4 * n), v1 = values[i8], v28 = values[i8 + 1], v0 = i8 > 0 ? values[i8 - 1] : 2 * v1 - v28, v32 = i8 < n - 1 ? values[i8 + 2] : 2 * v28 - v1;
    return basis((t4 - i8 / n) * n, v0, v1, v28, v32);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t4) {
    var i8 = Math.floor(((t4 %= 1) < 0 ? ++t4 : t4) * n), v0 = values[(i8 + n - 1) % n], v1 = values[i8 % n], v28 = values[(i8 + 1) % n], v32 = values[(i8 + 2) % n];
    return basis((t4 - i8 / n) * n, v0, v1, v28, v32);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default2 = (x21) => () => x21;

// node_modules/d3-interpolate/src/color.js
function linear(a7, d18) {
  return function(t4) {
    return a7 + t4 * d18;
  };
}
function exponential(a7, b25, y25) {
  return a7 = Math.pow(a7, y25), b25 = Math.pow(b25, y25) - a7, y25 = 1 / y25, function(t4) {
    return Math.pow(a7 + t4 * b25, y25);
  };
}
function hue(a7, b25) {
  var d18 = b25 - a7;
  return d18 ? linear(a7, d18 > 180 || d18 < -180 ? d18 - 360 * Math.round(d18 / 360) : d18) : constant_default2(isNaN(a7) ? b25 : a7);
}
function gamma(y25) {
  return (y25 = +y25) === 1 ? nogamma : function(a7, b25) {
    return b25 - a7 ? exponential(a7, b25, y25) : constant_default2(isNaN(a7) ? b25 : a7);
  };
}
function nogamma(a7, b25) {
  var d18 = b25 - a7;
  return d18 ? linear(a7, d18) : constant_default2(isNaN(a7) ? b25 : a7);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = (function rgbGamma(y25) {
  var color2 = gamma(y25);
  function rgb2(start2, end) {
    var r4 = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g15 = color2(start2.g, end.g), b25 = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t4) {
      start2.r = r4(t4);
      start2.g = g15(t4);
      start2.b = b25(t4);
      start2.opacity = opacity(t4);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
})(1);
function rgbSpline(spline) {
  return function(colors2) {
    var n = colors2.length, r4 = new Array(n), g15 = new Array(n), b25 = new Array(n), i8, color2;
    for (i8 = 0; i8 < n; ++i8) {
      color2 = rgb(colors2[i8]);
      r4[i8] = color2.r || 0;
      g15[i8] = color2.g || 0;
      b25[i8] = color2.b || 0;
    }
    r4 = spline(r4);
    g15 = spline(g15);
    b25 = spline(b25);
    color2.opacity = 1;
    return function(t4) {
      color2.r = r4(t4);
      color2.g = g15(t4);
      color2.b = b25(t4);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a7, b25) {
  if (!b25) b25 = [];
  var n = a7 ? Math.min(b25.length, a7.length) : 0, c6 = b25.slice(), i8;
  return function(t4) {
    for (i8 = 0; i8 < n; ++i8) c6[i8] = a7[i8] * (1 - t4) + b25[i8] * t4;
    return c6;
  };
}
function isNumberArray(x21) {
  return ArrayBuffer.isView(x21) && !(x21 instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a7, b25) {
  var nb = b25 ? b25.length : 0, na = a7 ? Math.min(nb, a7.length) : 0, x21 = new Array(na), c6 = new Array(nb), i8;
  for (i8 = 0; i8 < na; ++i8) x21[i8] = value_default(a7[i8], b25[i8]);
  for (; i8 < nb; ++i8) c6[i8] = b25[i8];
  return function(t4) {
    for (i8 = 0; i8 < na; ++i8) c6[i8] = x21[i8](t4);
    return c6;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a7, b25) {
  var d18 = /* @__PURE__ */ new Date();
  return a7 = +a7, b25 = +b25, function(t4) {
    return d18.setTime(a7 * (1 - t4) + b25 * t4), d18;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a7, b25) {
  return a7 = +a7, b25 = +b25, function(t4) {
    return a7 * (1 - t4) + b25 * t4;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a7, b25) {
  var i8 = {}, c6 = {}, k17;
  if (a7 === null || typeof a7 !== "object") a7 = {};
  if (b25 === null || typeof b25 !== "object") b25 = {};
  for (k17 in b25) {
    if (k17 in a7) {
      i8[k17] = value_default(a7[k17], b25[k17]);
    } else {
      c6[k17] = b25[k17];
    }
  }
  return function(t4) {
    for (k17 in i8) c6[k17] = i8[k17](t4);
    return c6;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero(b25) {
  return function() {
    return b25;
  };
}
function one(b25) {
  return function(t4) {
    return b25(t4) + "";
  };
}
function string_default(a7, b25) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i8 = -1, s12 = [], q3 = [];
  a7 = a7 + "", b25 = b25 + "";
  while ((am = reA.exec(a7)) && (bm = reB.exec(b25))) {
    if ((bs = bm.index) > bi) {
      bs = b25.slice(bi, bs);
      if (s12[i8]) s12[i8] += bs;
      else s12[++i8] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s12[i8]) s12[i8] += bm;
      else s12[++i8] = bm;
    } else {
      s12[++i8] = null;
      q3.push({ i: i8, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b25.length) {
    bs = b25.slice(bi);
    if (s12[i8]) s12[i8] += bs;
    else s12[++i8] = bs;
  }
  return s12.length < 2 ? q3[0] ? one(q3[0].x) : zero(b25) : (b25 = q3.length, function(t4) {
    for (var i9 = 0, o2; i9 < b25; ++i9) s12[(o2 = q3[i9]).i] = o2.x(t4);
    return s12.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a7, b25) {
  var t4 = typeof b25, c6;
  return b25 == null || t4 === "boolean" ? constant_default2(b25) : (t4 === "number" ? number_default : t4 === "string" ? (c6 = color(b25)) ? (b25 = c6, rgb_default) : string_default : b25 instanceof color ? rgb_default : b25 instanceof Date ? date_default : isNumberArray(b25) ? numberArray_default : Array.isArray(b25) ? genericArray : typeof b25.valueOf !== "function" && typeof b25.toString !== "function" || isNaN(b25) ? object_default : number_default)(a7, b25);
}

// node_modules/d3-interpolate/src/round.js
function round_default(a7, b25) {
  return a7 = +a7, b25 = +b25, function(t4) {
    return Math.round(a7 * (1 - t4) + b25 * t4);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a7, b25, c6, d18, e3, f29) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a7 * a7 + b25 * b25)) a7 /= scaleX, b25 /= scaleX;
  if (skewX = a7 * c6 + b25 * d18) c6 -= a7 * skewX, d18 -= b25 * skewX;
  if (scaleY = Math.sqrt(c6 * c6 + d18 * d18)) c6 /= scaleY, d18 /= scaleY, skewX /= scaleY;
  if (a7 * d18 < b25 * c6) a7 = -a7, b25 = -b25, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e3,
    translateY: f29,
    rotate: Math.atan2(b25, a7) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value2) {
  const m30 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value2 + "");
  return m30.isIdentity ? identity : decompose_default(m30.a, m30.b, m30.c, m30.d, m30.e, m30.f);
}
function parseSvg(value2) {
  if (value2 == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value2);
  if (!(value2 = svgNode.transform.baseVal.consolidate())) return identity;
  value2 = value2.matrix;
  return decompose_default(value2.a, value2.b, value2.c, value2.d, value2.e, value2.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s12) {
    return s12.length ? s12.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s12, q3) {
    if (xa !== xb || ya !== yb) {
      var i8 = s12.push("translate(", null, pxComma, null, pxParen);
      q3.push({ i: i8 - 4, x: number_default(xa, xb) }, { i: i8 - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s12.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a7, b25, s12, q3) {
    if (a7 !== b25) {
      if (a7 - b25 > 180) b25 += 360;
      else if (b25 - a7 > 180) a7 += 360;
      q3.push({ i: s12.push(pop(s12) + "rotate(", null, degParen) - 2, x: number_default(a7, b25) });
    } else if (b25) {
      s12.push(pop(s12) + "rotate(" + b25 + degParen);
    }
  }
  function skewX(a7, b25, s12, q3) {
    if (a7 !== b25) {
      q3.push({ i: s12.push(pop(s12) + "skewX(", null, degParen) - 2, x: number_default(a7, b25) });
    } else if (b25) {
      s12.push(pop(s12) + "skewX(" + b25 + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s12, q3) {
    if (xa !== xb || ya !== yb) {
      var i8 = s12.push(pop(s12) + "scale(", null, ",", null, ")");
      q3.push({ i: i8 - 4, x: number_default(xa, xb) }, { i: i8 - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s12.push(pop(s12) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a7, b25) {
    var s12 = [], q3 = [];
    a7 = parse(a7), b25 = parse(b25);
    translate(a7.translateX, a7.translateY, b25.translateX, b25.translateY, s12, q3);
    rotate(a7.rotate, b25.rotate, s12, q3);
    skewX(a7.skewX, b25.skewX, s12, q3);
    scale(a7.scaleX, a7.scaleY, b25.scaleX, b25.scaleY, s12, q3);
    a7 = b25 = null;
    return function(t4) {
      var i8 = -1, n = q3.length, o2;
      while (++i8 < n) s12[(o2 = q3[i8]).i] = o2.x(t4);
      return s12.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x21) {
  return ((x21 = Math.exp(x21)) + 1 / x21) / 2;
}
function sinh(x21) {
  return ((x21 = Math.exp(x21)) - 1 / x21) / 2;
}
function tanh(x21) {
  return ((x21 = Math.exp(2 * x21)) - 1) / (x21 + 1);
}
var zoom_default = (function zoomRho(rho, rho2, rho4) {
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d22 = dx * dx + dy * dy, i8, S6;
    if (d22 < epsilon2) {
      S6 = Math.log(w1 / w0) / rho;
      i8 = function(t4) {
        return [
          ux0 + t4 * dx,
          uy0 + t4 * dy,
          w0 * Math.exp(rho * t4 * S6)
        ];
      };
    } else {
      var d1 = Math.sqrt(d22), b02 = (w1 * w1 - w0 * w0 + rho4 * d22) / (2 * w0 * rho2 * d1), b110 = (w1 * w1 - w0 * w0 - rho4 * d22) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b02 * b02 + 1) - b02), r1 = Math.log(Math.sqrt(b110 * b110 + 1) - b110);
      S6 = (r1 - r0) / rho;
      i8 = function(t4) {
        var s12 = t4 * S6, coshr0 = cosh(r0), u15 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s12 + r0) - sinh(r0));
        return [
          ux0 + u15 * dx,
          uy0 + u15 * dy,
          w0 * coshr0 / cosh(rho * s12 + r0)
        ];
      };
    }
    i8.duration = S6 * 1e3 * rho / Math.SQRT2;
    return i8;
  }
  zoom.rho = function(_17) {
    var _1 = Math.max(1e-3, +_17), _22 = _1 * _1, _42 = _22 * _22;
    return zoomRho(_1, _22, _42);
  };
  return zoom;
})(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start2, end) {
    var h17 = hue2((start2 = hsl(start2)).h, (end = hsl(end)).h), s12 = nogamma(start2.s, end.s), l7 = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
    return function(t4) {
      start2.h = h17(t4);
      start2.s = s12(t4);
      start2.l = l7(t4);
      start2.opacity = opacity(t4);
      return start2 + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start2, end) {
    var h17 = hue2((start2 = hcl(start2)).h, (end = hcl(end)).h), c6 = nogamma(start2.c, end.c), l7 = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
    return function(t4) {
      start2.h = h17(t4);
      start2.c = c6(t4);
      start2.l = l7(t4);
      start2.opacity = opacity(t4);
      return start2 + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return (function cubehelixGamma(y25) {
    y25 = +y25;
    function cubehelix3(start2, end) {
      var h17 = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s12 = nogamma(start2.s, end.s), l7 = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
      return function(t4) {
        start2.h = h17(t4);
        start2.s = s12(t4);
        start2.l = l7(Math.pow(t4, y25));
        start2.opacity = opacity(t4);
        return start2 + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  })(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-interpolate/src/piecewise.js
function piecewise(interpolate, values) {
  if (values === void 0) values = interpolate, interpolate = value_default;
  var i8 = 0, n = values.length - 1, v28 = values[0], I2 = new Array(n < 0 ? 0 : n);
  while (i8 < n) I2[i8] = interpolate(v28, v28 = values[++i8]);
  return function(t4) {
    var i9 = Math.max(0, Math.min(n - 1, Math.floor(t4 *= n)));
    return I2[i9](t4 - i9);
  };
}

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name2) {
  var tween0, tween1;
  return function() {
    var schedule = set(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i8 = 0, n = tween1.length; i8 < n; ++i8) {
        if (tween1[i8].name === name2) {
          tween1 = tween1.slice();
          tween1.splice(i8, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name2, value2) {
  var tween0, tween1;
  if (typeof value2 !== "function") throw new Error();
  return function() {
    var schedule = set(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t4 = { name: name2, value: value2 }, i8 = 0, n = tween1.length; i8 < n; ++i8) {
        if (tween1[i8].name === name2) {
          tween1[i8] = t4;
          break;
        }
      }
      if (i8 === n) tween1.push(t4);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name2, value2) {
  var id2 = this._id;
  name2 += "";
  if (arguments.length < 2) {
    var tween = get(this.node(), id2).tween;
    for (var i8 = 0, n = tween.length, t4; i8 < n; ++i8) {
      if ((t4 = tween[i8]).name === name2) {
        return t4.value;
      }
    }
    return null;
  }
  return this.each((value2 == null ? tweenRemove : tweenFunction)(id2, name2, value2));
}
function tweenValue(transition2, name2, value2) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set(this, id2);
    (schedule.value || (schedule.value = {}))[name2] = value2.apply(this, arguments);
  });
  return function(node4) {
    return get(node4, id2).value[name2];
  };
}

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a7, b25) {
  var c6;
  return (typeof b25 === "number" ? number_default : b25 instanceof color ? rgb_default : (c6 = color(b25)) ? (b25 = c6, rgb_default) : string_default)(a7, b25);
}

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name2) {
  return function() {
    this.removeAttribute(name2);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name2, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name2);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name2, interpolate, value2) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value2(this), string1;
    if (value1 == null) return void this.removeAttribute(name2);
    string0 = this.getAttribute(name2);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value2) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value2(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name2, value2) {
  var fullname = namespace_default(name2), i8 = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name2, typeof value2 === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i8, tweenValue(this, "attr." + name2, value2)) : value2 == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i8, value2));
}

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name2, i8) {
  return function(t4) {
    this.setAttribute(name2, i8.call(this, t4));
  };
}
function attrInterpolateNS(fullname, i8) {
  return function(t4) {
    this.setAttributeNS(fullname.space, fullname.local, i8.call(this, t4));
  };
}
function attrTweenNS(fullname, value2) {
  var t03, i0;
  function tween() {
    var i8 = value2.apply(this, arguments);
    if (i8 !== i0) t03 = (i0 = i8) && attrInterpolateNS(fullname, i8);
    return t03;
  }
  tween._value = value2;
  return tween;
}
function attrTween(name2, value2) {
  var t03, i0;
  function tween() {
    var i8 = value2.apply(this, arguments);
    if (i8 !== i0) t03 = (i0 = i8) && attrInterpolate(name2, i8);
    return t03;
  }
  tween._value = value2;
  return tween;
}
function attrTween_default(name2, value2) {
  var key = "attr." + name2;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value2 == null) return this.tween(key, null);
  if (typeof value2 !== "function") throw new Error();
  var fullname = namespace_default(name2);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value2));
}

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value2) {
  return function() {
    init(this, id2).delay = +value2.apply(this, arguments);
  };
}
function delayConstant(id2, value2) {
  return value2 = +value2, function() {
    init(this, id2).delay = value2;
  };
}
function delay_default(value2) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value2 === "function" ? delayFunction : delayConstant)(id2, value2)) : get(this.node(), id2).delay;
}

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value2) {
  return function() {
    set(this, id2).duration = +value2.apply(this, arguments);
  };
}
function durationConstant(id2, value2) {
  return value2 = +value2, function() {
    set(this, id2).duration = value2;
  };
}
function duration_default(value2) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value2 === "function" ? durationFunction : durationConstant)(id2, value2)) : get(this.node(), id2).duration;
}

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value2) {
  if (typeof value2 !== "function") throw new Error();
  return function() {
    set(this, id2).ease = value2;
  };
}
function ease_default(value2) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value2)) : get(this.node(), id2).ease;
}

// node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value2) {
  return function() {
    var v28 = value2.apply(this, arguments);
    if (typeof v28 !== "function") throw new Error();
    set(this, id2).ease = v28;
  };
}
function easeVarying_default(value2) {
  if (typeof value2 !== "function") throw new Error();
  return this.each(easeVarying(this._id, value2));
}

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function") match = matcher_default(match);
  for (var groups2 = this._groups, m30 = groups2.length, subgroups = new Array(m30), j6 = 0; j6 < m30; ++j6) {
    for (var group3 = groups2[j6], n = group3.length, subgroup = subgroups[j6] = [], node4, i8 = 0; i8 < n; ++i8) {
      if ((node4 = group3[i8]) && match.call(node4, node4.__data__, i8, group3)) {
        subgroup.push(node4);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition2) {
  if (transition2._id !== this._id) throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m30 = Math.min(m0, m1), merges = new Array(m0), j6 = 0; j6 < m30; ++j6) {
    for (var group0 = groups0[j6], group1 = groups1[j6], n = group0.length, merge4 = merges[j6] = new Array(n), node4, i8 = 0; i8 < n; ++i8) {
      if (node4 = group0[i8] || group1[i8]) {
        merge4[i8] = node4;
      }
    }
  }
  for (; j6 < m0; ++j6) {
    merges[j6] = groups0[j6];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/on.js
function start(name2) {
  return (name2 + "").trim().split(/^|\s+/).every(function(t4) {
    var i8 = t4.indexOf(".");
    if (i8 >= 0) t4 = t4.slice(0, i8);
    return !t4 || t4 === "start";
  });
}
function onFunction(id2, name2, listener) {
  var on0, on1, sit = start(name2) ? init : set;
  return function() {
    var schedule = sit(this, id2), on = schedule.on;
    if (on !== on0) (on1 = (on0 = on).copy()).on(name2, listener);
    schedule.on = on1;
  };
}
function on_default2(name2, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get(this.node(), id2).on.on(name2) : this.each(onFunction(id2, name2, listener));
}

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i8 in this.__transition) if (+i8 !== id2) return;
    if (parent) parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/d3-transition/src/transition/select.js
function select_default3(select2) {
  var name2 = this._name, id2 = this._id;
  if (typeof select2 !== "function") select2 = selector_default(select2);
  for (var groups2 = this._groups, m30 = groups2.length, subgroups = new Array(m30), j6 = 0; j6 < m30; ++j6) {
    for (var group3 = groups2[j6], n = group3.length, subgroup = subgroups[j6] = new Array(n), node4, subnode, i8 = 0; i8 < n; ++i8) {
      if ((node4 = group3[i8]) && (subnode = select2.call(node4, node4.__data__, i8, group3))) {
        if ("__data__" in node4) subnode.__data__ = node4.__data__;
        subgroup[i8] = subnode;
        schedule_default(subgroup[i8], name2, id2, i8, subgroup, get(node4, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name2, id2);
}

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default3(select2) {
  var name2 = this._name, id2 = this._id;
  if (typeof select2 !== "function") select2 = selectorAll_default(select2);
  for (var groups2 = this._groups, m30 = groups2.length, subgroups = [], parents = [], j6 = 0; j6 < m30; ++j6) {
    for (var group3 = groups2[j6], n = group3.length, node4, i8 = 0; i8 < n; ++i8) {
      if (node4 = group3[i8]) {
        for (var children2 = select2.call(node4, node4.__data__, i8, group3), child, inherit2 = get(node4, id2), k17 = 0, l7 = children2.length; k17 < l7; ++k17) {
          if (child = children2[k17]) {
            schedule_default(child, name2, id2, k17, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node4);
      }
    }
  }
  return new Transition(subgroups, parents, name2, id2);
}

// node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/d3-transition/src/transition/style.js
function styleNull(name2, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name2), string1 = (this.style.removeProperty(name2), styleValue(this, name2));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name2) {
  return function() {
    this.style.removeProperty(name2);
  };
}
function styleConstant2(name2, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name2);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name2, interpolate, value2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name2), value1 = value2(this), string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name2), styleValue(this, name2));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name2) {
  var on0, on1, listener0, key = "style." + name2, event = "end." + key, remove2;
  return function() {
    var schedule = set(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name2)) : void 0;
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name2, value2, priority) {
  var i8 = (name2 += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value2 == null ? this.styleTween(name2, styleNull(name2, i8)).on("end.style." + name2, styleRemove2(name2)) : typeof value2 === "function" ? this.styleTween(name2, styleFunction2(name2, i8, tweenValue(this, "style." + name2, value2))).each(styleMaybeRemove(this._id, name2)) : this.styleTween(name2, styleConstant2(name2, i8, value2), priority).on("end.style." + name2, null);
}

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name2, i8, priority) {
  return function(t4) {
    this.style.setProperty(name2, i8.call(this, t4), priority);
  };
}
function styleTween(name2, value2, priority) {
  var t4, i0;
  function tween() {
    var i8 = value2.apply(this, arguments);
    if (i8 !== i0) t4 = (i0 = i8) && styleInterpolate(name2, i8, priority);
    return t4;
  }
  tween._value = value2;
  return tween;
}
function styleTween_default(name2, value2, priority) {
  var key = "style." + (name2 += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value2 == null) return this.tween(key, null);
  if (typeof value2 !== "function") throw new Error();
  return this.tween(key, styleTween(name2, value2, priority == null ? "" : priority));
}

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value2) {
  return function() {
    this.textContent = value2;
  };
}
function textFunction2(value2) {
  return function() {
    var value1 = value2(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value2) {
  return this.tween("text", typeof value2 === "function" ? textFunction2(tweenValue(this, "text", value2)) : textConstant2(value2 == null ? "" : value2 + ""));
}

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i8) {
  return function(t4) {
    this.textContent = i8.call(this, t4);
  };
}
function textTween(value2) {
  var t03, i0;
  function tween() {
    var i8 = value2.apply(this, arguments);
    if (i8 !== i0) t03 = (i0 = i8) && textInterpolate(i8);
    return t03;
  }
  tween._value = value2;
  return tween;
}
function textTween_default(value2) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value2 == null) return this.tween(key, null);
  if (typeof value2 !== "function") throw new Error();
  return this.tween(key, textTween(value2));
}

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name2 = this._name, id0 = this._id, id1 = newId();
  for (var groups2 = this._groups, m30 = groups2.length, j6 = 0; j6 < m30; ++j6) {
    for (var group3 = groups2[j6], n = group3.length, node4, i8 = 0; i8 < n; ++i8) {
      if (node4 = group3[i8]) {
        var inherit2 = get(node4, id0);
        schedule_default(node4, name2, id1, i8, group3, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups2, this._parents, name2, id1);
}

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size2 = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size2 === 0) resolve();
    } };
    that.each(function() {
      var schedule = set(this, id2), on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size2 === 0) resolve();
  });
}

// node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups2, parents, name2, id2) {
  this._groups = groups2;
  this._parents = parents;
  this._name = name2;
  this._id = id2;
}
function transition(name2) {
  return selection_default().transition(name2);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default3,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter_default2,
  merge: merge_default2,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// node_modules/d3-ease/src/linear.js
var linear2 = (t4) => +t4;

// node_modules/d3-ease/src/cubic.js
function cubicInOut(t4) {
  return ((t4 *= 2) <= 1 ? t4 * t4 * t4 : (t4 -= 2) * t4 * t4 + 2) / 2;
}

// node_modules/d3-ease/src/poly.js
var exponent = 3;
var polyIn = (function custom(e3) {
  e3 = +e3;
  function polyIn2(t4) {
    return Math.pow(t4, e3);
  }
  polyIn2.exponent = custom;
  return polyIn2;
})(exponent);
var polyOut = (function custom2(e3) {
  e3 = +e3;
  function polyOut2(t4) {
    return 1 - Math.pow(1 - t4, e3);
  }
  polyOut2.exponent = custom2;
  return polyOut2;
})(exponent);
var polyInOut = (function custom3(e3) {
  e3 = +e3;
  function polyInOut2(t4) {
    return ((t4 *= 2) <= 1 ? Math.pow(t4, e3) : 2 - Math.pow(2 - t4, e3)) / 2;
  }
  polyInOut2.exponent = custom3;
  return polyInOut2;
})(exponent);

// node_modules/d3-ease/src/sin.js
var pi = Math.PI;
var halfPi = pi / 2;

// node_modules/d3-ease/src/math.js
function tpmt(x21) {
  return (Math.pow(2, -10 * x21) - 9765625e-10) * 1.0009775171065494;
}

// node_modules/d3-ease/src/bounce.js
var b1 = 4 / 11;
var b2 = 6 / 11;
var b3 = 8 / 11;
var b4 = 3 / 4;
var b5 = 9 / 11;
var b6 = 10 / 11;
var b7 = 15 / 16;
var b8 = 21 / 22;
var b9 = 63 / 64;
var b0 = 1 / b1 / b1;

// node_modules/d3-ease/src/back.js
var overshoot = 1.70158;
var backIn = (function custom4(s12) {
  s12 = +s12;
  function backIn2(t4) {
    return (t4 = +t4) * t4 * (s12 * (t4 - 1) + t4);
  }
  backIn2.overshoot = custom4;
  return backIn2;
})(overshoot);
var backOut = (function custom5(s12) {
  s12 = +s12;
  function backOut2(t4) {
    return --t4 * t4 * ((t4 + 1) * s12 + t4) + 1;
  }
  backOut2.overshoot = custom5;
  return backOut2;
})(overshoot);
var backInOut = (function custom6(s12) {
  s12 = +s12;
  function backInOut2(t4) {
    return ((t4 *= 2) < 1 ? t4 * t4 * ((s12 + 1) * t4 - s12) : (t4 -= 2) * t4 * ((s12 + 1) * t4 + s12) + 2) / 2;
  }
  backInOut2.overshoot = custom6;
  return backInOut2;
})(overshoot);

// node_modules/d3-ease/src/elastic.js
var tau = 2 * Math.PI;
var amplitude = 1;
var period = 0.3;
var elasticIn = (function custom7(a7, p13) {
  var s12 = Math.asin(1 / (a7 = Math.max(1, a7))) * (p13 /= tau);
  function elasticIn2(t4) {
    return a7 * tpmt(- --t4) * Math.sin((s12 - t4) / p13);
  }
  elasticIn2.amplitude = function(a8) {
    return custom7(a8, p13 * tau);
  };
  elasticIn2.period = function(p14) {
    return custom7(a7, p14);
  };
  return elasticIn2;
})(amplitude, period);
var elasticOut = (function custom8(a7, p13) {
  var s12 = Math.asin(1 / (a7 = Math.max(1, a7))) * (p13 /= tau);
  function elasticOut2(t4) {
    return 1 - a7 * tpmt(t4 = +t4) * Math.sin((t4 + s12) / p13);
  }
  elasticOut2.amplitude = function(a8) {
    return custom8(a8, p13 * tau);
  };
  elasticOut2.period = function(p14) {
    return custom8(a7, p14);
  };
  return elasticOut2;
})(amplitude, period);
var elasticInOut = (function custom9(a7, p13) {
  var s12 = Math.asin(1 / (a7 = Math.max(1, a7))) * (p13 /= tau);
  function elasticInOut2(t4) {
    return ((t4 = t4 * 2 - 1) < 0 ? a7 * tpmt(-t4) * Math.sin((s12 - t4) / p13) : 2 - a7 * tpmt(t4) * Math.sin((s12 + t4) / p13)) / 2;
  }
  elasticInOut2.amplitude = function(a8) {
    return custom9(a8, p13 * tau);
  };
  elasticInOut2.period = function(p14) {
    return custom9(a7, p14);
  };
  return elasticInOut2;
})(amplitude, period);

// node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node4, id2) {
  var timing;
  while (!(timing = node4.__transition) || !(timing = timing[id2])) {
    if (!(node4 = node4.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name2) {
  var id2, timing;
  if (name2 instanceof Transition) {
    id2 = name2._id, name2 = name2._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name2 = name2 == null ? null : name2 + "";
  }
  for (var groups2 = this._groups, m30 = groups2.length, j6 = 0; j6 < m30; ++j6) {
    for (var group3 = groups2[j6], n = group3.length, node4, i8 = 0; i8 < n; ++i8) {
      if (node4 = group3[i8]) {
        schedule_default(node4, name2, id2, i8, group3, timing || inherit(node4, id2));
      }
    }
  }
  return new Transition(groups2, this._parents, name2, id2);
}

// node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/@unovis/ts/utils/d3.js
function smartTransition(selection2, duration, easing) {
  selection2.nodes().forEach((node4) => interrupt_default(node4));
  if (duration) {
    const transition2 = selection2.transition().duration(duration);
    if (easing)
      transition2.ease(easing);
    return transition2;
  } else
    return selection2;
}

// node_modules/@unovis/ts/containers/single-container/config.js
var SingleContainerDefaultConfig = Object.assign(Object.assign({}, ContainerDefaultConfig), { tooltip: void 0, annotations: void 0 });

// node_modules/@unovis/ts/containers/single-container/index.js
var SingleContainer = class extends ContainerCore {
  constructor(element, config, data) {
    var _a;
    super(element);
    this._defaultConfig = SingleContainerDefaultConfig;
    this.config = this._defaultConfig;
    if (config) {
      this.updateContainer(config, true);
      this.component = config.component;
    }
    if (data) {
      this.setData(data, true);
    }
    if ((_a = this.component) === null || _a === void 0 ? void 0 : _a.datamodel.data)
      this.render();
  }
  setData(data, preventRender) {
    var _a;
    const { config } = this;
    if (this.component)
      this.component.setData(data);
    if (!preventRender)
      this.render();
    (_a = config.tooltip) === null || _a === void 0 ? void 0 : _a.hide();
  }
  updateContainer(containerConfig, preventRender) {
    super.updateContainer(containerConfig);
    this._removeAllChildren();
    this.component = containerConfig.component;
    if (containerConfig.sizing)
      this.component.sizing = containerConfig.sizing;
    this.element.appendChild(this.component.element);
    const tooltip2 = containerConfig.tooltip;
    if (tooltip2) {
      if (!tooltip2.hasContainer())
        tooltip2.setContainer(this._container);
      tooltip2.setComponents([this.component]);
    }
    const annotations = containerConfig.annotations;
    if (annotations) {
      this.element.appendChild(annotations.element);
    }
    this.element.appendChild(this._svgDefs.node());
    this.element.appendChild(this._svgDefsExternal.node());
    if (!preventRender)
      this.render();
  }
  updateComponent(componentConfig, preventRender) {
    this.component.setConfig(componentConfig);
    if (!preventRender)
      this.render();
  }
  update(containerConfig, componentConfig, data) {
    if (containerConfig)
      this.updateContainer(containerConfig, true);
    if (componentConfig)
      this.updateComponent(componentConfig, true);
    if (data)
      this.setData(data, true);
    this.render();
  }
  getFitWidthScale() {
    const { config, component } = this;
    const extendedSizeComponent = component;
    if (!extendedSizeComponent.getWidth)
      return 1;
    const componentWidth = extendedSizeComponent.getWidth() + config.margin.left + config.margin.right;
    return this.width / componentWidth;
  }
  _preRender() {
    var _a, _b;
    super._preRender();
    this.component.setSize(this.width, this.height, this.containerWidth, this.containerHeight);
    this.component.setContainerMargin(this.config.margin);
    (_a = this.config.annotations) === null || _a === void 0 ? void 0 : _a.setSize(this.width, this.height, this.containerWidth, this.containerHeight);
    (_b = this.config.annotations) === null || _b === void 0 ? void 0 : _b.setContainerMargin(this.config.margin);
  }
  _render(duration) {
    var _a;
    const { config, component } = this;
    super._render(duration);
    component.g.attr("transform", `translate(${config.margin.left},${config.margin.top})`);
    component.render(duration);
    (_a = config.annotations) === null || _a === void 0 ? void 0 : _a.render(duration);
    if (config.tooltip)
      config.tooltip.update();
  }
  // Re-defining the `render()` function to handle different sizing techniques (`Sizing.Extend` and `Sizing.FitWidth`)
  // Not calling `super.render()` because we don't want it to interfere with setting the SVG size here.
  render(duration = this.config.duration) {
    const { config, component } = this;
    if (config.sizing === Sizing.Extend || config.sizing === Sizing.FitWidth) {
      const fitToWidth = config.sizing === Sizing.FitWidth;
      const extendedSizeComponent = component;
      const componentWidth = extendedSizeComponent.getWidth() + config.margin.left + config.margin.right;
      const componentHeight = extendedSizeComponent.getHeight() + config.margin.top + config.margin.bottom;
      const scale = fitToWidth ? this.getFitWidthScale() : 1;
      const currentWidth = this.svg.attr("width");
      const currentHeight = this.svg.attr("height");
      const scaledWidth = componentWidth * scale;
      const scaledHeight = componentHeight * scale;
      const animated = currentWidth || currentHeight;
      smartTransition(this.svg, animated ? duration : 0).attr("width", scaledWidth).attr("height", scaledHeight).attr("viewBox", `${0} ${0} ${componentWidth} ${fitToWidth ? scaledHeight : componentHeight}`).attr("preserveAspectRatio", "xMinYMin");
    } else {
      this.svg.attr("width", this.config.width || this.containerWidth).attr("height", this.config.height || this.containerHeight);
    }
    if (!this._resizeObserver)
      this._setUpResizeObserver();
    cancelAnimationFrame(this._renderAnimationFrameId);
    this._renderAnimationFrameId = requestAnimationFrame(() => {
      this._preRender();
      this._render(duration);
    });
  }
  _onResize() {
    var _a;
    const { config } = this;
    super._onResize();
    (_a = config.tooltip) === null || _a === void 0 ? void 0 : _a.hide();
  }
  destroy() {
    var _a, _b;
    const { component, config } = this;
    super.destroy();
    component === null || component === void 0 ? void 0 : component.destroy();
    (_a = config.tooltip) === null || _a === void 0 ? void 0 : _a.destroy();
    (_b = config.annotations) === null || _b === void 0 ? void 0 : _b.destroy();
  }
};

// node_modules/@unovis/ts/data-models/core.js
var CoreDataModel = class {
  constructor(data) {
    this.data = data;
  }
  get data() {
    return this._data;
  }
  set data(value2) {
    this._data = value2;
  }
};

// node_modules/@unovis/ts/components/axis/types.js
var AxisType;
(function(AxisType2) {
  AxisType2["X"] = "x";
  AxisType2["Y"] = "y";
})(AxisType || (AxisType = {}));

// node_modules/d3-scale/src/init.js
function initRange(domain, range3) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range3).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");
function ordinal() {
  var index3 = new InternMap(), domain = [], range3 = [], unknown = implicit;
  function scale(d18) {
    let i8 = index3.get(d18);
    if (i8 === void 0) {
      if (unknown !== implicit) return unknown;
      index3.set(d18, i8 = domain.push(d18) - 1);
    }
    return range3[i8 % range3.length];
  }
  scale.domain = function(_17) {
    if (!arguments.length) return domain.slice();
    domain = [], index3 = new InternMap();
    for (const value2 of _17) {
      if (index3.has(value2)) continue;
      index3.set(value2, domain.push(value2) - 1);
    }
    return scale;
  };
  scale.range = function(_17) {
    return arguments.length ? (range3 = Array.from(_17), scale) : range3.slice();
  };
  scale.unknown = function(_17) {
    return arguments.length ? (unknown = _17, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range3).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/d3-scale/src/band.js
function band() {
  var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round2 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale.unknown;
  function rescale() {
    var n = domain().length, reverse2 = r1 < r0, start2 = reverse2 ? r1 : r0, stop = reverse2 ? r0 : r1;
    step = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round2) step = Math.floor(step);
    start2 += (stop - start2 - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round2) start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
    var values = range(n).map(function(i8) {
      return start2 + step * i8;
    });
    return ordinalRange(reverse2 ? values.reverse() : values);
  }
  scale.domain = function(_17) {
    return arguments.length ? (domain(_17), rescale()) : domain();
  };
  scale.range = function(_17) {
    return arguments.length ? ([r0, r1] = _17, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale.rangeRound = function(_17) {
    return [r0, r1] = _17, r0 = +r0, r1 = +r1, round2 = true, rescale();
  };
  scale.bandwidth = function() {
    return bandwidth;
  };
  scale.step = function() {
    return step;
  };
  scale.round = function(_17) {
    return arguments.length ? (round2 = !!_17, rescale()) : round2;
  };
  scale.padding = function(_17) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_17), rescale()) : paddingInner;
  };
  scale.paddingInner = function(_17) {
    return arguments.length ? (paddingInner = Math.min(1, _17), rescale()) : paddingInner;
  };
  scale.paddingOuter = function(_17) {
    return arguments.length ? (paddingOuter = +_17, rescale()) : paddingOuter;
  };
  scale.align = function(_17) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _17)), rescale()) : align;
  };
  scale.copy = function() {
    return band(domain(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale) {
  var copy3 = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;
  scale.copy = function() {
    return pointish(copy3());
  };
  return scale;
}
function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

// node_modules/d3-scale/src/constant.js
function constants(x21) {
  return function() {
    return x21;
  };
}

// node_modules/d3-scale/src/number.js
function number(x21) {
  return +x21;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity2(x21) {
  return x21;
}
function normalize(a7, b25) {
  return (b25 -= a7 = +a7) ? function(x21) {
    return (x21 - a7) / b25;
  } : constants(isNaN(b25) ? NaN : 0.5);
}
function clamper(a7, b25) {
  var t4;
  if (a7 > b25) t4 = a7, a7 = b25, b25 = t4;
  return function(x21) {
    return Math.max(a7, Math.min(b25, x21));
  };
}
function bimap(domain, range3, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range3[0], r1 = range3[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x21) {
    return r0(d0(x21));
  };
}
function polymap(domain, range3, interpolate) {
  var j6 = Math.min(domain.length, range3.length) - 1, d18 = new Array(j6), r4 = new Array(j6), i8 = -1;
  if (domain[j6] < domain[0]) {
    domain = domain.slice().reverse();
    range3 = range3.slice().reverse();
  }
  while (++i8 < j6) {
    d18[i8] = normalize(domain[i8], domain[i8 + 1]);
    r4[i8] = interpolate(range3[i8], range3[i8 + 1]);
  }
  return function(x21) {
    var i9 = bisect_default(domain, x21, 1, j6) - 1;
    return r4[i9](d18[i9](x21));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range3 = unit, interpolate = value_default, transform2, untransform, unknown, clamp2 = identity2, piecewise2, output, input;
  function rescale() {
    var n = Math.min(domain.length, range3.length);
    if (clamp2 !== identity2) clamp2 = clamper(domain[0], domain[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x21) {
    return x21 == null || isNaN(x21 = +x21) ? unknown : (output || (output = piecewise2(domain.map(transform2), range3, interpolate)))(transform2(clamp2(x21)));
  }
  scale.invert = function(y25) {
    return clamp2(untransform((input || (input = piecewise2(range3, domain.map(transform2), number_default)))(y25)));
  };
  scale.domain = function(_17) {
    return arguments.length ? (domain = Array.from(_17, number), rescale()) : domain.slice();
  };
  scale.range = function(_17) {
    return arguments.length ? (range3 = Array.from(_17), rescale()) : range3.slice();
  };
  scale.rangeRound = function(_17) {
    return range3 = Array.from(_17), interpolate = round_default, rescale();
  };
  scale.clamp = function(_17) {
    return arguments.length ? (clamp2 = _17 ? true : identity2, rescale()) : clamp2 !== identity2;
  };
  scale.interpolate = function(_17) {
    return arguments.length ? (interpolate = _17, rescale()) : interpolate;
  };
  scale.unknown = function(_17) {
    return arguments.length ? (unknown = _17, scale) : unknown;
  };
  return function(t4, u15) {
    transform2 = t4, untransform = u15;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity2, identity2);
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x21) {
  return Math.abs(x21 = Math.round(x21)) >= 1e21 ? x21.toLocaleString("en").replace(/,/g, "") : x21.toString(10);
}
function formatDecimalParts(x21, p13) {
  if ((i8 = (x21 = p13 ? x21.toExponential(p13 - 1) : x21.toExponential()).indexOf("e")) < 0) return null;
  var i8, coefficient = x21.slice(0, i8);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x21.slice(i8 + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x21) {
  return x21 = formatDecimalParts(Math.abs(x21)), x21 ? x21[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value2, width) {
    var i8 = value2.length, t4 = [], j6 = 0, g15 = grouping[0], length = 0;
    while (i8 > 0 && g15 > 0) {
      if (length + g15 + 1 > width) g15 = Math.max(1, width - length);
      t4.push(value2.substring(i8 -= g15, i8 + g15));
      if ((length += g15 + 1) > width) break;
      g15 = grouping[j6 = (j6 + 1) % grouping.length];
    }
    return t4.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value2) {
    return value2.replace(/[0-9]/g, function(i8) {
      return numerals[+i8];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s12) {
  out: for (var n = s12.length, i8 = 1, i0 = -1, i1; i8 < n; ++i8) {
    switch (s12[i8]) {
      case ".":
        i0 = i1 = i8;
        break;
      case "0":
        if (i0 === 0) i0 = i8;
        i1 = i8;
        break;
      default:
        if (!+s12[i8]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s12.slice(0, i0) + s12.slice(i1 + 1) : s12;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x21, p13) {
  var d18 = formatDecimalParts(x21, p13);
  if (!d18) return x21 + "";
  var coefficient = d18[0], exponent2 = d18[1], i8 = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i8 === n ? coefficient : i8 > n ? coefficient + new Array(i8 - n + 1).join("0") : i8 > 0 ? coefficient.slice(0, i8) + "." + coefficient.slice(i8) : "0." + new Array(1 - i8).join("0") + formatDecimalParts(x21, Math.max(0, p13 + i8 - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x21, p13) {
  var d18 = formatDecimalParts(x21, p13);
  if (!d18) return x21 + "";
  var coefficient = d18[0], exponent2 = d18[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x21, p13) => (x21 * 100).toFixed(p13),
  "b": (x21) => Math.round(x21).toString(2),
  "c": (x21) => x21 + "",
  "d": formatDecimal_default,
  "e": (x21, p13) => x21.toExponential(p13),
  "f": (x21, p13) => x21.toFixed(p13),
  "g": (x21, p13) => x21.toPrecision(p13),
  "o": (x21) => Math.round(x21).toString(8),
  "p": (x21, p13) => formatRounded_default(x21 * 100, p13),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x21) => Math.round(x21).toString(16).toUpperCase(),
  "x": (x21) => Math.round(x21).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default(x21) {
  return x21;
}

// node_modules/d3-format/src/locale.js
var map = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale3) {
  var group3 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default : formatGroup_default(map.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default : formatNumerals_default(map.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "−" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign5 = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n") comma = true, type2 = "g";
    else if (!formatTypes_default[type2]) precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero2 || fill === "0" && align === "=") zero2 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value2) {
      var valuePrefix = prefix, valueSuffix = suffix, i8, n, c6;
      if (type2 === "c") {
        valueSuffix = formatType(value2) + valueSuffix;
        value2 = "";
      } else {
        value2 = +value2;
        var valueNegative = value2 < 0 || 1 / value2 < 0;
        value2 = isNaN(value2) ? nan : formatType(Math.abs(value2), precision);
        if (trim) value2 = formatTrim_default(value2);
        if (valueNegative && +value2 === 0 && sign5 !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign5 === "(" ? sign5 : minus : sign5 === "-" || sign5 === "(" ? "" : sign5) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign5 === "(" ? ")" : "");
        if (maybeSuffix) {
          i8 = -1, n = value2.length;
          while (++i8 < n) {
            if (c6 = value2.charCodeAt(i8), 48 > c6 || c6 > 57) {
              valueSuffix = (c6 === 46 ? decimal + value2.slice(i8 + 1) : value2.slice(i8)) + valueSuffix;
              value2 = value2.slice(0, i8);
              break;
            }
          }
        }
      }
      if (comma && !zero2) value2 = group3(value2, Infinity);
      var length = valuePrefix.length + value2.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero2) value2 = group3(padding + value2, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value2 = valuePrefix + value2 + valueSuffix + padding;
          break;
        case "=":
          value2 = valuePrefix + padding + value2 + valueSuffix;
          break;
        case "^":
          value2 = padding.slice(0, length = padding.length >> 1) + valuePrefix + value2 + valueSuffix + padding.slice(length);
          break;
        default:
          value2 = padding + valuePrefix + value2 + valueSuffix;
          break;
      }
      return numerals(value2);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value2) {
    var f29 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value2) / 3))) * 3, k17 = Math.pow(10, -e3), prefix = prefixes[8 + e3 / 3];
    return function(value3) {
      return f29(k17 * value3) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value2) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value2) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max8) {
  step = Math.abs(step), max8 = Math.abs(max8) - step;
  return Math.max(0, exponent_default(max8) - exponent_default(step)) + 1;
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start2, stop, count3, specifier) {
  var step = tickStep(start2, stop, count3), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value2 = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value2))) specifier.precision = precision;
      return formatPrefix(specifier, value2);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count3) {
    var d18 = domain();
    return ticks(d18[0], d18[d18.length - 1], count3 == null ? 10 : count3);
  };
  scale.tickFormat = function(count3, specifier) {
    var d18 = domain();
    return tickFormat(d18[0], d18[d18.length - 1], count3 == null ? 10 : count3, specifier);
  };
  scale.nice = function(count3) {
    if (count3 == null) count3 = 10;
    var d18 = domain();
    var i0 = 0;
    var i1 = d18.length - 1;
    var start2 = d18[i0];
    var stop = d18[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count3);
      if (step === prestep) {
        d18[i0] = start2;
        d18[i1] = stop;
        return domain(d18);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear3() {
  var scale = continuous();
  scale.copy = function() {
    return copy(scale, linear3());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}

// node_modules/d3-scale/src/identity.js
function identity3(domain) {
  var unknown;
  function scale(x21) {
    return x21 == null || isNaN(x21 = +x21) ? unknown : x21;
  }
  scale.invert = scale;
  scale.domain = scale.range = function(_17) {
    return arguments.length ? (domain = Array.from(_17, number), scale) : domain.slice();
  };
  scale.unknown = function(_17) {
    return arguments.length ? (unknown = _17, scale) : unknown;
  };
  scale.copy = function() {
    return identity3(domain).unknown(unknown);
  };
  domain = arguments.length ? Array.from(domain, number) : [0, 1];
  return linearish(scale);
}

// node_modules/d3-scale/src/nice.js
function nice(domain, interval) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x06 = domain[i0], x110 = domain[i1], t4;
  if (x110 < x06) {
    t4 = i0, i0 = i1, i1 = t4;
    t4 = x06, x06 = x110, x110 = t4;
  }
  domain[i0] = interval.floor(x06);
  domain[i1] = interval.ceil(x110);
  return domain;
}

// node_modules/d3-scale/src/log.js
function transformLog(x21) {
  return Math.log(x21);
}
function transformExp(x21) {
  return Math.exp(x21);
}
function transformLogn(x21) {
  return -Math.log(-x21);
}
function transformExpn(x21) {
  return -Math.exp(-x21);
}
function pow10(x21) {
  return isFinite(x21) ? +("1e" + x21) : x21 < 0 ? 0 : x21;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : (x21) => Math.pow(base, x21);
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x21) => Math.log(x21) / base);
}
function reflect(f29) {
  return (x21, k17) => -f29(-x21, k17);
}
function loggish(transform2) {
  const scale = transform2(transformLog, transformExp);
  const domain = scale.domain;
  let base = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform2(transformLogn, transformExpn);
    } else {
      transform2(transformLog, transformExp);
    }
    return scale;
  }
  scale.base = function(_17) {
    return arguments.length ? (base = +_17, rescale()) : base;
  };
  scale.domain = function(_17) {
    return arguments.length ? (domain(_17), rescale()) : domain();
  };
  scale.ticks = (count3) => {
    const d18 = domain();
    let u15 = d18[0];
    let v28 = d18[d18.length - 1];
    const r4 = v28 < u15;
    if (r4) [u15, v28] = [v28, u15];
    let i8 = logs(u15);
    let j6 = logs(v28);
    let k17;
    let t4;
    const n = count3 == null ? 10 : +count3;
    let z3 = [];
    if (!(base % 1) && j6 - i8 < n) {
      i8 = Math.floor(i8), j6 = Math.ceil(j6);
      if (u15 > 0) for (; i8 <= j6; ++i8) {
        for (k17 = 1; k17 < base; ++k17) {
          t4 = i8 < 0 ? k17 / pows(-i8) : k17 * pows(i8);
          if (t4 < u15) continue;
          if (t4 > v28) break;
          z3.push(t4);
        }
      }
      else for (; i8 <= j6; ++i8) {
        for (k17 = base - 1; k17 >= 1; --k17) {
          t4 = i8 > 0 ? k17 / pows(-i8) : k17 * pows(i8);
          if (t4 < u15) continue;
          if (t4 > v28) break;
          z3.push(t4);
        }
      }
      if (z3.length * 2 < n) z3 = ticks(u15, v28, n);
    } else {
      z3 = ticks(i8, j6, Math.min(j6 - i8, n)).map(pows);
    }
    return r4 ? z3.reverse() : z3;
  };
  scale.tickFormat = (count3, specifier) => {
    if (count3 == null) count3 = 10;
    if (specifier == null) specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
      specifier = format(specifier);
    }
    if (count3 === Infinity) return specifier;
    const k17 = Math.max(1, base * count3 / scale.ticks().length);
    return (d18) => {
      let i8 = d18 / pows(Math.round(logs(d18)));
      if (i8 * base < base - 0.5) i8 *= base;
      return i8 <= k17 ? specifier(d18) : "";
    };
  };
  scale.nice = () => {
    return domain(nice(domain(), {
      floor: (x21) => pows(Math.floor(logs(x21))),
      ceil: (x21) => pows(Math.ceil(logs(x21)))
    }));
  };
  return scale;
}
function log() {
  const scale = loggish(transformer()).domain([1, 10]);
  scale.copy = () => copy(scale, log()).base(scale.base());
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/d3-scale/src/symlog.js
function transformSymlog(c6) {
  return function(x21) {
    return Math.sign(x21) * Math.log1p(Math.abs(x21 / c6));
  };
}
function transformSymexp(c6) {
  return function(x21) {
    return Math.sign(x21) * Math.expm1(Math.abs(x21)) * c6;
  };
}
function symlogish(transform2) {
  var c6 = 1, scale = transform2(transformSymlog(c6), transformSymexp(c6));
  scale.constant = function(_17) {
    return arguments.length ? transform2(transformSymlog(c6 = +_17), transformSymexp(c6)) : c6;
  };
  return linearish(scale);
}
function symlog() {
  var scale = symlogish(transformer());
  scale.copy = function() {
    return copy(scale, symlog()).constant(scale.constant());
  };
  return initRange.apply(scale, arguments);
}

// node_modules/d3-scale/src/pow.js
function transformPow(exponent2) {
  return function(x21) {
    return x21 < 0 ? -Math.pow(-x21, exponent2) : Math.pow(x21, exponent2);
  };
}
function transformSqrt(x21) {
  return x21 < 0 ? -Math.sqrt(-x21) : Math.sqrt(x21);
}
function transformSquare(x21) {
  return x21 < 0 ? -x21 * x21 : x21 * x21;
}
function powish(transform2) {
  var scale = transform2(identity2, identity2), exponent2 = 1;
  function rescale() {
    return exponent2 === 1 ? transform2(identity2, identity2) : exponent2 === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent2), transformPow(1 / exponent2));
  }
  scale.exponent = function(_17) {
    return arguments.length ? (exponent2 = +_17, rescale()) : exponent2;
  };
  return linearish(scale);
}
function pow() {
  var scale = powish(transformer());
  scale.copy = function() {
    return copy(scale, pow()).exponent(scale.exponent());
  };
  initRange.apply(scale, arguments);
  return scale;
}
function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}

// node_modules/d3-scale/src/quantile.js
function quantile() {
  var domain = [], range3 = [], thresholds = [], unknown;
  function rescale() {
    var i8 = 0, n = Math.max(1, range3.length);
    thresholds = new Array(n - 1);
    while (++i8 < n) thresholds[i8 - 1] = quantileSorted(domain, i8 / n);
    return scale;
  }
  function scale(x21) {
    return x21 == null || isNaN(x21 = +x21) ? unknown : range3[bisect_default(thresholds, x21)];
  }
  scale.invertExtent = function(y25) {
    var i8 = range3.indexOf(y25);
    return i8 < 0 ? [NaN, NaN] : [
      i8 > 0 ? thresholds[i8 - 1] : domain[0],
      i8 < thresholds.length ? thresholds[i8] : domain[domain.length - 1]
    ];
  };
  scale.domain = function(_17) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d18 of _17) if (d18 != null && !isNaN(d18 = +d18)) domain.push(d18);
    domain.sort(ascending);
    return rescale();
  };
  scale.range = function(_17) {
    return arguments.length ? (range3 = Array.from(_17), rescale()) : range3.slice();
  };
  scale.unknown = function(_17) {
    return arguments.length ? (unknown = _17, scale) : unknown;
  };
  scale.quantiles = function() {
    return thresholds.slice();
  };
  scale.copy = function() {
    return quantile().domain(domain).range(range3).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}

// node_modules/d3-scale/src/quantize.js
function quantize() {
  var x06 = 0, x110 = 1, n = 1, domain = [0.5], range3 = [0, 1], unknown;
  function scale(x21) {
    return x21 != null && x21 <= x21 ? range3[bisect_default(domain, x21, 0, n)] : unknown;
  }
  function rescale() {
    var i8 = -1;
    domain = new Array(n);
    while (++i8 < n) domain[i8] = ((i8 + 1) * x110 - (i8 - n) * x06) / (n + 1);
    return scale;
  }
  scale.domain = function(_17) {
    return arguments.length ? ([x06, x110] = _17, x06 = +x06, x110 = +x110, rescale()) : [x06, x110];
  };
  scale.range = function(_17) {
    return arguments.length ? (n = (range3 = Array.from(_17)).length - 1, rescale()) : range3.slice();
  };
  scale.invertExtent = function(y25) {
    var i8 = range3.indexOf(y25);
    return i8 < 0 ? [NaN, NaN] : i8 < 1 ? [x06, domain[0]] : i8 >= n ? [domain[n - 1], x110] : [domain[i8 - 1], domain[i8]];
  };
  scale.unknown = function(_17) {
    return arguments.length ? (unknown = _17, scale) : scale;
  };
  scale.thresholds = function() {
    return domain.slice();
  };
  scale.copy = function() {
    return quantize().domain([x06, x110]).range(range3).unknown(unknown);
  };
  return initRange.apply(linearish(scale), arguments);
}

// node_modules/d3-scale/src/threshold.js
function threshold() {
  var domain = [0.5], range3 = [0, 1], unknown, n = 1;
  function scale(x21) {
    return x21 != null && x21 <= x21 ? range3[bisect_default(domain, x21, 0, n)] : unknown;
  }
  scale.domain = function(_17) {
    return arguments.length ? (domain = Array.from(_17), n = Math.min(domain.length, range3.length - 1), scale) : domain.slice();
  };
  scale.range = function(_17) {
    return arguments.length ? (range3 = Array.from(_17), n = Math.min(domain.length, range3.length - 1), scale) : range3.slice();
  };
  scale.invertExtent = function(y25) {
    var i8 = range3.indexOf(y25);
    return [domain[i8 - 1], domain[i8]];
  };
  scale.unknown = function(_17) {
    return arguments.length ? (unknown = _17, scale) : unknown;
  };
  scale.copy = function() {
    return threshold().domain(domain).range(range3).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}

// node_modules/d3-time/src/interval.js
var t02 = /* @__PURE__ */ new Date();
var t12 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count3, field) {
  function interval(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval.floor = (date2) => {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval.ceil = (date2) => {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval.round = (date2) => {
    const d0 = interval(date2), d1 = interval.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval.offset = (date2, step) => {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval.range = (start2, stop, step) => {
    const range3 = [];
    start2 = interval.ceil(start2);
    step = step == null ? 1 : Math.floor(step);
    if (!(start2 < stop) || !(step > 0)) return range3;
    let previous;
    do
      range3.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);
    while (previous < start2 && start2 < stop);
    return range3;
  };
  interval.filter = (test) => {
    return timeInterval((date2) => {
      if (date2 >= date2) while (floori(date2), !test(date2)) date2.setTime(date2 - 1);
    }, (date2, step) => {
      if (date2 >= date2) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date2, -1), !test(date2)) {
          }
        }
        else while (--step >= 0) {
          while (offseti(date2, 1), !test(date2)) {
          }
        }
      }
    });
  };
  if (count3) {
    interval.count = (start2, end) => {
      t02.setTime(+start2), t12.setTime(+end);
      floori(t02), floori(t12);
      return Math.floor(count3(t02, t12));
    };
    interval.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? (d18) => field(d18) % step === 0 : (d18) => interval.count(0, d18) % step === 0);
    };
  }
  return interval;
}

// node_modules/d3-time/src/millisecond.js
var millisecond = timeInterval(() => {
}, (date2, step) => {
  date2.setTime(+date2 + step);
}, (start2, end) => {
  return end - start2;
});
millisecond.every = (k17) => {
  k17 = Math.floor(k17);
  if (!isFinite(k17) || !(k17 > 0)) return null;
  if (!(k17 > 1)) return millisecond;
  return timeInterval((date2) => {
    date2.setTime(Math.floor(date2 / k17) * k17);
  }, (date2, step) => {
    date2.setTime(+date2 + step * k17);
  }, (start2, end) => {
    return (end - start2) / k17;
  });
};
var milliseconds = millisecond.range;

// node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// node_modules/d3-time/src/second.js
var second = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds());
}, (date2, step) => {
  date2.setTime(+date2 + step * durationSecond);
}, (start2, end) => {
  return (end - start2) / durationSecond;
}, (date2) => {
  return date2.getUTCSeconds();
});
var seconds = second.range;

// node_modules/d3-time/src/minute.js
var timeMinute = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start2, end) => {
  return (end - start2) / durationMinute;
}, (date2) => {
  return date2.getMinutes();
});
var timeMinutes = timeMinute.range;
var utcMinute = timeInterval((date2) => {
  date2.setUTCSeconds(0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start2, end) => {
  return (end - start2) / durationMinute;
}, (date2) => {
  return date2.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

// node_modules/d3-time/src/hour.js
var timeHour = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start2, end) => {
  return (end - start2) / durationHour;
}, (date2) => {
  return date2.getHours();
});
var timeHours = timeHour.range;
var utcHour = timeInterval((date2) => {
  date2.setUTCMinutes(0, 0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start2, end) => {
  return (end - start2) / durationHour;
}, (date2) => {
  return date2.getUTCHours();
});
var utcHours = utcHour.range;

// node_modules/d3-time/src/day.js
var timeDay = timeInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,
  (date2) => date2.getDate() - 1
);
var timeDays = timeDay.range;
var utcDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start2, end) => {
  return (end - start2) / durationDay;
}, (date2) => {
  return date2.getUTCDate() - 1;
});
var utcDays = utcDay.range;
var unixDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start2, end) => {
  return (end - start2) / durationDay;
}, (date2) => {
  return Math.floor(date2 / durationDay);
});
var unixDays = unixDay.range;

// node_modules/d3-time/src/week.js
function timeWeekday(i8) {
  return timeInterval((date2) => {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i8) % 7);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setDate(date2.getDate() + step * 7);
  }, (start2, end) => {
    return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var timeSunday = timeWeekday(0);
var timeMonday = timeWeekday(1);
var timeTuesday = timeWeekday(2);
var timeWednesday = timeWeekday(3);
var timeThursday = timeWeekday(4);
var timeFriday = timeWeekday(5);
var timeSaturday = timeWeekday(6);
var timeSundays = timeSunday.range;
var timeMondays = timeMonday.range;
var timeTuesdays = timeTuesday.range;
var timeWednesdays = timeWednesday.range;
var timeThursdays = timeThursday.range;
var timeFridays = timeFriday.range;
var timeSaturdays = timeSaturday.range;
function utcWeekday(i8) {
  return timeInterval((date2) => {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i8) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, (start2, end) => {
    return (end - start2) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/d3-time/src/month.js
var timeMonth = timeInterval((date2) => {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setMonth(date2.getMonth() + step);
}, (start2, end) => {
  return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;
}, (date2) => {
  return date2.getMonth();
});
var timeMonths = timeMonth.range;
var utcMonth = timeInterval((date2) => {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, (start2, end) => {
  return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;
}, (date2) => {
  return date2.getUTCMonth();
});
var utcMonths = utcMonth.range;

// node_modules/d3-time/src/year.js
var timeYear = timeInterval((date2) => {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setFullYear(date2.getFullYear() + step);
}, (start2, end) => {
  return end.getFullYear() - start2.getFullYear();
}, (date2) => {
  return date2.getFullYear();
});
timeYear.every = (k17) => {
  return !isFinite(k17 = Math.floor(k17)) || !(k17 > 0) ? null : timeInterval((date2) => {
    date2.setFullYear(Math.floor(date2.getFullYear() / k17) * k17);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step * k17);
  });
};
var timeYears = timeYear.range;
var utcYear = timeInterval((date2) => {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, (start2, end) => {
  return end.getUTCFullYear() - start2.getUTCFullYear();
}, (date2) => {
  return date2.getUTCFullYear();
});
utcYear.every = (k17) => {
  return !isFinite(k17 = Math.floor(k17)) || !(k17 > 0) ? null : timeInterval((date2) => {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k17) * k17);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k17);
  });
};
var utcYears = utcYear.range;

// node_modules/d3-time/src/ticks.js
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start2, stop, count3) {
    const reverse2 = stop < start2;
    if (reverse2) [start2, stop] = [stop, start2];
    const interval = count3 && typeof count3.range === "function" ? count3 : tickInterval(start2, stop, count3);
    const ticks3 = interval ? interval.range(start2, +stop + 1) : [];
    return reverse2 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start2, stop, count3) {
    const target = Math.abs(stop - start2) / count3;
    const i8 = bisector(([, , step2]) => step2).right(tickIntervals, target);
    if (i8 === tickIntervals.length) return year.every(tickStep(start2 / durationYear, stop / durationYear, count3));
    if (i8 === 0) return millisecond.every(Math.max(tickStep(start2, stop, count3), 1));
    const [t4, step] = tickIntervals[target / tickIntervals[i8 - 1][2] < tickIntervals[i8][2] / target ? i8 - 1 : i8];
    return t4.every(step);
  }
  return [ticks2, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

// node_modules/d3-time-format/src/locale.js
function localDate(d18) {
  if (0 <= d18.y && d18.y < 100) {
    var date2 = new Date(-1, d18.m, d18.d, d18.H, d18.M, d18.S, d18.L);
    date2.setFullYear(d18.y);
    return date2;
  }
  return new Date(d18.y, d18.m, d18.d, d18.H, d18.M, d18.S, d18.L);
}
function utcDate(d18) {
  if (0 <= d18.y && d18.y < 100) {
    var date2 = new Date(Date.UTC(-1, d18.m, d18.d, d18.H, d18.M, d18.S, d18.L));
    date2.setUTCFullYear(d18.y);
    return date2;
  }
  return new Date(Date.UTC(d18.y, d18.m, d18.d, d18.H, d18.M, d18.S, d18.L));
}
function newDate(y25, m30, d18) {
  return { y: y25, m: m30, d: d18, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale3) {
  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string = [], i8 = -1, j6 = 0, n = specifier.length, c6, pad2, format2;
      if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
      while (++i8 < n) {
        if (specifier.charCodeAt(i8) === 37) {
          string.push(specifier.slice(j6, i8));
          if ((pad2 = pads[c6 = specifier.charAt(++i8)]) != null) c6 = specifier.charAt(++i8);
          else pad2 = c6 === "e" ? " " : "0";
          if (format2 = formats2[c6]) c6 = format2(date2, pad2);
          string.push(c6);
          j6 = i8 + 1;
        }
      }
      string.push(specifier.slice(j6, i8));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d18 = newDate(1900, void 0, 1), i8 = parseSpecifier(d18, specifier, string += "", 0), week, day;
      if (i8 != string.length) return null;
      if ("Q" in d18) return new Date(d18.Q);
      if ("s" in d18) return new Date(d18.s * 1e3 + ("L" in d18 ? d18.L : 0));
      if (Z && !("Z" in d18)) d18.Z = 0;
      if ("p" in d18) d18.H = d18.H % 12 + d18.p * 12;
      if (d18.m === void 0) d18.m = "q" in d18 ? d18.q : 0;
      if ("V" in d18) {
        if (d18.V < 1 || d18.V > 53) return null;
        if (!("w" in d18)) d18.w = 1;
        if ("Z" in d18) {
          week = utcDate(newDate(d18.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d18.V - 1) * 7);
          d18.y = week.getUTCFullYear();
          d18.m = week.getUTCMonth();
          d18.d = week.getUTCDate() + (d18.w + 6) % 7;
        } else {
          week = localDate(newDate(d18.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d18.V - 1) * 7);
          d18.y = week.getFullYear();
          d18.m = week.getMonth();
          d18.d = week.getDate() + (d18.w + 6) % 7;
        }
      } else if ("W" in d18 || "U" in d18) {
        if (!("w" in d18)) d18.w = "u" in d18 ? d18.u % 7 : "W" in d18 ? 1 : 0;
        day = "Z" in d18 ? utcDate(newDate(d18.y, 0, 1)).getUTCDay() : localDate(newDate(d18.y, 0, 1)).getDay();
        d18.m = 0;
        d18.d = "W" in d18 ? (d18.w + 6) % 7 + d18.W * 7 - (day + 5) % 7 : d18.w + d18.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d18) {
        d18.H += d18.Z / 100 | 0;
        d18.M += d18.Z % 100;
        return utcDate(d18);
      }
      return localDate(d18);
    };
  }
  function parseSpecifier(d18, specifier, string, j6) {
    var i8 = 0, n = specifier.length, m30 = string.length, c6, parse;
    while (i8 < n) {
      if (j6 >= m30) return -1;
      c6 = specifier.charCodeAt(i8++);
      if (c6 === 37) {
        c6 = specifier.charAt(i8++);
        parse = parses[c6 in pads ? specifier.charAt(i8++) : c6];
        if (!parse || (j6 = parse(d18, string, j6)) < 0) return -1;
      } else if (c6 != string.charCodeAt(j6++)) {
        return -1;
      }
    }
    return j6;
  }
  function parsePeriod(d18, string, i8) {
    var n = periodRe.exec(string.slice(i8));
    return n ? (d18.p = periodLookup.get(n[0].toLowerCase()), i8 + n[0].length) : -1;
  }
  function parseShortWeekday(d18, string, i8) {
    var n = shortWeekdayRe.exec(string.slice(i8));
    return n ? (d18.w = shortWeekdayLookup.get(n[0].toLowerCase()), i8 + n[0].length) : -1;
  }
  function parseWeekday(d18, string, i8) {
    var n = weekdayRe.exec(string.slice(i8));
    return n ? (d18.w = weekdayLookup.get(n[0].toLowerCase()), i8 + n[0].length) : -1;
  }
  function parseShortMonth(d18, string, i8) {
    var n = shortMonthRe.exec(string.slice(i8));
    return n ? (d18.m = shortMonthLookup.get(n[0].toLowerCase()), i8 + n[0].length) : -1;
  }
  function parseMonth(d18, string, i8) {
    var n = monthRe.exec(string.slice(i8));
    return n ? (d18.m = monthLookup.get(n[0].toLowerCase()), i8 + n[0].length) : -1;
  }
  function parseLocaleDateTime(d18, string, i8) {
    return parseSpecifier(d18, locale_dateTime, string, i8);
  }
  function parseLocaleDate(d18, string, i8) {
    return parseSpecifier(d18, locale_date, string, i8);
  }
  function parseLocaleTime(d18, string, i8) {
    return parseSpecifier(d18, locale_time, string, i8);
  }
  function formatShortWeekday(d18) {
    return locale_shortWeekdays[d18.getDay()];
  }
  function formatWeekday(d18) {
    return locale_weekdays[d18.getDay()];
  }
  function formatShortMonth(d18) {
    return locale_shortMonths[d18.getMonth()];
  }
  function formatMonth(d18) {
    return locale_months[d18.getMonth()];
  }
  function formatPeriod(d18) {
    return locale_periods[+(d18.getHours() >= 12)];
  }
  function formatQuarter(d18) {
    return 1 + ~~(d18.getMonth() / 3);
  }
  function formatUTCShortWeekday(d18) {
    return locale_shortWeekdays[d18.getUTCDay()];
  }
  function formatUTCWeekday(d18) {
    return locale_weekdays[d18.getUTCDay()];
  }
  function formatUTCShortMonth(d18) {
    return locale_shortMonths[d18.getUTCMonth()];
  }
  function formatUTCMonth(d18) {
    return locale_months[d18.getUTCMonth()];
  }
  function formatUTCPeriod(d18) {
    return locale_periods[+(d18.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d18) {
    return 1 + ~~(d18.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f29 = newFormat(specifier += "", formats);
      f29.toString = function() {
        return specifier;
      };
      return f29;
    },
    parse: function(specifier) {
      var p13 = newParse(specifier += "", false);
      p13.toString = function() {
        return specifier;
      };
      return p13;
    },
    utcFormat: function(specifier) {
      var f29 = newFormat(specifier += "", utcFormats);
      f29.toString = function() {
        return specifier;
      };
      return f29;
    },
    utcParse: function(specifier) {
      var p13 = newParse(specifier += "", true);
      p13.toString = function() {
        return specifier;
      };
      return p13;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value2, fill, width) {
  var sign5 = value2 < 0 ? "-" : "", string = (sign5 ? -value2 : value2) + "", length = string.length;
  return sign5 + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}
function requote(s12) {
  return s12.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name2, i8) => [name2.toLowerCase(), i8]));
}
function parseWeekdayNumberSunday(d18, string, i8) {
  var n = numberRe.exec(string.slice(i8, i8 + 1));
  return n ? (d18.w = +n[0], i8 + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d18, string, i8) {
  var n = numberRe.exec(string.slice(i8, i8 + 1));
  return n ? (d18.u = +n[0], i8 + n[0].length) : -1;
}
function parseWeekNumberSunday(d18, string, i8) {
  var n = numberRe.exec(string.slice(i8, i8 + 2));
  return n ? (d18.U = +n[0], i8 + n[0].length) : -1;
}
function parseWeekNumberISO(d18, string, i8) {
  var n = numberRe.exec(string.slice(i8, i8 + 2));
  return n ? (d18.V = +n[0], i8 + n[0].length) : -1;
}
function parseWeekNumberMonday(d18, string, i8) {
  var n = numberRe.exec(string.slice(i8, i8 + 2));
  return n ? (d18.W = +n[0], i8 + n[0].length) : -1;
}
function parseFullYear(d18, string, i8) {
  var n = numberRe.exec(string.slice(i8, i8 + 4));
  return n ? (d18.y = +n[0], i8 + n[0].length) : -1;
}
function parseYear(d18, string, i8) {
  var n = numberRe.exec(string.slice(i8, i8 + 2));
  return n ? (d18.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i8 + n[0].length) : -1;
}
function parseZone(d18, string, i8) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i8, i8 + 6));
  return n ? (d18.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i8 + n[0].length) : -1;
}
function parseQuarter(d18, string, i8) {
  var n = numberRe.exec(string.slice(i8, i8 + 1));
  return n ? (d18.q = n[0] * 3 - 3, i8 + n[0].length) : -1;
}
function parseMonthNumber(d18, string, i8) {
  var n = numberRe.exec(string.slice(i8, i8 + 2));
  return n ? (d18.m = n[0] - 1, i8 + n[0].length) : -1;
}
function parseDayOfMonth(d18, string, i8) {
  var n = numberRe.exec(string.slice(i8, i8 + 2));
  return n ? (d18.d = +n[0], i8 + n[0].length) : -1;
}
function parseDayOfYear(d18, string, i8) {
  var n = numberRe.exec(string.slice(i8, i8 + 3));
  return n ? (d18.m = 0, d18.d = +n[0], i8 + n[0].length) : -1;
}
function parseHour24(d18, string, i8) {
  var n = numberRe.exec(string.slice(i8, i8 + 2));
  return n ? (d18.H = +n[0], i8 + n[0].length) : -1;
}
function parseMinutes(d18, string, i8) {
  var n = numberRe.exec(string.slice(i8, i8 + 2));
  return n ? (d18.M = +n[0], i8 + n[0].length) : -1;
}
function parseSeconds(d18, string, i8) {
  var n = numberRe.exec(string.slice(i8, i8 + 2));
  return n ? (d18.S = +n[0], i8 + n[0].length) : -1;
}
function parseMilliseconds(d18, string, i8) {
  var n = numberRe.exec(string.slice(i8, i8 + 3));
  return n ? (d18.L = +n[0], i8 + n[0].length) : -1;
}
function parseMicroseconds(d18, string, i8) {
  var n = numberRe.exec(string.slice(i8, i8 + 6));
  return n ? (d18.L = Math.floor(n[0] / 1e3), i8 + n[0].length) : -1;
}
function parseLiteralPercent(d18, string, i8) {
  var n = percentRe.exec(string.slice(i8, i8 + 1));
  return n ? i8 + n[0].length : -1;
}
function parseUnixTimestamp(d18, string, i8) {
  var n = numberRe.exec(string.slice(i8));
  return n ? (d18.Q = +n[0], i8 + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d18, string, i8) {
  var n = numberRe.exec(string.slice(i8));
  return n ? (d18.s = +n[0], i8 + n[0].length) : -1;
}
function formatDayOfMonth(d18, p13) {
  return pad(d18.getDate(), p13, 2);
}
function formatHour24(d18, p13) {
  return pad(d18.getHours(), p13, 2);
}
function formatHour12(d18, p13) {
  return pad(d18.getHours() % 12 || 12, p13, 2);
}
function formatDayOfYear(d18, p13) {
  return pad(1 + timeDay.count(timeYear(d18), d18), p13, 3);
}
function formatMilliseconds(d18, p13) {
  return pad(d18.getMilliseconds(), p13, 3);
}
function formatMicroseconds(d18, p13) {
  return formatMilliseconds(d18, p13) + "000";
}
function formatMonthNumber(d18, p13) {
  return pad(d18.getMonth() + 1, p13, 2);
}
function formatMinutes(d18, p13) {
  return pad(d18.getMinutes(), p13, 2);
}
function formatSeconds(d18, p13) {
  return pad(d18.getSeconds(), p13, 2);
}
function formatWeekdayNumberMonday(d18) {
  var day = d18.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d18, p13) {
  return pad(timeSunday.count(timeYear(d18) - 1, d18), p13, 2);
}
function dISO(d18) {
  var day = d18.getDay();
  return day >= 4 || day === 0 ? timeThursday(d18) : timeThursday.ceil(d18);
}
function formatWeekNumberISO(d18, p13) {
  d18 = dISO(d18);
  return pad(timeThursday.count(timeYear(d18), d18) + (timeYear(d18).getDay() === 4), p13, 2);
}
function formatWeekdayNumberSunday(d18) {
  return d18.getDay();
}
function formatWeekNumberMonday(d18, p13) {
  return pad(timeMonday.count(timeYear(d18) - 1, d18), p13, 2);
}
function formatYear(d18, p13) {
  return pad(d18.getFullYear() % 100, p13, 2);
}
function formatYearISO(d18, p13) {
  d18 = dISO(d18);
  return pad(d18.getFullYear() % 100, p13, 2);
}
function formatFullYear(d18, p13) {
  return pad(d18.getFullYear() % 1e4, p13, 4);
}
function formatFullYearISO(d18, p13) {
  var day = d18.getDay();
  d18 = day >= 4 || day === 0 ? timeThursday(d18) : timeThursday.ceil(d18);
  return pad(d18.getFullYear() % 1e4, p13, 4);
}
function formatZone(d18) {
  var z3 = d18.getTimezoneOffset();
  return (z3 > 0 ? "-" : (z3 *= -1, "+")) + pad(z3 / 60 | 0, "0", 2) + pad(z3 % 60, "0", 2);
}
function formatUTCDayOfMonth(d18, p13) {
  return pad(d18.getUTCDate(), p13, 2);
}
function formatUTCHour24(d18, p13) {
  return pad(d18.getUTCHours(), p13, 2);
}
function formatUTCHour12(d18, p13) {
  return pad(d18.getUTCHours() % 12 || 12, p13, 2);
}
function formatUTCDayOfYear(d18, p13) {
  return pad(1 + utcDay.count(utcYear(d18), d18), p13, 3);
}
function formatUTCMilliseconds(d18, p13) {
  return pad(d18.getUTCMilliseconds(), p13, 3);
}
function formatUTCMicroseconds(d18, p13) {
  return formatUTCMilliseconds(d18, p13) + "000";
}
function formatUTCMonthNumber(d18, p13) {
  return pad(d18.getUTCMonth() + 1, p13, 2);
}
function formatUTCMinutes(d18, p13) {
  return pad(d18.getUTCMinutes(), p13, 2);
}
function formatUTCSeconds(d18, p13) {
  return pad(d18.getUTCSeconds(), p13, 2);
}
function formatUTCWeekdayNumberMonday(d18) {
  var dow = d18.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d18, p13) {
  return pad(utcSunday.count(utcYear(d18) - 1, d18), p13, 2);
}
function UTCdISO(d18) {
  var day = d18.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d18) : utcThursday.ceil(d18);
}
function formatUTCWeekNumberISO(d18, p13) {
  d18 = UTCdISO(d18);
  return pad(utcThursday.count(utcYear(d18), d18) + (utcYear(d18).getUTCDay() === 4), p13, 2);
}
function formatUTCWeekdayNumberSunday(d18) {
  return d18.getUTCDay();
}
function formatUTCWeekNumberMonday(d18, p13) {
  return pad(utcMonday.count(utcYear(d18) - 1, d18), p13, 2);
}
function formatUTCYear(d18, p13) {
  return pad(d18.getUTCFullYear() % 100, p13, 2);
}
function formatUTCYearISO(d18, p13) {
  d18 = UTCdISO(d18);
  return pad(d18.getUTCFullYear() % 100, p13, 2);
}
function formatUTCFullYear(d18, p13) {
  return pad(d18.getUTCFullYear() % 1e4, p13, 4);
}
function formatUTCFullYearISO(d18, p13) {
  var day = d18.getUTCDay();
  d18 = day >= 4 || day === 0 ? utcThursday(d18) : utcThursday.ceil(d18);
  return pad(d18.getUTCFullYear() % 1e4, p13, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d18) {
  return +d18;
}
function formatUnixTimestampSeconds(d18) {
  return Math.floor(+d18 / 1e3);
}

// node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// node_modules/d3-time-format/src/isoFormat.js
var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative(date2) {
  return date2.toISOString();
}
var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);

// node_modules/d3-time-format/src/isoParse.js
function parseIsoNative(string) {
  var date2 = new Date(string);
  return isNaN(date2) ? null : date2;
}
var parseIso = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);

// node_modules/d3-scale/src/time.js
function date(t4) {
  return new Date(t4);
}
function number2(t4) {
  return t4 instanceof Date ? +t4 : +/* @__PURE__ */ new Date(+t4);
}
function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2) {
  var scale = continuous(), invert = scale.invert, domain = scale.domain;
  var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear2)(date2);
  }
  scale.invert = function(y25) {
    return new Date(invert(y25));
  };
  scale.domain = function(_17) {
    return arguments.length ? domain(Array.from(_17, number2)) : domain().map(date);
  };
  scale.ticks = function(interval) {
    var d18 = domain();
    return ticks2(d18[0], d18[d18.length - 1], interval == null ? 10 : interval);
  };
  scale.tickFormat = function(count3, specifier) {
    return specifier == null ? tickFormat2 : format2(specifier);
  };
  scale.nice = function(interval) {
    var d18 = domain();
    if (!interval || typeof interval.range !== "function") interval = tickInterval(d18[0], d18[d18.length - 1], interval == null ? 10 : interval);
    return interval ? domain(nice(d18, interval)) : scale;
  };
  scale.copy = function() {
    return copy(scale, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2));
  };
  return scale;
}
function time2() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/utcTime.js
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/sequential.js
function transformer2() {
  var x06 = 0, x110 = 1, t03, t13, k102, transform2, interpolator = identity2, clamp2 = false, unknown;
  function scale(x21) {
    return x21 == null || isNaN(x21 = +x21) ? unknown : interpolator(k102 === 0 ? 0.5 : (x21 = (transform2(x21) - t03) * k102, clamp2 ? Math.max(0, Math.min(1, x21)) : x21));
  }
  scale.domain = function(_17) {
    return arguments.length ? ([x06, x110] = _17, t03 = transform2(x06 = +x06), t13 = transform2(x110 = +x110), k102 = t03 === t13 ? 0 : 1 / (t13 - t03), scale) : [x06, x110];
  };
  scale.clamp = function(_17) {
    return arguments.length ? (clamp2 = !!_17, scale) : clamp2;
  };
  scale.interpolator = function(_17) {
    return arguments.length ? (interpolator = _17, scale) : interpolator;
  };
  function range3(interpolate) {
    return function(_17) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _17, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
    };
  }
  scale.range = range3(value_default);
  scale.rangeRound = range3(round_default);
  scale.unknown = function(_17) {
    return arguments.length ? (unknown = _17, scale) : unknown;
  };
  return function(t4) {
    transform2 = t4, t03 = t4(x06), t13 = t4(x110), k102 = t03 === t13 ? 0 : 1 / (t13 - t03);
    return scale;
  };
}
function copy2(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  var scale = linearish(transformer2()(identity2));
  scale.copy = function() {
    return copy2(scale, sequential());
  };
  return initInterpolator.apply(scale, arguments);
}

// node_modules/d3-scale/src/diverging.js
function transformer3() {
  var x06 = 0, x110 = 0.5, x22 = 1, s12 = 1, t03, t13, t22, k102, k21, interpolator = identity2, transform2, clamp2 = false, unknown;
  function scale(x21) {
    return isNaN(x21 = +x21) ? unknown : (x21 = 0.5 + ((x21 = +transform2(x21)) - t13) * (s12 * x21 < s12 * t13 ? k102 : k21), interpolator(clamp2 ? Math.max(0, Math.min(1, x21)) : x21));
  }
  scale.domain = function(_17) {
    return arguments.length ? ([x06, x110, x22] = _17, t03 = transform2(x06 = +x06), t13 = transform2(x110 = +x110), t22 = transform2(x22 = +x22), k102 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s12 = t13 < t03 ? -1 : 1, scale) : [x06, x110, x22];
  };
  scale.clamp = function(_17) {
    return arguments.length ? (clamp2 = !!_17, scale) : clamp2;
  };
  scale.interpolator = function(_17) {
    return arguments.length ? (interpolator = _17, scale) : interpolator;
  };
  function range3(interpolate) {
    return function(_17) {
      var r0, r1, r22;
      return arguments.length ? ([r0, r1, r22] = _17, interpolator = piecewise(interpolate, [r0, r1, r22]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale.range = range3(value_default);
  scale.rangeRound = range3(round_default);
  scale.unknown = function(_17) {
    return arguments.length ? (unknown = _17, scale) : unknown;
  };
  return function(t4) {
    transform2 = t4, t03 = t4(x06), t13 = t4(x110), t22 = t4(x22), k102 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s12 = t13 < t03 ? -1 : 1;
    return scale;
  };
}
function diverging() {
  var scale = linearish(transformer3()(identity2));
  scale.copy = function() {
    return copy2(scale, diverging());
  };
  return initInterpolator.apply(scale, arguments);
}

// node_modules/@unovis/ts/types/scale.js
var Scale = {
  scaleLinear: linear3,
  scalePow: pow,
  scaleSqrt: sqrt,
  scaleLog: log,
  scaleSymlog: symlog,
  scaleIdentity: identity3,
  scaleTime: time2,
  scaleUtc: utcTime,
  scaleSequential: sequential,
  scaleDiverging: diverging,
  scaleQuantize: quantize,
  scaleQuantile: quantile,
  scaleThreshold: threshold,
  scaleOrdinal: ordinal,
  scaleBand: band,
  scalePoint: point
};
var ScaleDimension;
(function(ScaleDimension2) {
  ScaleDimension2["X"] = "x";
  ScaleDimension2["Y"] = "y";
})(ScaleDimension || (ScaleDimension = {}));

// node_modules/@unovis/ts/types/direction.js
var Direction;
(function(Direction2) {
  Direction2["West"] = "west";
  Direction2["East"] = "east";
  Direction2["North"] = "north";
  Direction2["South"] = "south";
})(Direction || (Direction = {}));

// node_modules/@unovis/ts/containers/xy-container/config.js
var XYContainerDefaultConfig = Object.assign(Object.assign({}, ContainerDefaultConfig), { components: [], tooltip: void 0, crosshair: void 0, annotations: void 0, xAxis: void 0, yAxis: void 0, autoMargin: true, xScale: void 0, xDomain: void 0, xDomainMinConstraint: void 0, xDomainMaxConstraint: void 0, xRange: void 0, yScale: void 0, yDomain: void 0, yDomainMinConstraint: void 0, yDomainMaxConstraint: void 0, yRange: void 0, yDirection: Direction.North, preventEmptyDomain: null, scaleByDomain: false, clipPathExtend: 2 });

// node_modules/@unovis/ts/containers/xy-container/index.js
var XYContainer = class extends ContainerCore {
  constructor(element, config, data) {
    var _a, _b;
    super(element);
    this._defaultConfig = XYContainerDefaultConfig;
    this.datamodel = new CoreDataModel();
    this.config = this._defaultConfig;
    this._clipPathId = guid();
    this._axisMargin = { top: 0, bottom: 0, left: 0, right: 0 };
    this._firstRender = true;
    this._clipPath = this.svg.append("clipPath").attr("id", this._clipPathId);
    this._clipPath.append("rect");
    const highlightFilterId = "saturate";
    const baseUrl = window.location.href.replace(window.location.hash, "");
    this.svg.attr("class", css`
      --highlight-filter-id: url(${baseUrl}#${highlightFilterId}); // defining a css variable
    `);
    this._svgDefs.append("filter").attr("id", highlightFilterId).attr("filterUnits", "objectBoundingBox").html('<feColorMatrix type="saturate" in="SourceGraphic" values="1.35"/>');
    if (config) {
      this.updateContainer(config, true);
    }
    if (data) {
      this.setData(data, true);
    }
    if (this.config.xAxis || this.config.yAxis || ((_a = this.components) === null || _a === void 0 ? void 0 : _a.some((c6) => c6.datamodel.data))) {
      this.render();
    }
    (_b = document.fonts) === null || _b === void 0 ? void 0 : _b.ready.then(() => {
      if (!this._firstRender)
        this._renderAxes(0);
    });
  }
  get components() {
    return this.config.components;
  }
  // Overriding ContainerCore default get width method to work with axis auto margin
  get width() {
    const margin = this._getMargin();
    return clamp(this.containerWidth - margin.left - margin.right, 0, Number.POSITIVE_INFINITY);
  }
  // Overriding ContainerCore default get height method to work with axis auto margin
  get height() {
    const margin = this._getMargin();
    return clamp(this.containerHeight - margin.top - margin.bottom, 0, Number.POSITIVE_INFINITY);
  }
  setData(data, preventRender) {
    var _a, _b, _c, _d, _e;
    const { components, config } = this;
    if (!data)
      return;
    this.datamodel.data = data;
    components.forEach((c6) => {
      c6.setData(data);
    });
    (_a = config.crosshair) === null || _a === void 0 ? void 0 : _a.setData(data);
    (_b = config.xAxis) === null || _b === void 0 ? void 0 : _b.setData(data);
    (_c = config.yAxis) === null || _c === void 0 ? void 0 : _c.setData(data);
    const hasDataUpdated = !isEqual(this.datamodel.data, data);
    if (hasDataUpdated) {
      (_d = config.tooltip) === null || _d === void 0 ? void 0 : _d.hide();
      (_e = config.crosshair) === null || _e === void 0 ? void 0 : _e.hide();
    }
    if (!preventRender)
      this.render();
  }
  updateContainer(containerConfig, preventRender) {
    super.updateContainer(containerConfig);
    this._removeAllChildren();
    this.setData(this.datamodel.data, true);
    if (containerConfig.xAxis) {
      this.config.xAxis.config.type = AxisType.X;
      this.element.appendChild(containerConfig.xAxis.element);
    }
    if (containerConfig.yAxis) {
      this.config.yAxis.config.type = AxisType.Y;
      this.element.appendChild(containerConfig.yAxis.element);
    }
    for (const c6 of this.components) {
      this.element.appendChild(c6.element);
    }
    const tooltip2 = containerConfig.tooltip;
    if (tooltip2) {
      if (!tooltip2.hasContainer())
        tooltip2.setContainer(this._container);
      tooltip2.setComponents(this.components);
    }
    const crosshair = containerConfig.crosshair;
    if (crosshair) {
      crosshair.setContainer(this.svg);
      crosshair.tooltip = tooltip2;
      this.element.appendChild(crosshair.element);
    }
    const annotations = containerConfig.annotations;
    if (annotations) {
      this.element.appendChild(annotations.element);
    }
    this.element.appendChild(this._clipPath.node());
    this.element.appendChild(this._svgDefs.node());
    this.element.appendChild(this._svgDefsExternal.node());
    if (!preventRender)
      this.render();
  }
  updateComponents(componentConfigs, preventRender) {
    const { config } = this;
    this.components.forEach((c6, i8) => {
      const componentConfig = componentConfigs[i8];
      if (componentConfig) {
        c6.setConfig(componentConfigs[i8]);
      }
    });
    this._updateScales(...this.components, config.xAxis, config.yAxis, config.crosshair);
    if (!preventRender)
      this.render();
  }
  update(containerConfig, componentConfigs, data) {
    if (data)
      this.datamodel.data = data;
    if (containerConfig)
      this.updateContainer(containerConfig, true);
    if (componentConfigs)
      this.updateComponents(componentConfigs, true);
    this.render();
  }
  _preRender() {
    const { config } = this;
    super._preRender();
    if (config.autoMargin) {
      this._setAutoMargin();
    }
    const components = clean([...this.components, config.xAxis, config.yAxis, config.crosshair, config.annotations]);
    const margin = this._getMargin();
    for (const c6 of components) {
      c6.setSize(this.width, this.height, this.containerWidth, this.containerHeight);
      c6.setContainerMargin(margin);
    }
    this._updateScales(...this.components, config.xAxis, config.yAxis, config.crosshair);
  }
  _render(customDuration) {
    var _a, _b, _c, _d, _e;
    const { config } = this;
    super._render();
    const margin = this._getMargin();
    for (const c6 of this.components) {
      c6.g.attr("transform", `translate(${margin.left},${margin.top})`).style("clip-path", c6.clippable ? `url(#${this._clipPathId})` : null).style("-webkit-clip-path", c6.clippable ? `url(#${this._clipPathId})` : null);
      c6.render(customDuration);
    }
    this._renderAxes(this._firstRender ? 0 : customDuration);
    const clipPathExtension = config.clipPathExtend;
    this._clipPath.select("rect").attr("x", -clipPathExtension).attr("y", -clipPathExtension).attr("width", this.width + 2 * clipPathExtension).attr("height", this.height + 2 * clipPathExtension);
    (_a = config.tooltip) === null || _a === void 0 ? void 0 : _a.update();
    const crosshair = config.crosshair;
    if (crosshair) {
      const yAccessors = this.components.filter((c6) => !c6.stacked).map((c6) => c6.config.y);
      const yStackedAccessors = this.components.filter((c6) => c6.stacked).map((c6) => c6.config.y);
      const baselineComponentConfig = (_b = this.components.find((c6) => c6.config.baseline)) === null || _b === void 0 ? void 0 : _b.config;
      const baselineAccessor = baselineComponentConfig === null || baselineComponentConfig === void 0 ? void 0 : baselineComponentConfig.baseline;
      crosshair.accessors = {
        x: (_c = this.components[0]) === null || _c === void 0 ? void 0 : _c.config.x,
        y: flatten(yAccessors),
        yStacked: flatten(yStackedAccessors),
        baseline: baselineAccessor
      };
      crosshair.g.attr("transform", `translate(${margin.left},${margin.top})`).style("clip-path", `url(#${this._clipPathId})`).style("-webkit-clip-path", `url(#${this._clipPathId})`);
      crosshair.render();
    }
    (_d = config.annotations) === null || _d === void 0 ? void 0 : _d.g.attr("transform", `translate(${margin.left},${margin.top})`);
    (_e = config.annotations) === null || _e === void 0 ? void 0 : _e.render();
    this._firstRender = false;
  }
  _updateScales(...components) {
    const c6 = clean(components || this.components);
    this._setScales(...c6);
    this._updateScalesDomain(...c6);
    this._updateScalesRange(...c6);
  }
  _setScales(...components) {
    const { config } = this;
    if (!components)
      return;
    if (config.xScale)
      components.forEach((c6) => c6.setScale(ScaleDimension.X, config.xScale));
    if (config.yScale)
      components.forEach((c6) => c6.setScale(ScaleDimension.Y, config.yScale));
  }
  _updateScalesDomain(...components) {
    const { config } = this;
    if (!components)
      return;
    const componentsWithDomain = components.filter((c6) => !c6.config.excludeFromDomainCalculation);
    Object.values(ScaleDimension).forEach((dimension) => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const [min7, max8] = extent(merge(componentsWithDomain.map((c6) => c6.getDataExtent(dimension, config.scaleByDomain))));
      const configuredDomain = dimension === ScaleDimension.Y ? config.yDomain : config.xDomain;
      const configuredDomainMinConstraint = dimension === ScaleDimension.Y ? config.yDomainMinConstraint : config.xDomainMinConstraint;
      const configuredDomainMaxConstraint = dimension === ScaleDimension.Y ? config.yDomainMaxConstraint : config.xDomainMaxConstraint;
      const domainMin = (_b = (_a = configuredDomain === null || configuredDomain === void 0 ? void 0 : configuredDomain[0]) !== null && _a !== void 0 ? _a : min7) !== null && _b !== void 0 ? _b : 0;
      const domainMax = (_d = (_c = configuredDomain === null || configuredDomain === void 0 ? void 0 : configuredDomain[1]) !== null && _c !== void 0 ? _c : max8) !== null && _d !== void 0 ? _d : 1;
      const domain = [
        clamp(domainMin, (_e = configuredDomainMinConstraint === null || configuredDomainMinConstraint === void 0 ? void 0 : configuredDomainMinConstraint[0]) !== null && _e !== void 0 ? _e : Number.NEGATIVE_INFINITY, (_f = configuredDomainMinConstraint === null || configuredDomainMinConstraint === void 0 ? void 0 : configuredDomainMinConstraint[1]) !== null && _f !== void 0 ? _f : Number.POSITIVE_INFINITY),
        clamp(domainMax, (_g = configuredDomainMaxConstraint === null || configuredDomainMaxConstraint === void 0 ? void 0 : configuredDomainMaxConstraint[0]) !== null && _g !== void 0 ? _g : Number.NEGATIVE_INFINITY, (_h = configuredDomainMaxConstraint === null || configuredDomainMaxConstraint === void 0 ? void 0 : configuredDomainMaxConstraint[1]) !== null && _h !== void 0 ? _h : Number.POSITIVE_INFINITY)
      ];
      if (domain[0] === domain[1]) {
        const hasDataProvided = componentsWithDomain.some((c6) => {
          var _a2;
          return ((_a2 = c6.datamodel.data) === null || _a2 === void 0 ? void 0 : _a2.length) > 0;
        });
        if (config.preventEmptyDomain || config.preventEmptyDomain === null && (!hasDataProvided || dimension === ScaleDimension.Y)) {
          domain[1] = domain[0] + 1;
        }
      }
      components.forEach((c6) => c6.setScaleDomain(dimension, domain));
    });
  }
  _updateScalesRange(...components) {
    var _a, _b, _c, _d, _e, _f;
    const { config } = this;
    if (!components)
      return;
    const isYDirectionSouth = config.yDirection === Direction.South;
    const xRange = [(_a = config.padding.left) !== null && _a !== void 0 ? _a : 0, this.width - ((_b = config.padding.right) !== null && _b !== void 0 ? _b : 0)];
    const yRange = [this.height - ((_c = config.padding.bottom) !== null && _c !== void 0 ? _c : 0), (_d = config.padding.top) !== null && _d !== void 0 ? _d : 0];
    if (isYDirectionSouth)
      yRange.reverse();
    for (const c6 of components) {
      c6.setSize(this.width, this.height, this.containerWidth, this.containerHeight);
      c6.setScaleRange(ScaleDimension.X, (_e = config.xRange) !== null && _e !== void 0 ? _e : xRange);
      c6.setScaleRange(ScaleDimension.Y, (_f = config.yRange) !== null && _f !== void 0 ? _f : yRange);
    }
    const bleed = components.map((c6) => c6.bleed).reduce((bleed2, b25) => {
      for (const key of Object.keys(bleed2)) {
        const k17 = key;
        if (bleed2[k17] < b25[k17])
          bleed2[k17] = b25[k17];
      }
      return bleed2;
    }, { top: 0, bottom: 0, left: 0, right: 0 });
    for (const c6 of components) {
      c6.setScaleRange(ScaleDimension.X, [xRange[0] + bleed.left, xRange[1] - bleed.right]);
      c6.setScaleRange(
        ScaleDimension.Y,
        isYDirectionSouth ? [yRange[0] + bleed.top, yRange[1] - bleed.bottom] : [yRange[0] - bleed.bottom, yRange[1] + bleed.top]
        // if Y axis is directed upwards
      );
    }
  }
  _renderAxes(duration) {
    const { config: { xAxis, yAxis } } = this;
    const margin = this._getMargin();
    const axes = clean([xAxis, yAxis]);
    axes.forEach((axis3) => {
      const offset = axis3.getOffset(margin);
      axis3.g.attr("transform", `translate(${offset.left},${offset.top})`);
      axis3.render(duration);
    });
  }
  _setAutoMargin() {
    const { config: { xAxis, yAxis } } = this;
    const components = clean([...this.components, xAxis, yAxis]);
    this._setScales(...components);
    this._updateScalesDomain(...components);
    const numIterations = this._firstRender ? 2 : 1;
    for (let i8 = 0; i8 < numIterations; i8 += 1) {
      const axisMargin = { top: 0, bottom: 0, left: 0, right: 0 };
      this._updateScalesRange(...components);
      const axes = clean([xAxis, yAxis]);
      axes.forEach((axis3) => {
        axis3.preRender();
        const m30 = axis3.getRequiredMargin();
        if (axisMargin.top < m30.top)
          axisMargin.top = m30.top;
        if (axisMargin.bottom < m30.bottom)
          axisMargin.bottom = m30.bottom;
        if (axisMargin.left < m30.left)
          axisMargin.left = m30.left;
        if (axisMargin.right < m30.right)
          axisMargin.right = m30.right;
      });
      this._axisMargin = axisMargin;
    }
  }
  _getMargin() {
    const { config: { margin } } = this;
    return {
      top: margin.top + this._axisMargin.top,
      bottom: margin.bottom + this._axisMargin.bottom,
      left: margin.left + this._axisMargin.left,
      right: margin.right + this._axisMargin.right
    };
  }
  destroy() {
    const { components, config: { tooltip: tooltip2, crosshair, annotations, xAxis, yAxis } } = this;
    super.destroy();
    for (const c6 of components)
      c6 === null || c6 === void 0 ? void 0 : c6.destroy();
    tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.destroy();
    crosshair === null || crosshair === void 0 ? void 0 : crosshair.destroy();
    annotations === null || annotations === void 0 ? void 0 : annotations.destroy();
    xAxis === null || xAxis === void 0 ? void 0 : xAxis.destroy();
    yAxis === null || yAxis === void 0 ? void 0 : yAxis.destroy();
  }
};

// node_modules/@unovis/ts/core/component/config.js
var ComponentDefaultConfig = {
  duration: 600,
  events: {},
  attributes: {}
};

// node_modules/@unovis/ts/core/component/index.js
var ComponentCore = class {
  constructor(type2 = ComponentType.SVG) {
    var _a, _b;
    this.type = ComponentType.SVG;
    this.datamodel = new CoreDataModel();
    this.sizing = Sizing.Fit;
    this.events = {};
    this._defaultConfig = ComponentDefaultConfig;
    this._width = 400;
    this._height = 200;
    this._containerWidth = void 0;
    this._containerHeight = void 0;
    this._containerMargin = { top: 0, bottom: 0, left: 0, right: 0 };
    this._setUpComponentEventsThrottled = throttle(this._setUpComponentEvents, 500);
    this._setCustomAttributesThrottled = throttle(this._setCustomAttributes, 500);
    if (type2 === ComponentType.SVG) {
      this.element = document.createElementNS("http://www.w3.org/2000/svg", "g");
    } else {
      this.element = document.createElement("div");
    }
    this.uid = guid();
    this.g = select_default2(this.element);
    const rootClass = (_b = (_a = this.constructor) === null || _a === void 0 ? void 0 : _a["selectors"]) === null || _b === void 0 ? void 0 : _b.root;
    if (rootClass)
      this.g.attr("class", rootClass);
  }
  /** Set the container margin. Called automatically by containers. */
  setContainerMargin(margin) {
    this._containerMargin = margin;
  }
  setConfig(config) {
    this.prevConfig = this.config;
    this.config = merge2(this._defaultConfig, config);
  }
  setData(data) {
    this.datamodel.data = data;
  }
  setSize(width, height, containerWidth, containerHeight) {
    if (isFinite(width))
      this._width = width;
    if (isFinite(height))
      this._height = height;
    if (isFinite(containerWidth))
      this._containerWidth = containerWidth;
    if (isFinite(containerHeight))
      this._containerHeight = containerHeight;
  }
  render(duration = this.config.duration) {
    this._render(duration);
    const ANIMATING_ATTR = "animating";
    if (duration) {
      this.g.attr(ANIMATING_ATTR, "");
      const transition2 = this.g.transition(ANIMATING_ATTR).duration(duration);
      transition2.on("end interrupt", () => {
        this.g.attr(ANIMATING_ATTR, null);
      });
    }
    this._setUpComponentEventsThrottled();
    this._setCustomAttributesThrottled();
  }
  get bleed() {
    return { top: 0, bottom: 0, left: 0, right: 0 };
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  _render(duration = this.config.duration) {
  }
  _setCustomAttributes() {
    const attributeMap = this.config.attributes;
    Object.keys(attributeMap).forEach((className) => {
      Object.keys(attributeMap[className]).forEach((attr) => {
        const selection2 = this.g.selectAll(`.${className}`);
        selection2.attr(attr, attributeMap[className][attr]);
      });
    });
  }
  _setUpComponentEvents() {
    this._bindEvents(this.events);
    this._bindEvents(this.config.events, ".user");
  }
  _bindEvents(events2 = this.events, suffix = "") {
    Object.keys(events2).forEach((className) => {
      Object.keys(events2[className]).forEach((eventType) => {
        const selection2 = this.g.selectAll(`.${className}`);
        selection2.on(eventType + suffix, (event, d18) => {
          const els = selection2.nodes();
          const i8 = els.indexOf(event.currentTarget);
          const eventFunction = events2[className][eventType];
          return eventFunction === null || eventFunction === void 0 ? void 0 : eventFunction(d18, event, i8, els);
        });
      });
    });
  }
  destroy() {
    var _a;
    (_a = this.g) === null || _a === void 0 ? void 0 : _a.remove();
    this.element = void 0;
  }
  isDestroyed() {
    return !this.element;
  }
};

// node_modules/@unovis/ts/data-models/series.js
var SeriesDataModel = class extends CoreDataModel {
  constructor(data) {
    super(data);
  }
  get data() {
    var _a;
    return (_a = this._data) !== null && _a !== void 0 ? _a : [];
  }
  set data(data) {
    if (Array.isArray(data))
      this._data = data;
  }
};

// node_modules/@unovis/ts/core/xy-component/config.js
var XYComponentDefaultConfig = Object.assign(Object.assign({}, ComponentDefaultConfig), { x: void 0, y: void 0, id: (d18, i8) => {
  var _a;
  return (_a = d18.id) !== null && _a !== void 0 ? _a : `${i8}`;
}, color: (d18) => d18.color, xScale: void 0, yScale: void 0, excludeFromDomainCalculation: false });

// node_modules/@unovis/ts/core/xy-component/index.js
var XYComponentCore = class extends ComponentCore {
  constructor() {
    super(...arguments);
    this.datamodel = new SeriesDataModel();
    this.clippable = true;
    this.stacked = false;
    this._defaultConfig = XYComponentDefaultConfig;
    this._xScale = Scale.scaleLinear();
    this._yScale = Scale.scaleLinear();
  }
  get xScale() {
    return this.config.xScale || this._xScale;
  }
  get yScale() {
    return this.config.yScale || this._yScale;
  }
  setConfig(config) {
    var _a, _b;
    if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.xScale)
      config.xScale = this.config.xScale;
    if ((_b = this.config) === null || _b === void 0 ? void 0 : _b.yScale)
      config.yScale = this.config.yScale;
    super.setConfig(config);
  }
  setScaleDomain(dimension, domain) {
    var _a, _b;
    if (dimension === ScaleDimension.X)
      (_a = this._xScale) === null || _a === void 0 ? void 0 : _a.domain(domain);
    if (dimension === ScaleDimension.Y)
      (_b = this._yScale) === null || _b === void 0 ? void 0 : _b.domain(domain);
  }
  setScaleRange(dimension, range3) {
    var _a, _b;
    if (dimension === ScaleDimension.X)
      (_a = this._xScale) === null || _a === void 0 ? void 0 : _a.range(range3);
    if (dimension === ScaleDimension.Y)
      (_b = this._yScale) === null || _b === void 0 ? void 0 : _b.range(range3);
  }
  setScale(dimension, scale) {
    if (scale && dimension === ScaleDimension.X)
      this._xScale = scale;
    if (scale && dimension === ScaleDimension.Y)
      this._yScale = scale;
  }
  getDataExtent(dimension, scaleByVisibleData) {
    const { config, datamodel } = this;
    switch (dimension) {
      case ScaleDimension.X:
        return this.getXDataExtent();
      case ScaleDimension.Y:
        return this.getYDataExtent(scaleByVisibleData);
      default:
        return getExtent(datamodel.data, config[dimension]);
    }
  }
  getXDataExtent() {
    const { config, datamodel } = this;
    return getExtent(datamodel.data, config.x);
  }
  /** Some components override this method to provide custom data extent calculation */
  getYDataExtent(scaleByVisibleData) {
    const { config, datamodel } = this;
    const xDomain = this.xScale.domain();
    const data = scaleByVisibleData ? filterDataByRange(datamodel.data, xDomain, config.x, true) : datamodel.data;
    const yAccessors = isArray(config.y) ? config.y : [config.y];
    return getExtent(data, ...yAccessors);
  }
};

// node_modules/@unovis/ts/types/position.js
var Position;
(function(Position2) {
  Position2["Top"] = "top";
  Position2["Bottom"] = "bottom";
  Position2["Left"] = "left";
  Position2["Right"] = "right";
  Position2["Center"] = "center";
  Position2["Auto"] = "auto";
})(Position || (Position = {}));
var PositionStrategy;
(function(PositionStrategy2) {
  PositionStrategy2["Absolute"] = "absolute";
  PositionStrategy2["Fixed"] = "fixed";
})(PositionStrategy || (PositionStrategy = {}));
var Arrangement;
(function(Arrangement2) {
  Arrangement2["Inside"] = "inside";
  Arrangement2["Outside"] = "outside";
  Arrangement2["Center"] = "center";
})(Arrangement || (Arrangement = {}));
var Orientation;
(function(Orientation2) {
  Orientation2["Horizontal"] = "horizontal";
  Orientation2["Vertical"] = "vertical";
})(Orientation || (Orientation = {}));

// node_modules/@unovis/ts/components/tooltip/config.js
var TooltipDefaultConfig = {
  components: [],
  container: void 0,
  followCursor: true,
  allowHover: false,
  horizontalPlacement: Position.Auto,
  horizontalShift: 0,
  verticalPlacement: Position.Top,
  verticalShift: 0,
  attributes: {},
  triggers: {},
  className: void 0,
  showDelay: void 0,
  hideDelay: void 0
};

// node_modules/@unovis/ts/components/tooltip/style.js
var style_exports = {};
__export(style_exports, {
  hidden: () => hidden,
  nonInteractive: () => nonInteractive,
  positionFixed: () => positionFixed,
  root: () => root2,
  show: () => show,
  tooltip: () => tooltip,
  variables: () => variables2
});
var root2 = css`
  label: tooltip;
  display: inline-block;
  left: 0;
  bottom: 0;
  min-width: max-content;
  position: absolute;
  opacity: 0;
  transition: opacity;
  transition-duration: var(--vis-tooltip-transition-duration);
  z-index: 999999;
  padding: var(--vis-tooltip-padding);
  color: var(--vis-tooltip-text-color);
  border-radius: var(--vis-tooltip-border-radius);
  box-shadow: var(--vis-tooltip-box-shadow);
  border: solid 1px var(--vis-tooltip-border-color);
  background-color: var(--vis-tooltip-background-color);
  backdrop-filter: var(--vis-tooltip-backdrop-filter);
`;
var tooltip = root2;
var variables2 = injectGlobal`
  :root {
    --vis-tooltip-background-color: rgba(255, 255, 255, 0.95);
    --vis-tooltip-border-color: #e5e9f7;
    --vis-tooltip-text-color: #000;
    --vis-tooltip-shadow-color: rgba(172, 179, 184, 0.35);
    --vis-tooltip-backdrop-filter: none;
    --vis-tooltip-padding: 10px 15px;
    --vis-tooltip-border-radius: 5px;
    --vis-tooltip-transition-duration: 300ms;
    --vis-tooltip-box-shadow: none;

    --vis-dark-tooltip-background-color: rgba(30,30,30, 0.95);
    --vis-dark-tooltip-text-color: #e5e9f7;
    --vis-dark-tooltip-border-color: var(--vis-color-grey);
    --vis-dark-tooltip-shadow-color: rgba(0,0,0, 0.95);
  }

  body.theme-dark ${`.${root2}`} {
    --vis-tooltip-background-color: var(--vis-dark-tooltip-background-color);
    --vis-tooltip-text-color: var(--vis-dark-tooltip-text-color);
    --vis-tooltip-border-color: var(--vis-dark-tooltip-border-color);
    --vis-tooltip-shadow-color: var(--vis-dark-tooltip-shadow-color);
  }

  body.theme-dark {
    --vis-tooltip-background-color: rgba(30,30,30, 0.95);
    --vis-tooltip-text-color: #e5e9f7;
    --vis-tooltip-border-color: var(--vis-color-grey);
    --vis-tooltip-shadow-color: rgba(0,0,0, 0.95);
  }
`;
var positionFixed = css`
  bottom: unset;
  position: fixed;
`;
var show = css`
  opacity: 1;
`;
var hidden = css`
  display: none;
`;
var nonInteractive = css`
  label: non-interactive;
  pointer-events: none;
  user-select: none;
`;

// node_modules/@unovis/ts/components/tooltip/index.js
var Tooltip = class {
  constructor(config = {}) {
    this._defaultConfig = TooltipDefaultConfig;
    this.config = this._defaultConfig;
    this._setUpEventsThrottled = throttle(this._setUpEvents, 500);
    this._setContainerPositionThrottled = throttle(this._setContainerPosition, 500);
    this._isShown = false;
    this.element = document.createElement("div");
    this.div = select_default2(this.element).attr("class", root2).classed(show, false).classed(hidden, true);
    this.setConfig(config);
    this.components = this.config.components;
    this._mutationObserver = new MutationObserver(() => {
      if (!this._isShown)
        return;
      if (!this.config.followCursor && this._hoveredElement) {
        this.placeByElement(this._hoveredElement);
      } else if (this._position) {
        this.place({ x: this._position[0], y: this._position[1] });
      }
    });
    this._mutationObserver.observe(this.div.node(), { childList: true, subtree: true });
  }
  setConfig(config) {
    var _a;
    this.prevConfig = this.config;
    this.config = merge2(this._defaultConfig, config);
    if (this.prevConfig.horizontalPlacement !== this.config.horizontalPlacement) {
      this.overrideHorizontalPlacement(void 0);
    }
    if (this.config.container && this.config.container !== ((_a = this.prevConfig) === null || _a === void 0 ? void 0 : _a.container)) {
      this.setContainer(this.config.container);
    }
    this._setUpAttributes();
  }
  setContainer(container) {
    var _a;
    (_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this.element);
    this._container = container;
    this._container.appendChild(this.element);
    this._setContainerPositionThrottled();
  }
  getContainer() {
    return this._container;
  }
  hasContainer() {
    return !!this._container && this._container.isConnected;
  }
  setComponents(components) {
    this.components = components;
  }
  update() {
    if (!this._container)
      return;
    this._setUpEventsThrottled();
  }
  /** Show the tooltip immediately by providing content and position */
  show(html, pos) {
    this.render(html);
    this.place(pos);
  }
  _hide() {
    this.div.classed(show, false).on("transitionend", () => {
      this.div.classed(hidden, !this._isShown);
    });
    this._isShown = false;
  }
  /** Hides the tooltip after `hideDelay` */
  hide() {
    window.clearTimeout(this._showDelayTimeoutId);
    if (this.config.hideDelay) {
      window.clearTimeout(this._hideDelayTimeoutId);
      this._hideDelayTimeoutId = setTimeout(() => this._hide(), this.config.hideDelay);
    } else {
      this._hide();
    }
  }
  _display() {
    window.clearTimeout(this._hideDelayTimeoutId);
    this.div.classed(hidden, false).classed(show, true);
    this._isShown = true;
  }
  /** Simply display the tooltip with its previous content on position, taking into account `showDelay` */
  display() {
    if (this._isShown)
      return;
    if (this.config.showDelay) {
      window.clearTimeout(this._showDelayTimeoutId);
      this._showDelayTimeoutId = setTimeout(() => {
        this._display();
        this.place({ x: this._position[0], y: this._position[1] });
      }, this.config.showDelay);
    } else {
      this._display();
    }
  }
  place(pos) {
    this._position = [pos.x, pos.y];
    if (!this.hasContainer()) {
      console.warn("Unovis | Tooltip: Container was not set or is not initialized yet");
      return;
    }
    const { config } = this;
    const tooltipWidth = this.element.offsetWidth;
    const tooltipHeight = this.element.offsetHeight;
    const horizontalPlacement = this._overriddenHorizontalPlacement || (config.horizontalPlacement === Position.Auto ? Position.Center : config.horizontalPlacement);
    const verticalPlacement = config.verticalPlacement === Position.Auto ? pos.y - tooltipHeight < 0 ? Position.Bottom : Position.Top : config.verticalPlacement;
    const margin = 5;
    const translateX2 = horizontalPlacement === Position.Left ? -tooltipWidth - margin - config.horizontalShift : horizontalPlacement === Position.Center ? -tooltipWidth / 2 : margin + config.horizontalShift;
    const translateY2 = verticalPlacement === Position.Bottom ? margin + config.verticalShift : verticalPlacement === Position.Center ? -tooltipHeight / 2 : -margin - config.verticalShift - tooltipHeight;
    const [top2, left3] = this._constraintPosToContainer(pos.x + translateX2, pos.y + translateY2, tooltipWidth, tooltipHeight);
    this._applyPosition(top2, left3, tooltipHeight);
  }
  placeByElement(hoveredElement) {
    const { config } = this;
    this._hoveredElement = hoveredElement;
    const margin = 5;
    const tooltipWidth = this.element.offsetWidth;
    const tooltipHeight = this.element.offsetHeight;
    const isContainerBody = this.isContainerBody();
    const containerWidth = isContainerBody ? window.innerWidth : this._container.scrollWidth;
    const hoveredElementRect = hoveredElement.getBoundingClientRect();
    const elementPos = isContainerBody ? [hoveredElementRect.x, hoveredElementRect.y] : pointer_default({
      clientX: hoveredElementRect.x,
      clientY: hoveredElementRect.y,
      pageX: hoveredElementRect.x,
      pageY: hoveredElementRect.y
    }, this._container);
    const horizontalPlacement = this._overriddenHorizontalPlacement || (config.horizontalPlacement === Position.Auto ? elementPos[0] - tooltipWidth < 0 ? Position.Right : elementPos[0] + tooltipWidth > containerWidth ? Position.Left : Position.Center : config.horizontalPlacement);
    let translateX2 = 0;
    switch (horizontalPlacement) {
      case Position.Left:
        translateX2 = -tooltipWidth - margin - config.horizontalShift;
        break;
      case Position.Right:
        translateX2 = hoveredElementRect.width + margin + config.horizontalShift;
        break;
      case Position.Center:
      default:
        translateX2 = (-tooltipWidth + hoveredElementRect.width) / 2;
        break;
    }
    const verticalPlacement = config.verticalPlacement === Position.Auto ? horizontalPlacement !== Position.Center ? Position.Center : elementPos[1] - tooltipHeight < 0 ? Position.Bottom : Position.Top : config.verticalPlacement;
    let translateY2 = -tooltipHeight;
    switch (verticalPlacement) {
      case Position.Center:
        translateY2 += (tooltipHeight + hoveredElementRect.height) / 2;
        break;
      case Position.Bottom:
        translateY2 += tooltipHeight + hoveredElementRect.height + margin + config.verticalShift;
        break;
      case Position.Top:
      default:
        translateY2 += -margin - config.verticalShift;
        break;
    }
    const [top2, left3] = this._constraintPosToContainer(elementPos[0] + translateX2, elementPos[1] + translateY2, tooltipWidth, tooltipHeight);
    this._applyPosition(top2, left3, tooltipHeight);
  }
  isContainerBody() {
    return this._container === document.body;
  }
  /** Allows to override the horizontal placement of the tooltip which is useful when you want to define custom positioning behavior.
   * This method has been added for Crosshair to allow it position tooltip left or right of the crosshair line
   * (see the `_showTooltip` method of the Crosshair component).
   */
  overrideHorizontalPlacement(placement) {
    this._overriddenHorizontalPlacement = placement;
  }
  render(html) {
    var _a;
    const { config, prevConfig } = this;
    if (html instanceof HTMLElement) {
      const node4 = this.div.select(":first-child").node();
      if (node4 !== html)
        this.div.html("").append(() => html);
    } else if (html) {
      this.div.html(html);
    }
    this.div.classed((_a = config.className) !== null && _a !== void 0 ? _a : "", Boolean(config.className)).classed(nonInteractive, !config.allowHover);
    if ((prevConfig === null || prevConfig === void 0 ? void 0 : prevConfig.className) && prevConfig.className !== config.className) {
      this.div.classed(prevConfig.className, false);
    }
    this.display();
  }
  _applyPosition(x21, y25, tooltipHeight) {
    const isContainerBody = this.isContainerBody();
    const containerHeight = isContainerBody ? window.innerHeight : this._container.scrollHeight;
    this.div.classed(positionFixed, isContainerBody).style("top", isContainerBody ? `${y25}px` : "unset").style("bottom", !isContainerBody ? `${containerHeight - y25 - tooltipHeight}px` : "unset").style("left", `${x21}px`);
  }
  _constraintPosToContainer(top2, left3, tooltipWidth, tooltipHeight) {
    const isContainerBody = this.isContainerBody();
    const containerHeight = isContainerBody ? window.innerHeight : this._container.scrollHeight;
    const containerWidth = isContainerBody ? window.innerWidth : this._container.scrollWidth;
    const paddingX = 10;
    const hitRight = top2 > containerWidth - tooltipWidth - paddingX;
    const hitLeft = top2 < paddingX;
    const constrainedLeft = hitRight ? containerWidth - tooltipWidth - paddingX : hitLeft ? paddingX : top2;
    const paddingY = 10;
    const hitBottom = left3 > containerHeight - tooltipHeight - paddingY;
    const hitTop = left3 < paddingY;
    const constrainedTop = hitBottom ? containerHeight - tooltipHeight - paddingY : hitTop ? paddingY : left3;
    return [
      containerWidth < tooltipWidth ? 0 : constrainedLeft,
      containerHeight < tooltipHeight ? 0 : constrainedTop
    ];
  }
  _setContainerPosition() {
    var _a;
    if (this._container !== document.body && ((_a = getComputedStyle(this._container)) === null || _a === void 0 ? void 0 : _a.position) === "static") {
      this._container.style.position = "relative";
    }
  }
  _setUpEvents() {
    const { config } = this;
    this.components.forEach((component) => {
      const selection2 = select_default2(component.element);
      selection2.on("mousemove.tooltip", (e3) => {
        const { config: currentConfig } = this;
        const path3 = e3.composedPath && e3.composedPath() || e3.path || [e3.target];
        for (const className of Object.keys(currentConfig.triggers)) {
          const template = currentConfig.triggers[className];
          if (!template)
            continue;
          const els = selection2.selectAll(`.${className}`).nodes();
          for (const el of path3) {
            if (el === selection2.node())
              break;
            if (el.classList.contains(className)) {
              const i8 = els.indexOf(el);
              const d18 = select_default2(el).datum();
              const content = template(d18, i8, els);
              const [x21, y25] = this.isContainerBody() ? [e3.clientX, e3.clientY] : pointer_default(e3, this._container);
              if (content === null) {
                this.hide();
              } else {
                this.render(content);
                if (currentConfig.followCursor)
                  this.place({ x: x21, y: y25 });
                else
                  this.placeByElement(el);
              }
              e3.stopPropagation();
              return;
            }
          }
        }
        if (this._isShown)
          this.hide();
      }).on("mouseleave.tooltip", (e3) => {
        e3.stopPropagation();
        this.hide();
      });
    });
    if (config.allowHover) {
      this.div.on("mouseenter.tooltip", this._display.bind(this)).on("mouseleave.tooltip", this.hide.bind(this));
    } else {
      this.div.on("mouseenter.tooltip", null).on("mouseleave.tooltip", null);
    }
  }
  _setUpAttributes() {
    const attributesMap = this.config.attributes;
    if (!attributesMap)
      return;
    Object.keys(attributesMap).forEach((attr) => {
      this.div.attr(attr, attributesMap[attr]);
    });
  }
  destroy() {
    var _a;
    this._mutationObserver.disconnect();
    window.clearTimeout(this._hideDelayTimeoutId);
    window.clearTimeout(this._showDelayTimeoutId);
    (_a = this.div) === null || _a === void 0 ? void 0 : _a.remove();
  }
};
Tooltip.selectors = style_exports;

// node_modules/d3-shape/src/constant.js
function constant_default3(x21) {
  return function constant2() {
    return x21;
  };
}

// node_modules/d3-shape/src/math.js
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max2 = Math.max;
var min2 = Math.min;
var sin = Math.sin;
var sqrt2 = Math.sqrt;
var epsilon = 1e-12;
var pi2 = Math.PI;
var halfPi2 = pi2 / 2;
var tau2 = 2 * pi2;
function acos(x21) {
  return x21 > 1 ? 0 : x21 < -1 ? pi2 : Math.acos(x21);
}
function asin(x21) {
  return x21 >= 1 ? halfPi2 : x21 <= -1 ? -halfPi2 : Math.asin(x21);
}

// node_modules/d3-path/src/path.js
var pi3 = Math.PI;
var tau3 = 2 * pi3;
var epsilon3 = 1e-6;
var tauEpsilon = tau3 - epsilon3;
function append(strings) {
  this._ += strings[0];
  for (let i8 = 1, n = strings.length; i8 < n; ++i8) {
    this._ += arguments[i8] + strings[i8];
  }
}
function appendRound(digits) {
  let d18 = Math.floor(digits);
  if (!(d18 >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d18 > 15) return append;
  const k17 = 10 ** d18;
  return function(strings) {
    this._ += strings[0];
    for (let i8 = 1, n = strings.length; i8 < n; ++i8) {
      this._ += Math.round(arguments[i8] * k17) / k17 + strings[i8];
    }
  };
}
var Path = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x21, y25) {
    this._append`M${this._x0 = this._x1 = +x21},${this._y0 = this._y1 = +y25}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x21, y25) {
    this._append`L${this._x1 = +x21},${this._y1 = +y25}`;
  }
  quadraticCurveTo(x110, y110, x21, y25) {
    this._append`Q${+x110},${+y110},${this._x1 = +x21},${this._y1 = +y25}`;
  }
  bezierCurveTo(x110, y110, x22, y25, x21, y26) {
    this._append`C${+x110},${+y110},${+x22},${+y25},${this._x1 = +x21},${this._y1 = +y26}`;
  }
  arcTo(x110, y110, x22, y25, r4) {
    x110 = +x110, y110 = +y110, x22 = +x22, y25 = +y25, r4 = +r4;
    if (r4 < 0) throw new Error(`negative radius: ${r4}`);
    let x06 = this._x1, y06 = this._y1, x21 = x22 - x110, y212 = y25 - y110, x01 = x06 - x110, y01 = y06 - y110, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x110},${this._y1 = y110}`;
    } else if (!(l01_2 > epsilon3)) ;
    else if (!(Math.abs(y01 * x21 - y212 * x01) > epsilon3) || !r4) {
      this._append`L${this._x1 = x110},${this._y1 = y110}`;
    } else {
      let x202 = x22 - x06, y202 = y25 - y06, l21_2 = x21 * x21 + y212 * y212, l20_2 = x202 * x202 + y202 * y202, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l7 = r4 * Math.tan((pi3 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l7 / l01, t21 = l7 / l21;
      if (Math.abs(t01 - 1) > epsilon3) {
        this._append`L${x110 + t01 * x01},${y110 + t01 * y01}`;
      }
      this._append`A${r4},${r4},0,0,${+(y01 * x202 > x01 * y202)},${this._x1 = x110 + t21 * x21},${this._y1 = y110 + t21 * y212}`;
    }
  }
  arc(x21, y25, r4, a0, a1, ccw) {
    x21 = +x21, y25 = +y25, r4 = +r4, ccw = !!ccw;
    if (r4 < 0) throw new Error(`negative radius: ${r4}`);
    let dx = r4 * Math.cos(a0), dy = r4 * Math.sin(a0), x06 = x21 + dx, y06 = y25 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x06},${y06}`;
    } else if (Math.abs(this._x1 - x06) > epsilon3 || Math.abs(this._y1 - y06) > epsilon3) {
      this._append`L${x06},${y06}`;
    }
    if (!r4) return;
    if (da < 0) da = da % tau3 + tau3;
    if (da > tauEpsilon) {
      this._append`A${r4},${r4},0,1,${cw},${x21 - dx},${y25 - dy}A${r4},${r4},0,1,${cw},${this._x1 = x06},${this._y1 = y06}`;
    } else if (da > epsilon3) {
      this._append`A${r4},${r4},0,${+(da >= pi3)},${cw},${this._x1 = x21 + r4 * Math.cos(a1)},${this._y1 = y25 + r4 * Math.sin(a1)}`;
    }
  }
  rect(x21, y25, w14, h17) {
    this._append`M${this._x0 = this._x1 = +x21},${this._y0 = this._y1 = +y25}h${w14 = +w14}v${+h17}h${-w14}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path();
}
path.prototype = Path.prototype;

// node_modules/d3-shape/src/path.js
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_17) {
    if (!arguments.length) return digits;
    if (_17 == null) {
      digits = null;
    } else {
      const d18 = Math.floor(_17);
      if (!(d18 >= 0)) throw new RangeError(`invalid digits: ${_17}`);
      digits = d18;
    }
    return shape;
  };
  return () => new Path(digits);
}

// node_modules/d3-shape/src/arc.js
function arcInnerRadius(d18) {
  return d18.innerRadius;
}
function arcOuterRadius(d18) {
  return d18.outerRadius;
}
function arcStartAngle(d18) {
  return d18.startAngle;
}
function arcEndAngle(d18) {
  return d18.endAngle;
}
function arcPadAngle(d18) {
  return d18 && d18.padAngle;
}
function intersect(x06, y06, x110, y110, x22, y25, x32, y32) {
  var x102 = x110 - x06, y102 = y110 - y06, x322 = x32 - x22, y322 = y32 - y25, t4 = y322 * x102 - x322 * y102;
  if (t4 * t4 < epsilon) return;
  t4 = (x322 * (y06 - y25) - y322 * (x06 - x22)) / t4;
  return [x06 + t4 * x102, y06 + t4 * y102];
}
function cornerTangents(x06, y06, x110, y110, r1, rc, cw) {
  var x01 = x06 - x110, y01 = y06 - y110, lo = (cw ? rc : -rc) / sqrt2(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x112 = x06 + ox, y112 = y06 + oy, x102 = x110 + ox, y102 = y110 + oy, x004 = (x112 + x102) / 2, y004 = (y112 + y102) / 2, dx = x102 - x112, dy = y102 - y112, d22 = dx * dx + dy * dy, r4 = r1 - rc, D10 = x112 * y102 - x102 * y112, d18 = (dy < 0 ? -1 : 1) * sqrt2(max2(0, r4 * r4 * d22 - D10 * D10)), cx0 = (D10 * dy - dx * d18) / d22, cy0 = (-D10 * dx - dy * d18) / d22, cx1 = (D10 * dy + dx * d18) / d22, cy1 = (-D10 * dx + dy * d18) / d22, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r4 - 1),
    y11: cy0 * (r1 / r4 - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default3(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path3 = withPath(arc2);
  function arc2() {
    var buffer, r4, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi2, a1 = endAngle.apply(this, arguments) - halfPi2, da = abs(a1 - a0), cw = a1 > a0;
    if (!context) context = buffer = path3();
    if (r1 < r0) r4 = r1, r1 = r0, r0 = r4;
    if (!(r1 > epsilon)) context.moveTo(0, 0);
    else if (da > tau2 - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt2(r0 * r0 + r1 * r1)), rc = min2(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t03, t13;
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x102 = r0 * cos(a10), y102 = r0 * sin(a10);
      if (rc > epsilon) {
        var x112 = r1 * cos(a11), y112 = r1 * sin(a11), x004 = r0 * cos(a00), y004 = r0 * sin(a00), oc;
        if (da < pi2) {
          if (oc = intersect(x01, y01, x004, y004, x112, y112, x102, y102)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x112 - oc[0], by = y112 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt2(ax * ax + ay * ay) * sqrt2(bx * bx + by * by))) / 2), lc = sqrt2(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min2(rc, (r0 - lc) / (kc - 1));
            rc1 = min2(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon)) context.moveTo(x01, y01);
      else if (rc1 > epsilon) {
        t03 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw);
        t13 = cornerTangents(x112, y112, x102, y102, r1, rc1, cw);
        context.moveTo(t03.cx + t03.x01, t03.cy + t03.y01);
        if (rc1 < rc) context.arc(t03.cx, t03.cy, rc1, atan2(t03.y01, t03.x01), atan2(t13.y01, t13.x01), !cw);
        else {
          context.arc(t03.cx, t03.cy, rc1, atan2(t03.y01, t03.x01), atan2(t03.y11, t03.x11), !cw);
          context.arc(0, 0, r1, atan2(t03.cy + t03.y11, t03.cx + t03.x11), atan2(t13.cy + t13.y11, t13.cx + t13.x11), !cw);
          context.arc(t13.cx, t13.cy, rc1, atan2(t13.y11, t13.x11), atan2(t13.y01, t13.x01), !cw);
        }
      } else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x102, y102);
      else if (rc0 > epsilon) {
        t03 = cornerTangents(x102, y102, x112, y112, r0, -rc0, cw);
        t13 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw);
        context.lineTo(t03.cx + t03.x01, t03.cy + t03.y01);
        if (rc0 < rc) context.arc(t03.cx, t03.cy, rc0, atan2(t03.y01, t03.x01), atan2(t13.y01, t13.x01), !cw);
        else {
          context.arc(t03.cx, t03.cy, rc0, atan2(t03.y01, t03.x01), atan2(t03.y11, t03.x11), !cw);
          context.arc(0, 0, r0, atan2(t03.cy + t03.y11, t03.cx + t03.x11), atan2(t13.cy + t13.y11, t13.cx + t13.x11), cw);
          context.arc(t13.cx, t13.cy, rc0, atan2(t13.y11, t13.x11), atan2(t13.y01, t13.x01), !cw);
        }
      } else context.arc(0, 0, r0, a10, a00, cw);
    }
    context.closePath();
    if (buffer) return context = null, buffer + "" || null;
  }
  arc2.centroid = function() {
    var r4 = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a7 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi2 / 2;
    return [cos(a7) * r4, sin(a7) * r4];
  };
  arc2.innerRadius = function(_17) {
    return arguments.length ? (innerRadius = typeof _17 === "function" ? _17 : constant_default3(+_17), arc2) : innerRadius;
  };
  arc2.outerRadius = function(_17) {
    return arguments.length ? (outerRadius = typeof _17 === "function" ? _17 : constant_default3(+_17), arc2) : outerRadius;
  };
  arc2.cornerRadius = function(_17) {
    return arguments.length ? (cornerRadius = typeof _17 === "function" ? _17 : constant_default3(+_17), arc2) : cornerRadius;
  };
  arc2.padRadius = function(_17) {
    return arguments.length ? (padRadius = _17 == null ? null : typeof _17 === "function" ? _17 : constant_default3(+_17), arc2) : padRadius;
  };
  arc2.startAngle = function(_17) {
    return arguments.length ? (startAngle = typeof _17 === "function" ? _17 : constant_default3(+_17), arc2) : startAngle;
  };
  arc2.endAngle = function(_17) {
    return arguments.length ? (endAngle = typeof _17 === "function" ? _17 : constant_default3(+_17), arc2) : endAngle;
  };
  arc2.padAngle = function(_17) {
    return arguments.length ? (padAngle = typeof _17 === "function" ? _17 : constant_default3(+_17), arc2) : padAngle;
  };
  arc2.context = function(_17) {
    return arguments.length ? (context = _17 == null ? null : _17, arc2) : context;
  };
  return arc2;
}

// node_modules/d3-shape/src/array.js
var slice = Array.prototype.slice;
function array_default2(x21) {
  return typeof x21 === "object" && "length" in x21 ? x21 : Array.from(x21);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x21, y25) : this._context.moveTo(x21, y25);
        break;
      case 1:
        this._point = 2;
      // falls through
      default:
        this._context.lineTo(x21, y25);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// node_modules/d3-shape/src/point.js
function x(p13) {
  return p13[0];
}
function y(p13) {
  return p13[1];
}

// node_modules/d3-shape/src/line.js
function line_default(x21, y25) {
  var defined = constant_default3(true), context = null, curve = linear_default, output = null, path3 = withPath(line5);
  x21 = typeof x21 === "function" ? x21 : x21 === void 0 ? x : constant_default3(x21);
  y25 = typeof y25 === "function" ? y25 : y25 === void 0 ? y : constant_default3(y25);
  function line5(data) {
    var i8, n = (data = array_default2(data)).length, d18, defined0 = false, buffer;
    if (context == null) output = curve(buffer = path3());
    for (i8 = 0; i8 <= n; ++i8) {
      if (!(i8 < n && defined(d18 = data[i8], i8, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x21(d18, i8, data), +y25(d18, i8, data));
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  line5.x = function(_17) {
    return arguments.length ? (x21 = typeof _17 === "function" ? _17 : constant_default3(+_17), line5) : x21;
  };
  line5.y = function(_17) {
    return arguments.length ? (y25 = typeof _17 === "function" ? _17 : constant_default3(+_17), line5) : y25;
  };
  line5.defined = function(_17) {
    return arguments.length ? (defined = typeof _17 === "function" ? _17 : constant_default3(!!_17), line5) : defined;
  };
  line5.curve = function(_17) {
    return arguments.length ? (curve = _17, context != null && (output = curve(context)), line5) : curve;
  };
  line5.context = function(_17) {
    return arguments.length ? (_17 == null ? context = output = null : output = curve(context = _17), line5) : context;
  };
  return line5;
}

// node_modules/d3-shape/src/area.js
function area_default(x06, y06, y110) {
  var x110 = null, defined = constant_default3(true), context = null, curve = linear_default, output = null, path3 = withPath(area2);
  x06 = typeof x06 === "function" ? x06 : x06 === void 0 ? x : constant_default3(+x06);
  y06 = typeof y06 === "function" ? y06 : y06 === void 0 ? constant_default3(0) : constant_default3(+y06);
  y110 = typeof y110 === "function" ? y110 : y110 === void 0 ? y : constant_default3(+y110);
  function area2(data) {
    var i8, j6, k17, n = (data = array_default2(data)).length, d18, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context == null) output = curve(buffer = path3());
    for (i8 = 0; i8 <= n; ++i8) {
      if (!(i8 < n && defined(d18 = data[i8], i8, data)) === defined0) {
        if (defined0 = !defined0) {
          j6 = i8;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k17 = i8 - 1; k17 >= j6; --k17) {
            output.point(x0z[k17], y0z[k17]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i8] = +x06(d18, i8, data), y0z[i8] = +y06(d18, i8, data);
        output.point(x110 ? +x110(d18, i8, data) : x0z[i8], y110 ? +y110(d18, i8, data) : y0z[i8]);
      }
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default().defined(defined).curve(curve).context(context);
  }
  area2.x = function(_17) {
    return arguments.length ? (x06 = typeof _17 === "function" ? _17 : constant_default3(+_17), x110 = null, area2) : x06;
  };
  area2.x0 = function(_17) {
    return arguments.length ? (x06 = typeof _17 === "function" ? _17 : constant_default3(+_17), area2) : x06;
  };
  area2.x1 = function(_17) {
    return arguments.length ? (x110 = _17 == null ? null : typeof _17 === "function" ? _17 : constant_default3(+_17), area2) : x110;
  };
  area2.y = function(_17) {
    return arguments.length ? (y06 = typeof _17 === "function" ? _17 : constant_default3(+_17), y110 = null, area2) : y06;
  };
  area2.y0 = function(_17) {
    return arguments.length ? (y06 = typeof _17 === "function" ? _17 : constant_default3(+_17), area2) : y06;
  };
  area2.y1 = function(_17) {
    return arguments.length ? (y110 = _17 == null ? null : typeof _17 === "function" ? _17 : constant_default3(+_17), area2) : y110;
  };
  area2.lineX0 = area2.lineY0 = function() {
    return arealine().x(x06).y(y06);
  };
  area2.lineY1 = function() {
    return arealine().x(x06).y(y110);
  };
  area2.lineX1 = function() {
    return arealine().x(x110).y(y06);
  };
  area2.defined = function(_17) {
    return arguments.length ? (defined = typeof _17 === "function" ? _17 : constant_default3(!!_17), area2) : defined;
  };
  area2.curve = function(_17) {
    return arguments.length ? (curve = _17, context != null && (output = curve(context)), area2) : curve;
  };
  area2.context = function(_17) {
    return arguments.length ? (_17 == null ? context = output = null : output = curve(context = _17), area2) : context;
  };
  return area2;
}

// node_modules/d3-shape/src/descending.js
function descending_default(a7, b25) {
  return b25 < a7 ? -1 : b25 > a7 ? 1 : b25 >= a7 ? 0 : NaN;
}

// node_modules/d3-shape/src/identity.js
function identity_default2(d18) {
  return d18;
}

// node_modules/d3-shape/src/pie.js
function pie_default() {
  var value2 = identity_default2, sortValues = descending_default, sort2 = null, startAngle = constant_default3(0), endAngle = constant_default3(tau2), padAngle = constant_default3(0);
  function pie(data) {
    var i8, n = (data = array_default2(data)).length, j6, k17, sum5 = 0, index3 = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau2, Math.max(-tau2, endAngle.apply(this, arguments) - a0)), a1, p13 = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p13 * (da < 0 ? -1 : 1), v28;
    for (i8 = 0; i8 < n; ++i8) {
      if ((v28 = arcs[index3[i8] = i8] = +value2(data[i8], i8, data)) > 0) {
        sum5 += v28;
      }
    }
    if (sortValues != null) index3.sort(function(i9, j7) {
      return sortValues(arcs[i9], arcs[j7]);
    });
    else if (sort2 != null) index3.sort(function(i9, j7) {
      return sort2(data[i9], data[j7]);
    });
    for (i8 = 0, k17 = sum5 ? (da - n * pa) / sum5 : 0; i8 < n; ++i8, a0 = a1) {
      j6 = index3[i8], v28 = arcs[j6], a1 = a0 + (v28 > 0 ? v28 * k17 : 0) + pa, arcs[j6] = {
        data: data[j6],
        index: i8,
        value: v28,
        startAngle: a0,
        endAngle: a1,
        padAngle: p13
      };
    }
    return arcs;
  }
  pie.value = function(_17) {
    return arguments.length ? (value2 = typeof _17 === "function" ? _17 : constant_default3(+_17), pie) : value2;
  };
  pie.sortValues = function(_17) {
    return arguments.length ? (sortValues = _17, sort2 = null, pie) : sortValues;
  };
  pie.sort = function(_17) {
    return arguments.length ? (sort2 = _17, sortValues = null, pie) : sort2;
  };
  pie.startAngle = function(_17) {
    return arguments.length ? (startAngle = typeof _17 === "function" ? _17 : constant_default3(+_17), pie) : startAngle;
  };
  pie.endAngle = function(_17) {
    return arguments.length ? (endAngle = typeof _17 === "function" ? _17 : constant_default3(+_17), pie) : endAngle;
  };
  pie.padAngle = function(_17) {
    return arguments.length ? (padAngle = typeof _17 === "function" ? _17 : constant_default3(+_17), pie) : padAngle;
  };
  return pie;
}

// node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial(curve) {
  this._curve = curve;
}
Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a7, r4) {
    this._curve.point(r4 * Math.sin(a7), r4 * -Math.cos(a7));
  }
};
function curveRadial(curve) {
  function radial2(context) {
    return new Radial(curve(context));
  }
  radial2._curve = curve;
  return radial2;
}

// node_modules/d3-shape/src/lineRadial.js
function lineRadial(l7) {
  var c6 = l7.curve;
  l7.angle = l7.x, delete l7.x;
  l7.radius = l7.y, delete l7.y;
  l7.curve = function(_17) {
    return arguments.length ? c6(curveRadial(_17)) : c6()._curve;
  };
  return l7;
}

// node_modules/d3-shape/src/areaRadial.js
function areaRadial_default() {
  var a7 = area_default().curve(curveRadialLinear), c6 = a7.curve, x06 = a7.lineX0, x110 = a7.lineX1, y06 = a7.lineY0, y110 = a7.lineY1;
  a7.angle = a7.x, delete a7.x;
  a7.startAngle = a7.x0, delete a7.x0;
  a7.endAngle = a7.x1, delete a7.x1;
  a7.radius = a7.y, delete a7.y;
  a7.innerRadius = a7.y0, delete a7.y0;
  a7.outerRadius = a7.y1, delete a7.y1;
  a7.lineStartAngle = function() {
    return lineRadial(x06());
  }, delete a7.lineX0;
  a7.lineEndAngle = function() {
    return lineRadial(x110());
  }, delete a7.lineX1;
  a7.lineInnerRadius = function() {
    return lineRadial(y06());
  }, delete a7.lineY0;
  a7.lineOuterRadius = function() {
    return lineRadial(y110());
  }, delete a7.lineY1;
  a7.curve = function(_17) {
    return arguments.length ? c6(curveRadial(_17)) : c6()._curve;
  };
  return a7;
}

// node_modules/d3-shape/src/symbol/asterisk.js
var sqrt3 = sqrt2(3);

// node_modules/d3-shape/src/symbol/circle.js
var circle_default = {
  draw(context, size2) {
    const r4 = sqrt2(size2 / pi2);
    context.moveTo(r4, 0);
    context.arc(0, 0, r4, 0, tau2);
  }
};

// node_modules/d3-shape/src/symbol/cross.js
var cross_default = {
  draw(context, size2) {
    const r4 = sqrt2(size2 / 5) / 2;
    context.moveTo(-3 * r4, -r4);
    context.lineTo(-r4, -r4);
    context.lineTo(-r4, -3 * r4);
    context.lineTo(r4, -3 * r4);
    context.lineTo(r4, -r4);
    context.lineTo(3 * r4, -r4);
    context.lineTo(3 * r4, r4);
    context.lineTo(r4, r4);
    context.lineTo(r4, 3 * r4);
    context.lineTo(-r4, 3 * r4);
    context.lineTo(-r4, r4);
    context.lineTo(-3 * r4, r4);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt2(1 / 3);
var tan30_2 = tan30 * 2;
var diamond_default = {
  draw(context, size2) {
    const y25 = sqrt2(size2 / tan30_2);
    const x21 = y25 * tan30;
    context.moveTo(0, -y25);
    context.lineTo(x21, 0);
    context.lineTo(0, y25);
    context.lineTo(-x21, 0);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/square.js
var square_default = {
  draw(context, size2) {
    const w14 = sqrt2(size2);
    const x21 = -w14 / 2;
    context.rect(x21, x21, w14, w14);
  }
};

// node_modules/d3-shape/src/symbol/star.js
var ka = 0.8908130915292852;
var kr = sin(pi2 / 10) / sin(7 * pi2 / 10);
var kx = sin(tau2 / 10) * kr;
var ky = -cos(tau2 / 10) * kr;
var star_default = {
  draw(context, size2) {
    const r4 = sqrt2(size2 * ka);
    const x21 = kx * r4;
    const y25 = ky * r4;
    context.moveTo(0, -r4);
    context.lineTo(x21, y25);
    for (let i8 = 1; i8 < 5; ++i8) {
      const a7 = tau2 * i8 / 5;
      const c6 = cos(a7);
      const s12 = sin(a7);
      context.lineTo(s12 * r4, -c6 * r4);
      context.lineTo(c6 * x21 - s12 * y25, s12 * x21 + c6 * y25);
    }
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt32 = sqrt2(3);
var triangle_default = {
  draw(context, size2) {
    const y25 = -sqrt2(size2 / (sqrt32 * 3));
    context.moveTo(0, y25 * 2);
    context.lineTo(-sqrt32 * y25, -y25);
    context.lineTo(sqrt32 * y25, -y25);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/triangle2.js
var sqrt33 = sqrt2(3);

// node_modules/d3-shape/src/symbol/wye.js
var c = -0.5;
var s = sqrt2(3) / 2;
var k = 1 / sqrt2(12);
var a = (k / 2 + 1) * 3;
var wye_default = {
  draw(context, size2) {
    const r4 = sqrt2(size2 / a);
    const x06 = r4 / 2, y06 = r4 * k;
    const x110 = x06, y110 = r4 * k + r4;
    const x22 = -x110, y25 = y110;
    context.moveTo(x06, y06);
    context.lineTo(x110, y110);
    context.lineTo(x22, y25);
    context.lineTo(c * x06 - s * y06, s * x06 + c * y06);
    context.lineTo(c * x110 - s * y110, s * x110 + c * y110);
    context.lineTo(c * x22 - s * y25, s * x22 + c * y25);
    context.lineTo(c * x06 + s * y06, c * y06 - s * x06);
    context.lineTo(c * x110 + s * y110, c * y110 - s * x110);
    context.lineTo(c * x22 + s * y25, c * y25 - s * x22);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol.js
function Symbol2(type2, size2) {
  let context = null, path3 = withPath(symbol);
  type2 = typeof type2 === "function" ? type2 : constant_default3(type2 || circle_default);
  size2 = typeof size2 === "function" ? size2 : constant_default3(size2 === void 0 ? 64 : +size2);
  function symbol() {
    let buffer;
    if (!context) context = buffer = path3();
    type2.apply(this, arguments).draw(context, +size2.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }
  symbol.type = function(_17) {
    return arguments.length ? (type2 = typeof _17 === "function" ? _17 : constant_default3(_17), symbol) : type2;
  };
  symbol.size = function(_17) {
    return arguments.length ? (size2 = typeof _17 === "function" ? _17 : constant_default3(+_17), symbol) : size2;
  };
  symbol.context = function(_17) {
    return arguments.length ? (context = _17 == null ? null : _17, symbol) : context;
  };
  return symbol;
}

// node_modules/d3-shape/src/noop.js
function noop_default() {
}

// node_modules/d3-shape/src/curve/basis.js
function point2(that, x21, y25) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x21) / 6,
    (that._y0 + 4 * that._y1 + y25) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point2(this, this._x1, this._y1);
      // falls through
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x21, y25) : this._context.moveTo(x21, y25);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // falls through
      default:
        point2(this, x21, y25);
        break;
    }
    this._x0 = this._x1, this._x1 = x21;
    this._y0 = this._y1, this._y1 = y25;
  }
};
function basis_default2(context) {
  return new Basis(context);
}

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x21, this._y2 = y25;
        break;
      case 1:
        this._point = 2;
        this._x3 = x21, this._y3 = y25;
        break;
      case 2:
        this._point = 3;
        this._x4 = x21, this._y4 = y25;
        this._context.moveTo((this._x0 + 4 * this._x1 + x21) / 6, (this._y0 + 4 * this._y1 + y25) / 6);
        break;
      default:
        point2(this, x21, y25);
        break;
    }
    this._x0 = this._x1, this._x1 = x21;
    this._y0 = this._y1, this._y1 = y25;
  }
};
function basisClosed_default2(context) {
  return new BasisClosed(context);
}

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x06 = (this._x0 + 4 * this._x1 + x21) / 6, y06 = (this._y0 + 4 * this._y1 + y25) / 6;
        this._line ? this._context.lineTo(x06, y06) : this._context.moveTo(x06, y06);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point2(this, x21, y25);
        break;
    }
    this._x0 = this._x1, this._x1 = x21;
    this._y0 = this._y1, this._y1 = y25;
  }
};
function basisOpen_default(context) {
  return new BasisOpen(context);
}

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x21 = this._x, y25 = this._y, j6 = x21.length - 1;
    if (j6 > 0) {
      var x06 = x21[0], y06 = y25[0], dx = x21[j6] - x06, dy = y25[j6] - y06, i8 = -1, t4;
      while (++i8 <= j6) {
        t4 = i8 / j6;
        this._basis.point(
          this._beta * x21[i8] + (1 - this._beta) * (x06 + t4 * dx),
          this._beta * y25[i8] + (1 - this._beta) * (y06 + t4 * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x21, y25) {
    this._x.push(+x21);
    this._y.push(+y25);
  }
};
var bundle_default = (function custom10(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom10(+beta2);
  };
  return bundle;
})(0.85);

// node_modules/d3-shape/src/curve/cardinal.js
function point3(that, x21, y25) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x21),
    that._y2 + that._k * (that._y1 - y25),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point3(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x21, y25) : this._context.moveTo(x21, y25);
        break;
      case 1:
        this._point = 2;
        this._x1 = x21, this._y1 = y25;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        point3(this, x21, y25);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x21;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y25;
  }
};
var cardinal_default = (function custom11(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom11(+tension2);
  };
  return cardinal;
})(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x21, this._y3 = y25;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x21, this._y4 = y25);
        break;
      case 2:
        this._point = 3;
        this._x5 = x21, this._y5 = y25;
        break;
      default:
        point3(this, x21, y25);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x21;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y25;
  }
};
var cardinalClosed_default = (function custom12(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom12(+tension2);
  };
  return cardinal;
})(0);

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point3(this, x21, y25);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x21;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y25;
  }
};
var cardinalOpen_default = (function custom13(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom13(+tension2);
  };
  return cardinal;
})(0);

// node_modules/d3-shape/src/curve/catmullRom.js
function point4(that, x21, y25) {
  var x110 = that._x1, y110 = that._y1, x22 = that._x2, y26 = that._y2;
  if (that._l01_a > epsilon) {
    var a7 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x110 = (x110 * a7 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y110 = (y110 * a7 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon) {
    var b25 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m30 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b25 + that._x1 * that._l23_2a - x21 * that._l12_2a) / m30;
    y26 = (y26 * b25 + that._y1 * that._l23_2a - y25 * that._l12_2a) / m30;
  }
  that._context.bezierCurveTo(x110, y110, x22, y26, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    if (this._point) {
      var x23 = this._x2 - x21, y232 = this._y2 - y25;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y232 * y232, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x21, y25) : this._context.moveTo(x21, y25);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        point4(this, x21, y25);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x21;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y25;
  }
};
var catmullRom_default = (function custom14(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom14(+alpha2);
  };
  return catmullRom;
})(0.5);

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    if (this._point) {
      var x23 = this._x2 - x21, y232 = this._y2 - y25;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y232 * y232, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x21, this._y3 = y25;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x21, this._y4 = y25);
        break;
      case 2:
        this._point = 3;
        this._x5 = x21, this._y5 = y25;
        break;
      default:
        point4(this, x21, y25);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x21;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y25;
  }
};
var catmullRomClosed_default = (function custom15(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom15(+alpha2);
  };
  return catmullRom;
})(0.5);

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    if (this._point) {
      var x23 = this._x2 - x21, y232 = this._y2 - y25;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y232 * y232, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point4(this, x21, y25);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x21;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y25;
  }
};
var catmullRomOpen_default = (function custom16(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom16(+alpha2);
  };
  return catmullRom;
})(0.5);

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    if (this._point) this._context.lineTo(x21, y25);
    else this._point = 1, this._context.moveTo(x21, y25);
  }
};
function linearClosed_default(context) {
  return new LinearClosed(context);
}

// node_modules/d3-shape/src/curve/monotone.js
function sign(x21) {
  return x21 < 0 ? -1 : 1;
}
function slope3(that, x22, y25) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y25 - that._y1) / (h1 || h0 < 0 && -0), p13 = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p13)) || 0;
}
function slope2(that, t4) {
  var h17 = that._x1 - that._x0;
  return h17 ? (3 * (that._y1 - that._y0) / h17 - t4) / 2 : t4;
}
function point5(that, t03, t13) {
  var x06 = that._x0, y06 = that._y0, x110 = that._x1, y110 = that._y1, dx = (x110 - x06) / 3;
  that._context.bezierCurveTo(x06 + dx, y06 + dx * t03, x110 - dx, y110 - dx * t13, x110, y110);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point5(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x21, y25) {
    var t13 = NaN;
    x21 = +x21, y25 = +y25;
    if (x21 === this._x1 && y25 === this._y1) return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x21, y25) : this._context.moveTo(x21, y25);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point5(this, slope2(this, t13 = slope3(this, x21, y25)), t13);
        break;
      default:
        point5(this, this._t0, t13 = slope3(this, x21, y25));
        break;
    }
    this._x0 = this._x1, this._x1 = x21;
    this._y0 = this._y1, this._y1 = y25;
    this._t0 = t13;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x21, y25) {
  MonotoneX.prototype.point.call(this, y25, x21);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x21, y25) {
    this._context.moveTo(y25, x21);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x21, y25) {
    this._context.lineTo(y25, x21);
  },
  bezierCurveTo: function(x110, y110, x22, y25, x21, y26) {
    this._context.bezierCurveTo(y110, x110, y25, x22, y26, x21);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x21 = this._x, y25 = this._y, n = x21.length;
    if (n) {
      this._line ? this._context.lineTo(x21[0], y25[0]) : this._context.moveTo(x21[0], y25[0]);
      if (n === 2) {
        this._context.lineTo(x21[1], y25[1]);
      } else {
        var px = controlPoints(x21), py = controlPoints(y25);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x21[i1], y25[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x21, y25) {
    this._x.push(+x21);
    this._y.push(+y25);
  }
};
function controlPoints(x21) {
  var i8, n = x21.length - 1, m30, a7 = new Array(n), b25 = new Array(n), r4 = new Array(n);
  a7[0] = 0, b25[0] = 2, r4[0] = x21[0] + 2 * x21[1];
  for (i8 = 1; i8 < n - 1; ++i8) a7[i8] = 1, b25[i8] = 4, r4[i8] = 4 * x21[i8] + 2 * x21[i8 + 1];
  a7[n - 1] = 2, b25[n - 1] = 7, r4[n - 1] = 8 * x21[n - 1] + x21[n];
  for (i8 = 1; i8 < n; ++i8) m30 = a7[i8] / b25[i8 - 1], b25[i8] -= m30, r4[i8] -= m30 * r4[i8 - 1];
  a7[n - 1] = r4[n - 1] / b25[n - 1];
  for (i8 = n - 2; i8 >= 0; --i8) a7[i8] = (r4[i8] - a7[i8 + 1]) / b25[i8];
  b25[n - 1] = (x21[n] + a7[n - 1]) / 2;
  for (i8 = 0; i8 < n - 1; ++i8) b25[i8] = 2 * x21[i8 + 1] - a7[i8 + 1];
  return [a7, b25];
}
function natural_default(context) {
  return new Natural(context);
}

// node_modules/d3-shape/src/curve/step.js
function Step(context, t4) {
  this._context = context;
  this._t = t4;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x21, y25) : this._context.moveTo(x21, y25);
        break;
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y25);
          this._context.lineTo(x21, y25);
        } else {
          var x110 = this._x * (1 - this._t) + x21 * this._t;
          this._context.lineTo(x110, this._y);
          this._context.lineTo(x110, y25);
        }
        break;
      }
    }
    this._x = x21, this._y = y25;
  }
};
function step_default(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}

// node_modules/d3-interpolate-path/build/d3-interpolate-path.mjs
function ownKeys(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols2);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i8 = 1; i8 < arguments.length; i8++) {
    var source = arguments[i8] != null ? arguments[i8] : {};
    if (i8 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i8 = 1; i8 < arguments.length; i8++) {
      var source = arguments[i8];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
  var n = Object.prototype.toString.call(o2).slice(8, -1);
  if (n === "Object" && o2.constructor) n = o2.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o2);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i8 = 0, arr2 = new Array(len); i8 < len; i8++) arr2[i8] = arr[i8];
  return arr2;
}
function _createForOfIteratorHelper(o2, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
  if (!it) {
    if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it) o2 = it;
      var i8 = 0;
      var F12 = function() {
      };
      return {
        s: F12,
        n: function() {
          if (i8 >= o2.length) return {
            done: true
          };
          return {
            done: false,
            value: o2[i8++]
          };
        },
        e: function(e3) {
          throw e3;
        },
        f: F12
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function() {
      it = it.call(o2);
    },
    n: function() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function(e3) {
      didErr = true;
      err = e3;
    },
    f: function() {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function decasteljau(points3, t4) {
  var left3 = [];
  var right3 = [];
  function decasteljauRecurse(points4, t5) {
    if (points4.length === 1) {
      left3.push(points4[0]);
      right3.push(points4[0]);
    } else {
      var newPoints = Array(points4.length - 1);
      for (var i8 = 0; i8 < newPoints.length; i8++) {
        if (i8 === 0) {
          left3.push(points4[0]);
        }
        if (i8 === newPoints.length - 1) {
          right3.push(points4[i8 + 1]);
        }
        newPoints[i8] = [(1 - t5) * points4[i8][0] + t5 * points4[i8 + 1][0], (1 - t5) * points4[i8][1] + t5 * points4[i8 + 1][1]];
      }
      decasteljauRecurse(newPoints, t5);
    }
  }
  if (points3.length) {
    decasteljauRecurse(points3, t4);
  }
  return {
    left: left3,
    right: right3.reverse()
  };
}
function pointsToCommand(points3) {
  var command = {};
  if (points3.length === 4) {
    command.x2 = points3[2][0];
    command.y2 = points3[2][1];
  }
  if (points3.length >= 3) {
    command.x1 = points3[1][0];
    command.y1 = points3[1][1];
  }
  command.x = points3[points3.length - 1][0];
  command.y = points3[points3.length - 1][1];
  if (points3.length === 4) {
    command.type = "C";
  } else if (points3.length === 3) {
    command.type = "Q";
  } else {
    command.type = "L";
  }
  return command;
}
function splitCurveAsPoints(points3, segmentCount) {
  segmentCount = segmentCount || 2;
  var segments = [];
  var remainingCurve = points3;
  var tIncrement = 1 / segmentCount;
  for (var i8 = 0; i8 < segmentCount - 1; i8++) {
    var tRelative = tIncrement / (1 - tIncrement * i8);
    var split = decasteljau(remainingCurve, tRelative);
    segments.push(split.left);
    remainingCurve = split.right;
  }
  segments.push(remainingCurve);
  return segments;
}
function splitCurve(commandStart, commandEnd, segmentCount) {
  var points3 = [[commandStart.x, commandStart.y]];
  if (commandEnd.x1 != null) {
    points3.push([commandEnd.x1, commandEnd.y1]);
  }
  if (commandEnd.x2 != null) {
    points3.push([commandEnd.x2, commandEnd.y2]);
  }
  points3.push([commandEnd.x, commandEnd.y]);
  return splitCurveAsPoints(points3, segmentCount).map(pointsToCommand);
}
var commandTokenRegex = /[MLCSTQAHVZmlcstqahv]|-?[\d.e+-]+/g;
var typeMap = {
  M: ["x", "y"],
  L: ["x", "y"],
  H: ["x"],
  V: ["y"],
  C: ["x1", "y1", "x2", "y2", "x", "y"],
  S: ["x2", "y2", "x", "y"],
  Q: ["x1", "y1", "x", "y"],
  T: ["x", "y"],
  A: ["rx", "ry", "xAxisRotation", "largeArcFlag", "sweepFlag", "x", "y"],
  Z: []
};
Object.keys(typeMap).forEach(function(key) {
  typeMap[key.toLowerCase()] = typeMap[key];
});
function arrayOfLength(length, value2) {
  var array3 = Array(length);
  for (var i8 = 0; i8 < length; i8++) {
    array3[i8] = value2;
  }
  return array3;
}
function commandToString(command) {
  return "".concat(command.type).concat(typeMap[command.type].map(function(p13) {
    return command[p13];
  }).join(","));
}
function convertToSameType(aCommand, bCommand) {
  var conversionMap = {
    x1: "x",
    y1: "y",
    x2: "x",
    y2: "y"
  };
  var readFromBKeys = ["xAxisRotation", "largeArcFlag", "sweepFlag"];
  if (aCommand.type !== bCommand.type && bCommand.type.toUpperCase() !== "M") {
    var aConverted = {};
    Object.keys(bCommand).forEach(function(bKey) {
      var bValue = bCommand[bKey];
      var aValue = aCommand[bKey];
      if (aValue === void 0) {
        if (readFromBKeys.includes(bKey)) {
          aValue = bValue;
        } else {
          if (aValue === void 0 && conversionMap[bKey]) {
            aValue = aCommand[conversionMap[bKey]];
          }
          if (aValue === void 0) {
            aValue = 0;
          }
        }
      }
      aConverted[bKey] = aValue;
    });
    aConverted.type = bCommand.type;
    aCommand = aConverted;
  }
  return aCommand;
}
function splitSegment(commandStart, commandEnd, segmentCount) {
  var segments = [];
  if (commandEnd.type === "L" || commandEnd.type === "Q" || commandEnd.type === "C") {
    segments = segments.concat(splitCurve(commandStart, commandEnd, segmentCount));
  } else {
    var copyCommand = _extends({}, commandStart);
    if (copyCommand.type === "M") {
      copyCommand.type = "L";
    }
    segments = segments.concat(arrayOfLength(segmentCount - 1).map(function() {
      return copyCommand;
    }));
    segments.push(commandEnd);
  }
  return segments;
}
function extend2(commandsToExtend, referenceCommands, excludeSegment) {
  var numSegmentsToExtend = commandsToExtend.length - 1;
  var numReferenceSegments = referenceCommands.length - 1;
  var segmentRatio = numSegmentsToExtend / numReferenceSegments;
  var countPointsPerSegment = arrayOfLength(numReferenceSegments).reduce(function(accum, d18, i8) {
    var insertIndex = Math.floor(segmentRatio * i8);
    if (excludeSegment && insertIndex < commandsToExtend.length - 1 && excludeSegment(commandsToExtend[insertIndex], commandsToExtend[insertIndex + 1])) {
      var addToPriorSegment = segmentRatio * i8 % 1 < 0.5;
      if (accum[insertIndex]) {
        if (addToPriorSegment) {
          if (insertIndex > 0) {
            insertIndex -= 1;
          } else if (insertIndex < commandsToExtend.length - 1) {
            insertIndex += 1;
          }
        } else if (insertIndex < commandsToExtend.length - 1) {
          insertIndex += 1;
        } else if (insertIndex > 0) {
          insertIndex -= 1;
        }
      }
    }
    accum[insertIndex] = (accum[insertIndex] || 0) + 1;
    return accum;
  }, []);
  var extended = countPointsPerSegment.reduce(function(extended2, segmentCount, i8) {
    if (i8 === commandsToExtend.length - 1) {
      var lastCommandCopies = arrayOfLength(segmentCount, _extends({}, commandsToExtend[commandsToExtend.length - 1]));
      if (lastCommandCopies[0].type === "M") {
        lastCommandCopies.forEach(function(d18) {
          d18.type = "L";
        });
      }
      return extended2.concat(lastCommandCopies);
    }
    return extended2.concat(splitSegment(commandsToExtend[i8], commandsToExtend[i8 + 1], segmentCount));
  }, []);
  extended.unshift(commandsToExtend[0]);
  return extended;
}
function pathCommandsFromString(d18) {
  var tokens = (d18 || "").match(commandTokenRegex) || [];
  var commands = [];
  var commandArgs;
  var command;
  for (var i8 = 0; i8 < tokens.length; ++i8) {
    commandArgs = typeMap[tokens[i8]];
    if (commandArgs) {
      command = {
        type: tokens[i8]
      };
      for (var a7 = 0; a7 < commandArgs.length; ++a7) {
        command[commandArgs[a7]] = +tokens[i8 + a7 + 1];
      }
      i8 += commandArgs.length;
      commands.push(command);
    }
  }
  return commands;
}
function interpolatePathCommands(aCommandsInput, bCommandsInput, interpolateOptions) {
  var aCommands = aCommandsInput == null ? [] : aCommandsInput.slice();
  var bCommands = bCommandsInput == null ? [] : bCommandsInput.slice();
  var _ref = _typeof(interpolateOptions) === "object" ? interpolateOptions : {
    excludeSegment: interpolateOptions,
    snapEndsToInput: true
  }, excludeSegment = _ref.excludeSegment, snapEndsToInput = _ref.snapEndsToInput;
  if (!aCommands.length && !bCommands.length) {
    return function nullInterpolator() {
      return [];
    };
  }
  var addZ = (aCommands.length === 0 || aCommands[aCommands.length - 1].type === "Z") && (bCommands.length === 0 || bCommands[bCommands.length - 1].type === "Z");
  if (aCommands.length > 0 && aCommands[aCommands.length - 1].type === "Z") {
    aCommands.pop();
  }
  if (bCommands.length > 0 && bCommands[bCommands.length - 1].type === "Z") {
    bCommands.pop();
  }
  if (!aCommands.length) {
    aCommands.push(bCommands[0]);
  } else if (!bCommands.length) {
    bCommands.push(aCommands[0]);
  }
  var numPointsToExtend = Math.abs(bCommands.length - aCommands.length);
  if (numPointsToExtend !== 0) {
    if (bCommands.length > aCommands.length) {
      aCommands = extend2(aCommands, bCommands, excludeSegment);
    } else if (bCommands.length < aCommands.length) {
      bCommands = extend2(bCommands, aCommands, excludeSegment);
    }
  }
  aCommands = aCommands.map(function(aCommand, i8) {
    return convertToSameType(aCommand, bCommands[i8]);
  });
  var interpolatedCommands = aCommands.map(function(aCommand) {
    return _objectSpread2({}, aCommand);
  });
  if (addZ) {
    interpolatedCommands.push({
      type: "Z"
    });
    aCommands.push({
      type: "Z"
    });
  }
  return function pathCommandInterpolator(t4) {
    if (t4 === 1 && snapEndsToInput) {
      return bCommandsInput == null ? [] : bCommandsInput;
    }
    if (t4 === 0) {
      return aCommands;
    }
    for (var i8 = 0; i8 < interpolatedCommands.length; ++i8) {
      var aCommand = aCommands[i8];
      var bCommand = bCommands[i8];
      var interpolatedCommand = interpolatedCommands[i8];
      var _iterator = _createForOfIteratorHelper(typeMap[interpolatedCommand.type]), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var arg = _step.value;
          interpolatedCommand[arg] = (1 - t4) * aCommand[arg] + t4 * bCommand[arg];
          if (arg === "largeArcFlag" || arg === "sweepFlag") {
            interpolatedCommand[arg] = Math.round(interpolatedCommand[arg]);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    return interpolatedCommands;
  };
}
function interpolatePath(a7, b25, interpolateOptions) {
  var aCommands = pathCommandsFromString(a7);
  var bCommands = pathCommandsFromString(b25);
  var _ref2 = _typeof(interpolateOptions) === "object" ? interpolateOptions : {
    excludeSegment: interpolateOptions,
    snapEndsToInput: true
  }, excludeSegment = _ref2.excludeSegment, snapEndsToInput = _ref2.snapEndsToInput;
  if (!aCommands.length && !bCommands.length) {
    return function nullInterpolator() {
      return "";
    };
  }
  var commandInterpolator = interpolatePathCommands(aCommands, bCommands, {
    excludeSegment,
    snapEndsToInput
  });
  return function pathStringInterpolator(t4) {
    if (t4 === 1 && snapEndsToInput) {
      return b25 == null ? "" : b25;
    }
    var interpolatedCommands = commandInterpolator(t4);
    var interpolatedString = "";
    var _iterator2 = _createForOfIteratorHelper(interpolatedCommands), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var interpolatedCommand = _step2.value;
        interpolatedString += commandToString(interpolatedCommand);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return interpolatedString;
  };
}

// node_modules/@unovis/ts/utils/color.js
function getColor(d18, accessor, index3, dontFallbackToCssVar) {
  if (Array.isArray(accessor) && isFinite(index3))
    return accessor[index3 % accessor.length];
  const value2 = getString(d18, accessor, index3);
  return value2 || (isNumber(index3) && !dontFallbackToCssVar ? `var(${getCSSColorVariable(index3)})` : null);
}
function hexToRgb(hex2) {
  const parsed = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex2);
  return parsed ? {
    r: parseInt(parsed[1], 16),
    g: parseInt(parsed[2], 16),
    b: parseInt(parsed[3], 16)
  } : { r: 0, g: 0, b: 0 };
}
function rgbToBrightness(rgb2) {
  return (0.2126 * rgb2.r + 0.7152 * rgb2.g + 0.0722 * rgb2.b) / 255;
}
function hexToBrightness(hex2) {
  const rgb2 = hexToRgb(hex2);
  return rgbToBrightness(rgb2);
}
function getHexValue(s12, context) {
  var _a;
  const hex2 = isStringCSSVariable(s12) ? getCSSVariableValue(s12, context) : s12;
  return (_a = color(hex2)) === null || _a === void 0 ? void 0 : _a.formatHex();
}
function rgbaToRgb(rgba2, backgroundColor) {
  var _a;
  const rgb2 = (_a = color(rgba2)) === null || _a === void 0 ? void 0 : _a.rgb();
  if (!rgb2 || rgb2.opacity === 1)
    return rgb2;
  const alpha = 1 - rgb2.opacity;
  const bg = color(backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : "#fff").rgb();
  return {
    r: Math.round((rgb2.opacity * (rgb2.r / 255) + alpha * (bg.r / 255)) * 255),
    g: Math.round((rgb2.opacity * (rgb2.g / 255) + alpha * (bg.g / 255)) * 255),
    b: Math.round((rgb2.opacity * (rgb2.b / 255) + alpha * (bg.b / 255)) * 255)
  };
}
function brighter2(inputColor, amount) {
  const c6 = hcl(inputColor);
  if (!c6)
    return inputColor;
  return c6.brighter(amount).formatHex();
}

// node_modules/@unovis/ts/types/curve.js
var CurveType;
(function(CurveType2) {
  CurveType2["Basis"] = "basis";
  CurveType2["BasisClosed"] = "basisClosed";
  CurveType2["BasisOpen"] = "basisOpen";
  CurveType2["Bundle"] = "bundle";
  CurveType2["Cardinal"] = "cardinal";
  CurveType2["CardinalClosed"] = "cardinalClosed";
  CurveType2["CardinalOpen"] = "cardinalOpen";
  CurveType2["CatmullRom"] = "catmullRom";
  CurveType2["CatmullRomClosed"] = "catmullRomClosed";
  CurveType2["CatmullRomOpen"] = "catmullRomOpen";
  CurveType2["Linear"] = "linear";
  CurveType2["LinearClosed"] = "linearClosed";
  CurveType2["MonotoneX"] = "monotoneX";
  CurveType2["MonotoneY"] = "monotoneY";
  CurveType2["Natural"] = "natural";
  CurveType2["Step"] = "step";
  CurveType2["StepAfter"] = "stepAfter";
  CurveType2["StepBefore"] = "stepBefore";
})(CurveType || (CurveType = {}));
var Curve = {
  [CurveType.Basis]: basis_default2,
  [CurveType.BasisClosed]: basisClosed_default2,
  [CurveType.BasisOpen]: basisOpen_default,
  [CurveType.Bundle]: bundle_default,
  [CurveType.Cardinal]: cardinal_default,
  [CurveType.CardinalClosed]: cardinalClosed_default,
  [CurveType.CardinalOpen]: cardinalOpen_default,
  [CurveType.CatmullRom]: catmullRom_default,
  [CurveType.CatmullRomClosed]: catmullRomClosed_default,
  [CurveType.CatmullRomOpen]: catmullRomOpen_default,
  [CurveType.Linear]: linear_default,
  [CurveType.LinearClosed]: linearClosed_default,
  [CurveType.MonotoneX]: monotoneX,
  [CurveType.MonotoneY]: monotoneY,
  [CurveType.Natural]: natural_default,
  [CurveType.Step]: step_default,
  [CurveType.StepAfter]: stepAfter,
  [CurveType.StepBefore]: stepBefore
};

// node_modules/@unovis/ts/components/line/config.js
var LineDefaultConfig = Object.assign(Object.assign({}, XYComponentDefaultConfig), { curveType: CurveType.MonotoneX, lineWidth: 2, lineDashArray: void 0, fallbackValue: void 0, highlightOnHover: false, cursor: null, interpolateMissingData: false });

// node_modules/@unovis/ts/components/line/style.js
var style_exports2 = {};
__export(style_exports2, {
  dim: () => dim,
  globalStyles: () => globalStyles,
  interpolatedPath: () => interpolatedPath,
  line: () => line,
  linePath: () => linePath,
  lineSelectionHelper: () => lineSelectionHelper,
  root: () => root3
});
var globalStyles = injectGlobal`
  :root {
    --vis-line-cursor: default;
    --vis-line-stroke-dasharray: none;
    --vis-line-stroke-dashoffset: 0;

    --vis-line-gapfill-stroke-dasharray: 2 3;
    --vis-line-gapfill-stroke-opacity: 0.8;
    --vis-line-gapfill-stroke-dashoffset: 0;
  }
`;
var root3 = css`
  label: line-component;
`;
var line = css`
  label: line;
  transition: opacity 200ms;
  cursor: var(--vis-line-cursor);
`;
var linePath = css`
  label: linePath;
  fill: none;
  stroke-dasharray: var(--vis-line-stroke-dasharray);
  stroke-dashoffset: var(--vis-line-stroke-dashoffset);
`;
var lineSelectionHelper = css`
  label: lineSelectionHelper;
  fill: none;
  stroke: rgba(0, 0, 0, 0);
  stroke-width: 8px;
`;
var dim = css`
  opacity: 0.2;
`;
var interpolatedPath = css`
  label: interpolated-path;
  fill: none;
  stroke-dasharray: var(--vis-line-gapfill-stroke-dasharray);
  stroke-dashoffset: var(--vis-line-gapfill-stroke-dashoffset);
  stroke-opacity: var(--vis-line-gapfill-stroke-opacity);
`;

// node_modules/@unovis/ts/components/line/index.js
var Line = class _Line extends XYComponentCore {
  constructor(config) {
    super();
    this._defaultConfig = LineDefaultConfig;
    this.config = this._defaultConfig;
    this.curve = Curve[CurveType.MonotoneX];
    this.events = {
      [_Line.selectors.line]: {
        mouseover: this._highlight.bind(this),
        mouseleave: this._resetHighlight.bind(this)
      }
    };
    if (config)
      this.setConfig(config);
  }
  get bleed() {
    const { config: { lineWidth } } = this;
    const yDomain = this.yScale.domain();
    const yDirection = this.yScale.range()[0] > this.yScale.range()[1] ? Direction.North : Direction.South;
    const isYDirectionSouth = yDirection === Direction.South;
    const isLineThick = lineWidth > 3;
    const isLineVeryThick = lineWidth >= 10;
    return {
      top: !isLineVeryThick && (!isYDirectionSouth && yDomain[1] === 0 || isYDirectionSouth && yDomain[0] === 0) ? 0 : lineWidth / 2,
      bottom: !isLineVeryThick && (!isYDirectionSouth && yDomain[0] === 0 || isYDirectionSouth && yDomain[1] === 0) ? 0 : lineWidth / 2,
      left: isLineThick ? lineWidth / 2 : 0,
      right: isLineThick ? lineWidth / 2 : 0
    };
  }
  _render(customDuration) {
    super._render(customDuration);
    const { config, datamodel: { data } } = this;
    const duration = isNumber(customDuration) ? customDuration : config.duration;
    this.curve = Curve[config.curveType];
    this.lineGen = line_default().x((d18) => d18.x).y((d18) => d18.y).defined((d18) => d18.defined).curve(this.curve);
    const yAccessors = isArray(config.y) ? config.y : [config.y];
    const lineDataX = data.map((d18, i8) => this.xScale(getNumber(d18, config.x, i8)));
    const lineData = yAccessors.map((a7) => {
      const ld = data.map((d18, i8) => {
        const rawValue = getNumber(d18, a7, i8);
        const value2 = (isNumber(rawValue) || rawValue === null) && isFinite(rawValue) ? rawValue : config.fallbackValue;
        const defined2 = config.interpolateMissingData ? (isNumber(rawValue) || rawValue === null) && isFinite(rawValue) : isFinite(value2);
        return {
          x: lineDataX[i8],
          y: this.yScale(value2 !== null && value2 !== void 0 ? value2 : 0),
          defined: defined2,
          value: value2
        };
      });
      const defined = ld.reduce((def, d18) => d18.defined || def, false);
      let validGap = false;
      const gaps = ld.reduce((acc, d18, i8) => {
        if (!d18.defined && isFinite(config.fallbackValue)) {
          acc.push(Object.assign(Object.assign({}, d18), { defined: true }));
        }
        if (!d18.defined && !validGap)
          validGap = true;
        const isEndpoint = i8 > 0 && !ld[i8 - 1].defined || i8 < ld.length - 1 && !ld[i8 + 1].defined;
        if (d18.defined && isEndpoint) {
          if (!validGap)
            acc.push(Object.assign(Object.assign({}, d18), { defined: false }));
          acc.push(d18);
          validGap = false;
        }
        return acc;
      }, []);
      const visible = defined && ld.some((d18) => d18.value !== null);
      return {
        values: ld,
        defined,
        gaps,
        visible
      };
    });
    const lines3 = this.g.selectAll(`.${line}`).data(lineData);
    const linesEnter = lines3.enter().append("g").attr("class", line);
    linesEnter.append("path").attr("class", linePath).attr("stroke", (d18, i8) => getColor(data, config.color, i8)).attr("stroke-opacity", 0).attr("stroke-width", config.lineWidth);
    linesEnter.append("path").attr("class", lineSelectionHelper).attr("d", this._emptyPath());
    linesEnter.append("path").attr("class", interpolatedPath).attr("d", this._emptyPath()).style("opacity", 0);
    const linesMerged = linesEnter.merge(lines3);
    linesMerged.style("cursor", (d18, i8) => getString(data, config.cursor, i8));
    linesMerged.each((d18, i8, elements) => {
      var _a;
      const group3 = select_default2(elements[i8]);
      const linePath$1 = group3.select(`.${linePath}`);
      const lineSelectionHelper$1 = group3.select(`.${lineSelectionHelper}`);
      const lineGaps = group3.select(`.${interpolatedPath}`);
      const isLineVisible = d18.visible;
      const dashArray = getValue(data, config.lineDashArray, i8);
      const transition2 = smartTransition(linePath$1, duration).attr("stroke", getColor(data, config.color, i8)).attr("stroke-width", config.lineWidth).attr("stroke-opacity", isLineVisible ? 1 : 0).style("stroke-dasharray", (_a = dashArray === null || dashArray === void 0 ? void 0 : dashArray.join(" ")) !== null && _a !== void 0 ? _a : null);
      const hasUndefinedSegments = d18.values.some((d19) => !d19.defined);
      const svgPathD = this.lineGen(d18.values);
      if (duration && !hasUndefinedSegments) {
        const previous = linePath$1.attr("d") || this._emptyPath();
        const next = svgPathD || this._emptyPath();
        const t4 = transition2;
        t4.attrTween("d", () => interpolatePath(previous, next));
      } else if (d18.visible) {
        transition2.attr("d", svgPathD);
      }
      lineSelectionHelper$1.attr("d", svgPathD).attr("visibility", isLineVisible ? null : "hidden");
      if (hasUndefinedSegments && config.interpolateMissingData) {
        smartTransition(lineGaps, duration).attr("d", this.lineGen(d18.gaps)).attr("stroke", getColor(data, config.color, i8)).attr("stroke-width", config.lineWidth - 1).style("opacity", 1);
      } else {
        lineGaps.transition().duration(duration).style("opacity", 0);
      }
    });
    smartTransition(lines3.exit(), duration).style("opacity", 0).remove();
  }
  _emptyPath() {
    const xRange = this.xScale.range();
    const yRange = this.yScale.range();
    return `M${xRange[0]},${yRange[0]} L${xRange[1]},${yRange[0]}`;
  }
  _highlight(datum2) {
    const { config } = this;
    if (config.highlightOnHover) {
      this.g.selectAll(`.${line}`).classed(dim, (d18) => d18 !== datum2);
    }
  }
  _resetHighlight() {
    const { config } = this;
    if (config.highlightOnHover) {
      this.g.selectAll(`.${line}`).classed(dim, false);
    }
  }
};
Line.selectors = style_exports2;

// node_modules/@unovis/ts/utils/path.js
function roundedRectPath({ x: x21, y: y25, w: w14, h: h17, tl = false, tr = false, bl = false, br = false, r: r4 = 0 }) {
  let path3;
  path3 = `M${x21 + r4},${y25}h${w14 - 2 * r4}`;
  let roundedR = tr ? r4 : 0;
  let angularR = tr ? 0 : r4;
  path3 += `a${roundedR},${roundedR} 0 0 1 ${roundedR},${roundedR}`;
  path3 += `h${angularR}v${angularR}`;
  path3 += `v${h17 - 2 * r4}`;
  roundedR = br ? r4 : 0;
  angularR = br ? 0 : r4;
  path3 += `a${roundedR},${roundedR} 0 0 1 ${-roundedR},${roundedR}`;
  path3 += `v${angularR}h${-angularR}`;
  path3 += `h${2 * r4 - w14}`;
  roundedR = bl ? r4 : 0;
  angularR = bl ? 0 : r4;
  path3 += `a${roundedR},${roundedR} 0 0 1 ${-roundedR},${-roundedR}`;
  path3 += `h${-angularR}v${-angularR}`;
  path3 += `v${2 * r4 - h17}`;
  roundedR = tl ? r4 : 0;
  angularR = tl ? 0 : r4;
  path3 += `a${roundedR},${roundedR} 0 0 1 ${roundedR},${-roundedR}`;
  path3 += `v${-angularR}h${angularR}`;
  path3 += "z";
  return path3;
}
function polygon(size2, n = 6, endAngle = 2 * Math.PI, open = false) {
  const r4 = n === 4 ? Math.sqrt(0.5) * size2 : size2 / 3.6 * 2;
  const deltaAngle = n === 4 ? Math.PI / 4 : 0;
  const shiftedEndAngle = endAngle - deltaAngle;
  const completion = (shiftedEndAngle < 0 ? endAngle : shiftedEndAngle) / (2 * Math.PI);
  const nSegments = Math.ceil(n * completion);
  const centerAngle = 1 / n * Math.PI * 2;
  const baseAngle = (Math.PI - centerAngle) / 2;
  const data = range(nSegments + (shiftedEndAngle >= 0 ? 1 : 0)).map((d18, i8) => {
    const isLastSegment = i8 === nSegments || nSegments === 1 && shiftedEndAngle < 0;
    let mult = isLastSegment ? completion * n % 1 || 1 : 1;
    if (shiftedEndAngle < 0) {
      mult += 0.5;
    }
    const angle = centerAngle * (i8 - 1 + mult);
    let radius;
    if (isLastSegment) {
      const thirdAngle = Math.PI - baseAngle - centerAngle * mult;
      radius = r4 * Math.sin(baseAngle) / Math.sin(thirdAngle);
    } else {
      radius = r4;
    }
    return {
      x: Math.sin(angle + deltaAngle) * radius,
      y: -Math.cos(angle + deltaAngle) * radius
    };
  });
  if (n === 4) {
    const angle = centerAngle * (-1 + 0.5);
    const thirdAngle = Math.PI * 0.5;
    const radius = r4 * Math.sin(baseAngle) / Math.sin(thirdAngle);
    data.unshift({
      x: Math.sin(angle + deltaAngle) * radius,
      y: -Math.cos(angle + deltaAngle) * radius
    });
  }
  const path3 = line_default().x((d18) => d18["x"]).y((d18) => d18["y"]).curve((open ? cardinal_default : cardinalClosed_default).tension(0.95));
  return path3(data);
}
function circlePath(cx, cy, r4) {
  return `
    M ${cx} ${cy}
    m ${-r4}, 0
    a ${r4},${r4} 0 1,1 ${r4 * 2},0
    a ${r4},${r4} 0 1,1 ${-r4 * 2},0`;
}
function scoreRectPath({ x: x21, y: y25, w: w14, h: h17, r: r4 = 0, score: score2 = 1 }) {
  let path3;
  const side = 1 / 4;
  const halfSide = side / 2;
  let part = score2;
  const hLength = min([w14 * 0.5 * (part / halfSide) + r4, w14 * 0.5 - r4]);
  path3 = `M${x21 + w14 * 0.5},${y25}h${hLength}`;
  part = score2 - 1 / 8;
  if (part > 0) {
    path3 += `a${r4},${r4} 0 0 1 ${r4},${r4}`;
    const vLength = clamp(h17 * (part / side) - r4, 0, h17 - 2 * r4);
    path3 += `v${vLength}`;
  }
  part = score2 - 3 / 8;
  if (part > 0) {
    path3 += `a${r4},${r4} 0 0 1 ${-r4},${r4}`;
    const hLength2 = clamp(r4 - w14 * (part / side), 2 * r4 - w14, 0);
    path3 += `h${hLength2}`;
  }
  part = score2 - 5 / 8;
  if (part > 0) {
    path3 += `a${r4},${r4} 0 0 1 ${-r4},${-r4}`;
    const vLength = clamp(r4 - h17 * (part / side), 2 * r4 - h17, 0);
    path3 += `v${vLength}`;
  }
  part = score2 - 7 / 8;
  if (part > 0) {
    path3 += `a${r4},${r4} 0 0 1 ${r4},${-r4}`;
    const hLength2 = max([w14 * 0.5 * (part / halfSide) - r4, 0]);
    path3 += `h${hLength2}`;
  }
  return path3;
}
function convertLineToArc(path3, r4) {
  return path3.toString().replace(/L(?<x>-?\d*\.?\d*),(?<y>-?\d+\.?\d*)/gm, (_17, x21, y25) => `A ${r4} ${r4} 0 0 0 ${x21} ${y25}`);
}
function arrowPolylinePath(points3, arrowHeadLength = 8, arrowHeadWidth = 6, smoothing = 5) {
  if (points3.length < 2)
    return "";
  let totalLength = 0;
  for (let i8 = 0; i8 < points3.length - 1; i8++) {
    const [x110, y110] = points3[i8];
    const [x22, y25] = points3[i8 + 1];
    totalLength += Math.sqrt(Math.pow(x22 - x110, 2) + Math.pow(y25 - y110, 2));
  }
  if (totalLength === 0)
    return "";
  let headLength = arrowHeadLength;
  let headWidth = arrowHeadWidth;
  const threshold2 = arrowHeadLength * 2;
  if (totalLength < threshold2) {
    const scale = totalLength / threshold2;
    headLength *= scale;
    headWidth *= scale;
  }
  headLength = Math.min(headLength / 2, totalLength);
  const [lastX, lastY] = points3[points3.length - 1];
  const [prevX, prevY] = points3[points3.length - 2];
  const dx = lastX - prevX;
  const dy = lastY - prevY;
  const segmentLength = Math.sqrt(dx * dx + dy * dy);
  const ux = dx / segmentLength;
  const uy = dy / segmentLength;
  const tailX = lastX - headLength * ux;
  const tailY = lastY - headLength * uy;
  const perpX = -uy;
  const perpY = ux;
  const leftX = tailX + headWidth / 2 * perpX;
  const leftY = tailY + headWidth / 2 * perpY;
  const rightX = tailX - headWidth / 2 * perpX;
  const rightY = tailY - headWidth / 2 * perpY;
  const pathParts = [];
  if (points3.length === 2) {
    const [startX, startY] = points3[0];
    const adjustedSmoothing = Math.min(smoothing, segmentLength / 3);
    const cp1x = startX + ux * adjustedSmoothing;
    const cp1y = startY + uy * adjustedSmoothing + perpY * adjustedSmoothing * 0.5;
    const cp2x = tailX - ux * adjustedSmoothing;
    const cp2y = tailY - uy * adjustedSmoothing + perpY * adjustedSmoothing * 0.5;
    pathParts.push(`M${startX},${startY}`);
    pathParts.push(`C${cp1x},${cp1y} ${cp2x},${cp2y} ${lastX},${lastY}`);
  } else {
    pathParts.push(`M${points3[0][0]},${points3[0][1]}`);
    for (let i8 = 0; i8 < points3.length - 2; i8++) {
      const [x110, y110] = points3[i8];
      const [x22, y25] = points3[i8 + 1];
      const [x32, y32] = points3[i8 + 2];
      const v1x = x22 - x110;
      const v1y = y25 - y110;
      const v2x = x32 - x22;
      const v2y = y32 - y25;
      const len1 = Math.sqrt(v1x * v1x + v1y * v1y);
      const len2 = Math.sqrt(v2x * v2x + v2y * v2y);
      const u1x = v1x / len1;
      const u1y = v1y / len1;
      const u2x = v2x / len2;
      const u2y = v2y / len2;
      const minSegmentLength = Math.min(len1, len2);
      const adjustedSmoothing = Math.min(smoothing, minSegmentLength / 3);
      const corner1x = x22 - u1x * adjustedSmoothing;
      const corner1y = y25 - u1y * adjustedSmoothing;
      const corner2x = x22 + u2x * adjustedSmoothing;
      const corner2y = y25 + u2y * adjustedSmoothing;
      pathParts.push(`L${corner1x},${corner1y}`);
      pathParts.push(`C${x22},${y25} ${x22},${y25} ${corner2x},${corner2y}`);
    }
    pathParts.push(`L${lastX},${lastY}`);
  }
  pathParts.push(`M${leftX},${leftY} L${lastX},${lastY} L${rightX},${rightY}`);
  return pathParts.join(" ");
}

// node_modules/@unovis/ts/components/stacked-bar/config.js
var StackedBarDefaultConfig = Object.assign(Object.assign({}, XYComponentDefaultConfig), { color: void 0, barMaxWidth: void 0, barWidth: void 0, dataStep: void 0, barPadding: 0, roundedCorners: 2, cursor: null, barMinHeight1Px: false, barMinHeightZeroValue: null, orientation: Orientation.Vertical });

// node_modules/@unovis/ts/components/stacked-bar/style.js
var style_exports3 = {};
__export(style_exports3, {
  bar: () => bar,
  barGroup: () => barGroup,
  barGroupExit: () => barGroupExit,
  globalStyles: () => globalStyles2,
  root: () => root4
});
var root4 = css`
  label: stacked-bar-component;
`;
var globalStyles2 = injectGlobal`
  :root {
    --vis-stacked-bar-cursor: default;
    --vis-stacked-bar-fill-color: var(--vis-color-main);
    --vis-stacked-bar-stroke-color: none;
    --vis-stacked-bar-stroke-width: 0px;
    --vis-stacked-bar-hover-stroke-width: none;
    --vis-stacked-bar-hover-stroke-color: none;

    /* Dark Theme */
    --vis-dark-stacked-bar-stroke-color: none;
  }

  body.theme-dark ${`.${root4}`} {
    --vis-stacked-bar-stroke-color: var(--vis-dark-stacked-bar-stroke-color);
  }
`;
var bar = css`
  label: bar;
  fill: var(--vis-stacked-bar-fill-color);
  stroke: var(--vis-stacked-bar-stroke-color);
  stroke-width: var(--vis-stacked-bar-stroke-width);
  cursor: var(--vis-stacked-bar-cursor);

  &:hover {
    stroke-width: var(--vis-stacked-bar-hover-stroke-width);
    stroke: var(--vis-stacked-bar-hover-stroke-color);
  }
`;
var barGroup = css`
  label: barGroup;
`;
var barGroupExit = css`
  label: barGroupExit;
`;

// node_modules/@unovis/ts/components/stacked-bar/index.js
var StackedBar = class extends XYComponentCore {
  constructor(config) {
    super();
    this._defaultConfig = StackedBarDefaultConfig;
    this.config = this._defaultConfig;
    this.getAccessors = () => isArray(this.config.y) ? this.config.y : [this.config.y];
    this.stacked = true;
    this.events = {};
    this._barData = [];
    if (config)
      this.setConfig(config);
  }
  get bleed() {
    this._barData = this._getVisibleData();
    if (this._barData.length === 0)
      return { top: 0, bottom: 0, left: 0, right: 0 };
    const isHorizontalAndFlipped = !this.isVertical() && this.dataScale.range()[0] > this.dataScale.range()[1];
    const dataDomain = this.dataScale.domain();
    const halfGroupWidth = this._getBarWidth() / 2;
    const dataScaleValues = this._barData.map((d18, i8) => getNumber(d18, this.config.x, i8));
    const firstDataValue = min(dataScaleValues);
    const lastDataValue = max(dataScaleValues);
    const firstValuePx = this.dataScale(firstDataValue);
    const lastValuePx = this.dataScale(lastDataValue);
    const dataDomainRequiredStart = this.dataScale.invert(firstValuePx + (isHorizontalAndFlipped ? halfGroupWidth : -halfGroupWidth));
    const dataDomainRequiredEnd = this.dataScale.invert(lastValuePx + (isHorizontalAndFlipped ? -halfGroupWidth : halfGroupWidth));
    const bleedPxStart = dataDomainRequiredStart <= dataDomain[0] ? this.dataScale(dataDomain[0]) - this.dataScale(dataDomainRequiredStart) : 0;
    const bleedPxEnd = dataDomainRequiredEnd > dataDomain[1] ? this.dataScale(dataDomainRequiredEnd) - this.dataScale(dataDomain[1]) : 0;
    return {
      top: this.isVertical() ? 0 : isHorizontalAndFlipped ? -bleedPxEnd : bleedPxStart,
      bottom: this.isVertical() ? 0 : isHorizontalAndFlipped ? -bleedPxStart : bleedPxEnd,
      left: this.isVertical() ? bleedPxStart : 0,
      right: this.isVertical() ? bleedPxEnd : 0
    };
  }
  get dataScale() {
    return this.isVertical() ? this.xScale : this.yScale;
  }
  get valueScale() {
    return this.isVertical() ? this.yScale : this.xScale;
  }
  isVertical() {
    return this.config.orientation === Orientation.Vertical;
  }
  _render(customDuration) {
    const { config } = this;
    const duration = isNumber(customDuration) ? customDuration : config.duration;
    const yAccessors = this.getAccessors();
    const stacked = getStackedData(this._barData, 0, yAccessors, this._prevNegative);
    this._prevNegative = stacked.map((s12) => !!s12.isMostlyNegative);
    const barGroups = this.g.selectAll(`.${barGroup}`).data(this._barData, (d18, i8) => {
      var _a;
      return `${(_a = getString(d18, config.id, i8)) !== null && _a !== void 0 ? _a : i8}`;
    });
    const getBarGroupsTransform = (d18, i8) => {
      const v28 = this.dataScale(getNumber(d18, config.x, i8));
      const x21 = this.isVertical() ? v28 : 0;
      const y25 = this.isVertical() ? 0 : v28;
      return `translate(${x21},${y25})`;
    };
    const barGroupsEnter = barGroups.enter().append("g").attr("class", barGroup).attr("transform", getBarGroupsTransform).style("opacity", 1);
    const barGroupsMerged = barGroupsEnter.merge(barGroups);
    smartTransition(barGroupsMerged, duration).attr("transform", getBarGroupsTransform).style("opacity", 1);
    const barGroupExit$1 = barGroups.exit().attr("class", barGroupExit);
    smartTransition(barGroupExit$1, duration).style("opacity", 0).remove();
    smartTransition(barGroupExit$1.selectAll(`.${bar}`), duration).attr("transform", this.isVertical() ? `translate(0,${this._height / 3})` : `translate(${this._width / 6},0)`);
    const bars = barGroupsMerged.selectAll(`.${bar}`).data((d18, j6) => stacked.map((s12, stackIndex) => Object.assign(Object.assign({}, d18), {
      _index: j6,
      _stacked: s12[j6],
      // Ending bar if the next stack is not the same as the current one
      _ending: stackIndex === stacked.length - 1 || stackIndex <= stacked.length - 1 && stacked[stackIndex + 1][j6][0] !== s12[j6][1]
    })));
    const barsEnter = bars.enter().append("path").attr("class", bar).attr("d", (d18, j6) => this._getBarPath(d18, j6, true)).style("fill", (d18, j6) => getColor(d18, config.color, j6));
    const barsMerged = barsEnter.merge(bars);
    smartTransition(barsMerged, duration).attr("d", (d18, j6) => this._getBarPath(d18, j6)).style("fill", (d18, j6) => getColor(d18, config.color, j6)).style("cursor", (d18, j6) => getString(d18, config.cursor, j6));
    smartTransition(bars.exit(), duration).style("opacity", 0).remove();
  }
  _getBarWidth() {
    const { config, datamodel: { data } } = this;
    if (isEmpty(data))
      return 0;
    if (config.barWidth)
      return min([config.barWidth, config.barMaxWidth]);
    const isOrdinal = this.dataScale.bandwidth;
    const domain = this.dataScale.domain ? this.dataScale.domain() : [];
    const domainLength = isOrdinal ? domain.length : domain[1] - domain[0];
    let dataSize = 1 + domainLength / config.dataStep || !isOrdinal && data.filter((d18, i8) => {
      const value2 = getNumber(d18, config.x, i8);
      return value2 >= domain[0] && value2 <= domain[1];
    }).length || data.length;
    if (!isOrdinal && dataSize >= 2)
      dataSize += 1;
    const c6 = dataSize < 2 ? 1 : 1 - config.barPadding;
    const barWidth = c6 * (this.isVertical() ? this._width : this._height) / dataSize;
    return min([barWidth, config.barMaxWidth]);
  }
  _getVisibleData() {
    const { config, datamodel: { data } } = this;
    const groupWidth = this._getBarWidth();
    const halfGroupWidthPx = data.length < 2 ? 0 : groupWidth / 2;
    const scale = this.dataScale;
    const halfGroupWidth = Math.abs(scale.invert(halfGroupWidthPx) - scale.invert(0));
    const filtered = data === null || data === void 0 ? void 0 : data.filter((d18, i8) => {
      const v28 = getNumber(d18, config.x, i8);
      const domain = scale.domain();
      const domainMin = +domain[0];
      const domainMax = +domain[1];
      return v28 >= domainMin - halfGroupWidth && v28 <= domainMax + halfGroupWidth;
    });
    return filtered;
  }
  _getBarPath(d18, accessorIndex, isEntering = false) {
    const { config } = this;
    const yAccessors = this.getAccessors();
    const barWidth = this._getBarWidth();
    const isNegative = d18._stacked[1] < 0;
    const isEnding = d18._ending;
    const value2 = getNumber(d18, yAccessors[accessorIndex], d18._index);
    const height = isEntering ? 0 : Math.abs(this.valueScale(d18._stacked[0]) - this.valueScale(d18._stacked[1]));
    const h17 = !isEntering && config.barMinHeight1Px && height < 1 && isFinite(value2) && value2 !== config.barMinHeightZeroValue ? 1 : height;
    const y25 = isEntering ? this.valueScale(0) : this.valueScale(isNegative ? d18._stacked[0] : d18._stacked[1]) - (height < 1 && config.barMinHeight1Px ? 1 : 0);
    const x21 = -barWidth / 2;
    const width = barWidth;
    const cornerRadius = config.roundedCorners ? isNumber(config.roundedCorners) ? +config.roundedCorners : width / 2 : 0;
    const cornerRadiusClamped = clamp(cornerRadius, 0, Math.min(height, width) / 2);
    const isNorthDirected = this.yScale.range()[0] > this.yScale.range()[1];
    return roundedRectPath({
      x: this.isVertical() ? x21 : y25 - h17,
      y: this.isVertical() ? y25 + (isNorthDirected ? 0 : -h17) : x21,
      w: this.isVertical() ? width : h17,
      h: this.isVertical() ? h17 : width,
      tl: isEnding && (this.isVertical() ? !isNegative && isNorthDirected || isNegative && !isNorthDirected : isNegative),
      tr: isEnding && (this.isVertical() ? !isNegative && isNorthDirected || isNegative && !isNorthDirected : !isNegative),
      br: isEnding && (this.isVertical() ? isNegative && isNorthDirected || !isNegative && !isNorthDirected : !isNegative),
      bl: isEnding && (this.isVertical() ? isNegative && isNorthDirected || !isNegative && !isNorthDirected : isNegative),
      r: cornerRadiusClamped
    });
  }
  getValueScaleExtent(scaleByVisibleData) {
    const { datamodel } = this;
    const yAccessors = this.getAccessors();
    const data = scaleByVisibleData ? this._getVisibleData() : datamodel.data;
    return getStackedExtent(data, ...yAccessors);
  }
  getDataScaleExtent() {
    const { config, datamodel } = this;
    return getExtent(datamodel.data, config.x);
  }
  getYDataExtent(scaleByVisibleData) {
    return this.isVertical() ? this.getValueScaleExtent(scaleByVisibleData) : this.getDataScaleExtent();
  }
  getXDataExtent() {
    return this.isVertical() ? this.getDataScaleExtent() : this.getValueScaleExtent(false);
  }
};
StackedBar.selectors = style_exports3;

// node_modules/@unovis/ts/components/grouped-bar/config.js
var GroupedBarDefaultConfig = Object.assign(Object.assign({}, XYComponentDefaultConfig), { color: void 0, groupMaxWidth: void 0, groupWidth: void 0, dataStep: void 0, groupPadding: 0.05, barPadding: 0, roundedCorners: 2, barMinHeight: 2, cursor: null, orientation: Orientation.Vertical });

// node_modules/@unovis/ts/components/grouped-bar/style.js
var style_exports4 = {};
__export(style_exports4, {
  bar: () => bar2,
  barGroup: () => barGroup2,
  barGroupExit: () => barGroupExit2,
  globalStyles: () => globalStyles3,
  root: () => root5
});
var root5 = css`
  label: grouped-bar-component;
`;
var globalStyles3 = injectGlobal`
  :root {
    --vis-grouped-bar-cursor: default;
    --vis-grouped-bar-fill-color: var(--vis-color-main);
    --vis-grouped-bar-stroke-color: none;
    --vis-grouped-bar-stroke-width: 0px;
    --vis-grouped-bar-hover-stroke-width: 1px;
    --vis-grouped-bar-hover-stroke-color: none;


    /* Dark Theme */
    --vis-dark-grouped-bar-stroke-color: none;
  }

  body.theme-dark ${`.${root5}`} {
    --vis-grouped-bar-stroke-color: var(--vis-dark-grouped-bar-stroke-color);
  }
`;
var bar2 = css`
  label: bar;
  fill: var(--vis-grouped-bar-fill-color);
  stroke: var(--vis-grouped-bar-stroke-color);
  stroke-width: var(--vis-grouped-bar-stroke-width);
  cursor: var(--vis-grouped-bar-cursor);

  &:hover {
    stroke-width: var(--vis-grouped-bar-hover-stroke-width);
    stroke: var(--vis-grouped-bar-hover-stroke-color);
  }
`;
var barGroup2 = css`
  label: barGroup;
`;
var barGroupExit2 = css`
  label: barGroupExit;
`;

// node_modules/@unovis/ts/components/grouped-bar/index.js
var GroupedBar = class extends XYComponentCore {
  constructor(config) {
    super();
    this._defaultConfig = GroupedBarDefaultConfig;
    this.config = this._defaultConfig;
    this.getAccessors = () => isArray(this.config.y) ? this.config.y : [this.config.y];
    this.events = {};
    this._barData = [];
    if (config)
      this.setConfig(config);
  }
  get bleed() {
    this._barData = this._getVisibleData();
    if (this._barData.length === 0)
      return { top: 0, bottom: 0, left: 0, right: 0 };
    const isHorizontalAndFlipped = !this.isVertical() && this.dataScale.range()[0] > this.dataScale.range()[1];
    const dataDomain = this.dataScale.domain();
    const halfGroupWidth = this._getGroupWidth() / 2;
    const dataScaleValues = this._barData.map((d18, i8) => getNumber(d18, this.config.x, i8));
    const firstDataValue = min(dataScaleValues);
    const lastDataValue = max(dataScaleValues);
    const firstValuePx = this.dataScale(firstDataValue);
    const lastValuePx = this.dataScale(lastDataValue);
    const dataDomainRequiredStart = this.dataScale.invert(firstValuePx + (isHorizontalAndFlipped ? halfGroupWidth : -halfGroupWidth));
    const dataDomainRequiredEnd = this.dataScale.invert(lastValuePx + (isHorizontalAndFlipped ? -halfGroupWidth : halfGroupWidth));
    const bleedPxStart = dataDomainRequiredStart <= dataDomain[0] ? this.dataScale(dataDomain[0]) - this.dataScale(dataDomainRequiredStart) : 0;
    const bleedPxEnd = dataDomainRequiredEnd > dataDomain[1] ? this.dataScale(dataDomainRequiredEnd) - this.dataScale(dataDomain[1]) : 0;
    return {
      top: this.isVertical() ? 0 : isHorizontalAndFlipped ? -bleedPxEnd : bleedPxStart,
      bottom: this.isVertical() ? 0 : isHorizontalAndFlipped ? -bleedPxStart : bleedPxEnd,
      left: this.isVertical() ? bleedPxStart : 0,
      right: this.isVertical() ? bleedPxEnd : 0
    };
  }
  get dataScale() {
    return this.isVertical() ? this.xScale : this.yScale;
  }
  get valueScale() {
    return this.isVertical() ? this.yScale : this.xScale;
  }
  isVertical() {
    return this.config.orientation === Orientation.Vertical;
  }
  _render(customDuration) {
    const { config } = this;
    const duration = isNumber(customDuration) ? customDuration : config.duration;
    const groupWidth = this._getGroupWidth();
    const yAccessors = this.getAccessors();
    const innerBandScaleRange = [-groupWidth / 2, groupWidth / 2];
    const innerBandScale = band().domain(range(yAccessors.length)).range(innerBandScaleRange).paddingInner(config.barPadding).paddingOuter(config.barPadding);
    const barGroups = this.g.selectAll(`.${barGroup2}`).data(this._barData, (d18, i8) => {
      var _a;
      return `${(_a = getString(d18, config.id, i8)) !== null && _a !== void 0 ? _a : i8}`;
    });
    const getBarGroupsTransform = (d18, i8) => {
      const v28 = this.dataScale(getNumber(d18, config.x, i8));
      const x21 = this.isVertical() ? v28 : 0;
      const y25 = this.isVertical() ? 0 : v28;
      return `translate(${x21},${y25})`;
    };
    const barGroupsEnter = barGroups.enter().append("g").attr("class", barGroup2).attr("transform", getBarGroupsTransform).style("opacity", 1);
    const barGroupsMerged = barGroupsEnter.merge(barGroups);
    smartTransition(barGroupsMerged, duration).attr("transform", getBarGroupsTransform).style("opacity", 1);
    const barGroupExit$1 = barGroups.exit().attr("class", barGroupExit2);
    smartTransition(barGroupExit$1, duration).style("opacity", 0).remove();
    smartTransition(barGroupExit$1.selectAll(`.${bar2}`), duration).attr("transform", (d18, i8, e3) => {
      return this.isVertical() ? `translate(0,${this.yScale(0)}) scale(1,0)` : `translate(${this.xScale(0)},0) scale(0,1)`;
    });
    const barWidth = innerBandScale.bandwidth();
    const bars = barGroupsMerged.selectAll(`.${bar2}`).data((d18) => yAccessors.map(() => d18));
    const valueAxisDirection = this._getValueAxisDirection();
    const barsEnter = bars.enter().append("path").attr("class", bar2).attr("d", (d18, i8) => {
      const x21 = innerBandScale(i8);
      const y25 = this.valueScale(0);
      const width = barWidth;
      const height = 0;
      return this._getBarPath(x21, y25, width, height, false, valueAxisDirection);
    }).style("fill", (d18, i8) => getColor(d18, config.color, i8));
    const barsMerged = barsEnter.merge(bars);
    smartTransition(barsMerged, duration).attr("d", (d18, j6) => {
      const x21 = innerBandScale(j6);
      const width = barWidth;
      const value2 = getNumber(d18, yAccessors[j6]);
      const isNegative = value2 < 0;
      let y25 = isNegative ? this.valueScale(0) : this.valueScale(value2 || 0);
      let height = Math.abs(this.valueScale(0) - this.valueScale(value2)) || 0;
      if (height < config.barMinHeight) {
        const dir = valueAxisDirection === Direction.North ? -1 : 1;
        y25 = this.valueScale(0) + dir * config.barMinHeight;
        height = config.barMinHeight;
      }
      return this._getBarPath(x21, y25, width, height, isNegative, valueAxisDirection);
    }).style("fill", (d18, i8) => getColor(d18, config.color, i8)).style("cursor", (d18, i8) => getString(d18, config.cursor, i8));
    smartTransition(bars.exit(), duration).remove();
  }
  _getValueAxisDirection() {
    return this.valueScale.range()[0] > this.valueScale.range()[1] ? Direction.North : Direction.South;
  }
  _getVisibleData() {
    const { config, datamodel: { data } } = this;
    const groupWidth = this._getGroupWidth();
    const halfGroupWidth = data.length < 2 ? 0 : groupWidth / 2;
    const dataScale = this.dataScale;
    const xHalfGroupWidth = Math.abs(dataScale.invert(halfGroupWidth) - dataScale.invert(0));
    const filtered = data === null || data === void 0 ? void 0 : data.filter((d18, i8) => {
      const v28 = getNumber(d18, config.x, i8);
      const domain = dataScale.domain();
      const domainMin = +domain[0];
      const domainMax = +domain[1];
      return v28 >= domainMin - xHalfGroupWidth && v28 <= domainMax + xHalfGroupWidth;
    });
    return filtered;
  }
  _getBarPath(x21, y25, width, height, isNegative, direction) {
    const { config } = this;
    const cornerRadius = config.roundedCorners ? isNumber(config.roundedCorners) ? +config.roundedCorners : width / 2 : 0;
    const cornerRadiusClamped = clamp(cornerRadius, 0, Math.min(height, width) / 2);
    const isNorthDirected = direction === Direction.North;
    const roundedTop = this.isVertical() && isNegative !== isNorthDirected;
    const roundedBottom = this.isVertical() && isNegative === isNorthDirected;
    const roundedLeft = !this.isVertical() && isNegative;
    const roundedRight = !this.isVertical() && !isNegative;
    return roundedRectPath({
      x: this.isVertical() ? x21 : y25 + (isNorthDirected ? 0 : -height),
      y: this.isVertical() ? y25 + (isNorthDirected ? 0 : -height) : x21,
      w: this.isVertical() ? width : height,
      h: this.isVertical() ? height : width,
      tl: roundedTop || roundedLeft,
      tr: roundedTop || roundedRight,
      bl: roundedBottom || roundedLeft,
      br: roundedBottom || roundedRight,
      r: cornerRadiusClamped
    });
  }
  _getGroupWidth() {
    const { config, datamodel: { data } } = this;
    if (isEmpty(data))
      return 0;
    if (config.groupWidth) {
      return min([config.groupWidth, config.groupMaxWidth]);
    }
    const isOrdinal = this.dataScale.bandwidth;
    const domain = this.dataScale.domain ? this.dataScale.domain() : [];
    const domainLength = isOrdinal ? domain.length : domain[1] - domain[0];
    let dataSize = 1 + domainLength / config.dataStep || !isOrdinal && data.filter((d18, i8) => {
      const value2 = getNumber(d18, config.x, i8);
      return value2 >= domain[0] && value2 <= domain[1];
    }).length || data.length;
    if (!isOrdinal && dataSize >= 2)
      dataSize += 1;
    const c6 = dataSize < 2 ? 1 : 1 - config.groupPadding;
    const groupWidth = c6 * (this.isVertical() ? this._width : this._height) / dataSize;
    return min([groupWidth, config.groupMaxWidth]);
  }
  getValueScaleExtent(scaleByVisibleData) {
    const { datamodel } = this;
    const yAccessors = this.getAccessors();
    const data = scaleByVisibleData ? this._getVisibleData() : datamodel.data;
    const min7 = getMin(data, ...yAccessors);
    const max8 = getMax(data, ...yAccessors);
    return [min7 > 0 ? 0 : min7, max8 < 0 ? 0 : max8];
  }
  getDataScaleExtent() {
    const { config, datamodel } = this;
    return getExtent(datamodel.data, config.x);
  }
  getYDataExtent(scaleByVisibleData) {
    return this.isVertical() ? this.getValueScaleExtent(scaleByVisibleData) : this.getDataScaleExtent();
  }
  getXDataExtent() {
    return this.isVertical() ? this.getDataScaleExtent() : this.getValueScaleExtent(false);
  }
};
GroupedBar.selectors = style_exports4;

// node_modules/d3-axis/src/identity.js
function identity_default3(x21) {
  return x21;
}

// node_modules/d3-axis/src/axis.js
var top = 1;
var right = 2;
var bottom = 3;
var left = 4;
var epsilon4 = 1e-6;
function translateX(x21) {
  return "translate(" + x21 + ",0)";
}
function translateY(y25) {
  return "translate(0," + y25 + ")";
}
function number3(scale) {
  return (d18) => +scale(d18);
}
function center(scale, offset) {
  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
  if (scale.round()) offset = Math.round(offset);
  return (d18) => +scale(d18) + offset;
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k17 = orient === top || orient === left ? -1 : 1, x21 = orient === left || orient === right ? "x" : "y", transform2 = orient === top || orient === bottom ? translateX : translateY;
  function axis3(context) {
    var values = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format2 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity_default3 : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range3 = scale.range(), range0 = +range3[0] + offset, range1 = +range3[range3.length - 1] + offset, position = (scale.bandwidth ? center : number3)(scale.copy(), offset), selection2 = context.selection ? context.selection() : context, path3 = selection2.selectAll(".domain").data([null]), tick2 = selection2.selectAll(".tick").data(values, scale).order(), tickExit = tick2.exit(), tickEnter = tick2.enter().append("g").attr("class", "tick"), line5 = tick2.select("line"), text = tick2.select("text");
    path3 = path3.merge(path3.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick2 = tick2.merge(tickEnter);
    line5 = line5.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x21 + "2", k17 * tickSizeInner));
    text = text.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x21, k17 * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection2) {
      path3 = path3.transition(context);
      tick2 = tick2.transition(context);
      line5 = line5.transition(context);
      text = text.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon4).attr("transform", function(d18) {
        return isFinite(d18 = position(d18)) ? transform2(d18 + offset) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon4).attr("transform", function(d18) {
        var p13 = this.parentNode.__axis;
        return transform2((p13 && isFinite(p13 = p13(d18)) ? p13 : position(d18)) + offset);
      });
    }
    tickExit.remove();
    path3.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k17 * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k17 * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k17 * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k17 * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
    tick2.attr("opacity", 1).attr("transform", function(d18) {
      return transform2(position(d18) + offset);
    });
    line5.attr(x21 + "2", k17 * tickSizeInner);
    text.attr(x21, k17 * spacing).text(format2);
    selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection2.each(function() {
      this.__axis = position;
    });
  }
  axis3.scale = function(_17) {
    return arguments.length ? (scale = _17, axis3) : scale;
  };
  axis3.ticks = function() {
    return tickArguments = Array.from(arguments), axis3;
  };
  axis3.tickArguments = function(_17) {
    return arguments.length ? (tickArguments = _17 == null ? [] : Array.from(_17), axis3) : tickArguments.slice();
  };
  axis3.tickValues = function(_17) {
    return arguments.length ? (tickValues = _17 == null ? null : Array.from(_17), axis3) : tickValues && tickValues.slice();
  };
  axis3.tickFormat = function(_17) {
    return arguments.length ? (tickFormat2 = _17, axis3) : tickFormat2;
  };
  axis3.tickSize = function(_17) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_17, axis3) : tickSizeInner;
  };
  axis3.tickSizeInner = function(_17) {
    return arguments.length ? (tickSizeInner = +_17, axis3) : tickSizeInner;
  };
  axis3.tickSizeOuter = function(_17) {
    return arguments.length ? (tickSizeOuter = +_17, axis3) : tickSizeOuter;
  };
  axis3.tickPadding = function(_17) {
    return arguments.length ? (tickPadding = +_17, axis3) : tickPadding;
  };
  axis3.offset = function(_17) {
    return arguments.length ? (offset = +_17, axis3) : offset;
  };
  return axis3;
}
function axisTop(scale) {
  return axis(top, scale);
}
function axisRight(scale) {
  return axis(right, scale);
}
function axisBottom(scale) {
  return axis(bottom, scale);
}
function axisLeft(scale) {
  return axis(left, scale);
}

// node_modules/@unovis/ts/types/text.js
var TrimMode;
(function(TrimMode2) {
  TrimMode2["Start"] = "start";
  TrimMode2["Middle"] = "middle";
  TrimMode2["End"] = "end";
})(TrimMode || (TrimMode = {}));
var VerticalAlign;
(function(VerticalAlign2) {
  VerticalAlign2["Top"] = "top";
  VerticalAlign2["Middle"] = "middle";
  VerticalAlign2["Bottom"] = "bottom";
})(VerticalAlign || (VerticalAlign = {}));
var FitMode;
(function(FitMode2) {
  FitMode2["Wrap"] = "wrap";
  FitMode2["Trim"] = "trim";
})(FitMode || (FitMode = {}));
var TextAlign;
(function(TextAlign2) {
  TextAlign2["Left"] = "left";
  TextAlign2["Center"] = "center";
  TextAlign2["Right"] = "right";
})(TextAlign || (TextAlign = {}));

// node_modules/@unovis/ts/utils/text.js
var import_striptags = __toESM(require_striptags(), 1);

// node_modules/@unovis/ts/types/svg.js
function getTextAnchorFromTextAlign(textAlign) {
  switch (textAlign) {
    case TextAlign.Center:
      return "middle";
    case TextAlign.Right:
      return "end";
    case TextAlign.Left:
    default:
      return "start";
  }
}

// node_modules/@unovis/ts/utils/text.js
var textAlignToAnchor = (textAlign) => {
  switch (textAlign) {
    case TextAlign.Left:
      return "start";
    case TextAlign.Right:
      return "end";
    case TextAlign.Center:
      return "middle";
    default:
      return null;
  }
};
function kebabCaseToCamel(str) {
  return str.replace(/-([a-z])/g, (_17, letter) => letter.toUpperCase());
}
function kebabCase(str) {
  var _a;
  return (_a = str.match(/[A-Z]{2,}(?=[A-Z][a-z0-9]*|\b)|[A-Z]?[a-z0-9]*|[A-Z]|[0-9]+/g)) === null || _a === void 0 ? void 0 : _a.filter(Boolean).map((x21) => x21.toLowerCase()).join("-");
}
function escapeStringKeepHash(str) {
  return str.replace(/['"]/g, "&#39;").replace(/\u0000/g, "\\0").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\v/g, "\\v").replace(/\t/g, "\\t").replace(/\f/g, "\\f");
}
function trimStringStart(str, maxLength = 15) {
  if (!str)
    return "";
  return str.length > maxLength ? `…${str.substr(str.length - maxLength, maxLength)}` : str;
}
function trimStringMiddle(str, maxLength = 15) {
  if (!str)
    return "";
  const dist = Math.floor((maxLength - 3) / 2);
  return str.length > maxLength ? `${str.substr(0, dist)}…${str.substr(-dist, dist)}` : str;
}
function trimStringEnd(str, maxLength = 15) {
  if (!str)
    return "";
  return str.length > maxLength ? `${str.substr(0, maxLength)}…` : str;
}
function trimString(str, length = 15, type2 = TrimMode.Middle) {
  if (!str)
    return "";
  let result = trimStringEnd(str, length);
  if (type2 === TrimMode.Start)
    result = trimStringStart(str, length);
  else if (type2 === TrimMode.Middle)
    result = trimStringMiddle(str, length);
  return result;
}
function splitString(text, separators = [" "]) {
  let result = [text];
  for (let i8 = 0; i8 < separators.length; i8++) {
    const sep = separators[i8];
    result.forEach((d18, index3) => {
      const separated = d18.split(sep);
      const words = separated.map((word, j6) => `${word}${j6 === separated.length - 1 ? "" : sep}`);
      result[index3] = words;
    });
    result = flatten(result);
  }
  return result;
}
function wrapSVGText(textElement, width, separator = [" ", "-", ".", ","]) {
  const text = textElement.text();
  if (!text)
    return;
  const separators = isArray(separator) ? separator : [separator];
  const words = splitString(text, separators);
  const x21 = parseFloat(textElement.attr("x")) || 0;
  textElement.text("");
  let tspan = textElement.append("tspan").attr("x", x21);
  let tspanContent = `${words[0]}`;
  tspan.text(tspanContent);
  words.forEach((word, i8) => {
    if (i8 === 0)
      return;
    const tspanText = `${tspanContent}${word}`;
    tspan.text(tspanText);
    const tspanWidth = tspan.node().getComputedTextLength();
    if (tspanWidth > width) {
      tspan.text(tspanContent.trim());
      tspan = textElement.append("tspan").attr("x", x21).attr("dy", "1.2em").text(word);
      tspanContent = word;
    } else
      tspanContent += word;
  });
}
function trimSVGText(svgTextSelection, maxWidth, trimType, fastMode, fontSize, fontWidthToHeightRatio) {
  var _a;
  if (maxWidth === void 0) {
    maxWidth = 50;
  }
  if (trimType === void 0) {
    trimType = TrimMode.Middle;
  }
  if (fastMode === void 0) {
    fastMode = true;
  }
  if (fontSize === void 0) {
    fontSize = +((_a = window.getComputedStyle(svgTextSelection.node())) === null || _a === void 0 ? void 0 : _a.fontSize) || 0;
  }
  if (fontWidthToHeightRatio === void 0) {
    fontWidthToHeightRatio = getFontWidthToHeightRatio();
  }
  const text = svgTextSelection.text() || "";
  const textLength = text.length;
  const textWidth = fastMode ? fontSize * textLength * fontWidthToHeightRatio : svgTextSelection.node().getComputedTextLength();
  const tolerance = 1.1;
  const maxCharacters = Math.ceil(textLength * maxWidth / (tolerance * textWidth));
  if (maxCharacters < textLength) {
    svgTextSelection.text(trimString(text, maxCharacters, trimType));
    return true;
  }
  return false;
}
function estimateStringPixelLength(str, fontSize, fontWidthToHeightRatio = getFontWidthToHeightRatio()) {
  return str.length * fontSize * fontWidthToHeightRatio || 0;
}
function getPreciseStringLengthPx(str, fontFamily, fontSize) {
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  const text = document.createElementNS(svgNS, "text");
  text.textContent = str;
  text.setAttribute("font-size", `${fontSize}`);
  text.setAttribute("font-family", fontFamily);
  svg.appendChild(text);
  document.body.appendChild(svg);
  const length = text.getComputedTextLength();
  document.body.removeChild(svg);
  return length;
}
function estimateTextSize(svgTextSelection, fontSize, dy = 0.32, fastMode = true, fontWidthToHeightRatio) {
  fontWidthToHeightRatio = fontWidthToHeightRatio || getFontWidthToHeightRatio();
  const tspanSelection = svgTextSelection.selectAll("tspan");
  const lines3 = tspanSelection.size() || 1;
  const height = svgTextSelection.text() ? 0.85 * fontSize * lines3 * (1 + dy) - dy : 0;
  let width = 0;
  if (tspanSelection.empty()) {
    const textLength = svgTextSelection.text().length;
    width = fastMode ? fontSize * textLength * fontWidthToHeightRatio : svgTextSelection.node().getComputedTextLength();
  } else {
    for (const tspan of tspanSelection.nodes()) {
      const tspanTextLength = tspan.textContent.length;
      const w14 = fastMode ? fontSize * tspanTextLength * fontWidthToHeightRatio : tspan.getComputedTextLength();
      if (w14 > width)
        width = w14;
    }
  }
  return { width, height };
}
function breakTextIntoLines(textBlock, width = void 0, fastMode = true, separator = UNOVIS_TEXT_SEPARATOR_DEFAULT, wordBreak = false) {
  var _a, _b, _c;
  const text = `${textBlock.text}`;
  if (!text)
    return [];
  const fontSize = (_a = textBlock.fontSize) !== null && _a !== void 0 ? _a : UNOVIS_TEXT_DEFAULT.fontSize;
  const fontFamily = (_b = textBlock.fontFamily) !== null && _b !== void 0 ? _b : UNOVIS_TEXT_DEFAULT.fontFamily;
  const fontWidthToHeightRatio = (_c = textBlock.fontWidthToHeightRatio) !== null && _c !== void 0 ? _c : UNOVIS_TEXT_DEFAULT.fontWidthToHeightRatio;
  const separators = Array.isArray(separator) ? separator : [separator];
  const splitByNewLine = text.split("\n");
  return splitByNewLine.map((str) => {
    const lines3 = [];
    if (!width)
      return [str];
    const words = splitString(str, separators);
    let line5 = "";
    for (let i8 = 0; i8 < words.length; i8 += 1) {
      const textLengthPx = fastMode ? estimateStringPixelLength(line5 + words[i8], fontSize, fontWidthToHeightRatio) : getPreciseStringLengthPx(line5 + words[i8], fontFamily, fontSize);
      if (textLengthPx < width || i8 === 0) {
        line5 += words[i8];
      } else {
        lines3.push(line5.trim());
        line5 = words[i8];
      }
      const minCharactersOnLine = 2;
      if (wordBreak) {
        while (line5.trim().length > minCharactersOnLine) {
          const subLineLengthPx = fastMode ? estimateStringPixelLength(line5, fontSize, fontWidthToHeightRatio) : getPreciseStringLengthPx(line5, fontFamily, fontSize);
          if (subLineLengthPx > width) {
            let breakIndex = line5.trim().length - minCharactersOnLine;
            while (breakIndex > 0) {
              const subLine = `${line5.substring(0, breakIndex)}${UNOVIS_TEXT_HYPHEN_CHARACTER_DEFAULT}`;
              const subLinePx = fastMode ? estimateStringPixelLength(subLine, fontSize, fontWidthToHeightRatio) : getPreciseStringLengthPx(subLine, fontFamily, fontSize);
              if (subLinePx <= width || breakIndex === 1) {
                lines3.push(subLine.trim());
                line5 = line5.substring(breakIndex);
                break;
              }
              breakIndex--;
            }
          } else {
            break;
          }
        }
      }
    }
    if (line5)
      lines3.push(line5.trim());
    return lines3;
  }).flat();
}
function getWrappedText(text, width = void 0, height = void 0, fastMode = true, separator = UNOVIS_TEXT_SEPARATOR_DEFAULT, wordBreak = false) {
  const textArrays = Array.isArray(text) ? text.map((t4) => merge2(UNOVIS_TEXT_DEFAULT, t4)) : [merge2(UNOVIS_TEXT_DEFAULT, text)];
  const textWrapped = textArrays.map((block) => breakTextIntoLines(block, width, fastMode, separator, wordBreak));
  const firstBlock = textArrays[0];
  let h17 = -firstBlock.fontSize * (firstBlock.lineHeight - 1);
  const blocks = [];
  textArrays.forEach((text2, i8) => {
    var _a;
    let lines3 = textWrapped[i8];
    const prevBlock = i8 > 0 ? blocks[i8 - 1] : void 0;
    const prevBlockMarginBottomPx = prevBlock ? prevBlock.marginBottom : 0;
    const marginTopPx = text2.marginTop;
    const effectiveMarginPx = Math.max(prevBlockMarginBottomPx, marginTopPx);
    h17 += effectiveMarginPx;
    const dh = text2.fontSize * text2.lineHeight;
    let maxWidth = 0;
    for (let k17 = 0; k17 < lines3.length; k17 += 1) {
      let line5 = lines3[k17];
      h17 += dh;
      const lineWithEllipsis = `${line5} …`;
      const textLengthPx = fastMode ? estimateStringPixelLength(lineWithEllipsis, text2.fontSize, text2.fontWidthToHeightRatio) : getPreciseStringLengthPx(lineWithEllipsis, text2.fontFamily, text2.fontSize);
      maxWidth = Math.max(textLengthPx, maxWidth);
      if (height && h17 + dh > height && k17 !== lines3.length - 1) {
        const lastCharacter = line5.charAt(line5.length - 1);
        if (lastCharacter === UNOVIS_TEXT_HYPHEN_CHARACTER_DEFAULT) {
          line5 = line5.substr(0, lines3[k17].length - 1);
        }
        if (textLengthPx < width) {
          lines3[k17] = lineWithEllipsis;
        } else {
          lines3[k17] = `${lines3[k17].substr(0, lines3[k17].length - 2)}…`;
        }
        lines3 = lines3.slice(0, k17 + 1);
        break;
      }
    }
    blocks.push(Object.assign(Object.assign({}, text2), { _lines: lines3, _estimatedHeight: h17 - ((prevBlock === null || prevBlock === void 0 ? void 0 : prevBlock._estimatedHeight) || 0), _maxWidth: Math.max(maxWidth, (_a = prevBlock === null || prevBlock === void 0 ? void 0 : prevBlock._maxWidth) !== null && _a !== void 0 ? _a : 0) }));
  });
  return blocks;
}
function renderTextToTspanStrings(blocks, x21 = 0, y25) {
  return blocks.map((b25, i8) => {
    const prevBlock = i8 > 0 ? blocks[i8 - 1] : void 0;
    const prevBlockMarginBottomEm = prevBlock ? prevBlock.marginBottom / prevBlock.fontSize : 0;
    const marginTopEm = b25.marginTop / b25.fontSize;
    const marginEm = Math.max(prevBlockMarginBottomEm, marginTopEm);
    const attributes = {
      fontSize: b25.fontSize,
      fontFamily: b25.fontFamily,
      fontWeight: b25.fontWeight,
      fill: b25.color,
      y: i8 === 0 && y25
    };
    const attributesString = Object.entries(attributes).filter(([_17, value2]) => value2).map(([key, value2]) => `${kebabCase(key)}="${escapeStringKeepHash(value2.toString())}"`).join(" ");
    return `<tspan xmlns="http://www.w3.org/2000/svg" ${attributesString}>${b25._lines.map((line5, k17) => {
      let dy;
      if (i8 === 0 && k17 === 0)
        dy = 0.8 + marginEm;
      else if (k17 === 0)
        dy = marginEm + b25.lineHeight;
      else
        dy = b25.lineHeight;
      return `<tspan x="${x21}" dy="${dy}em">${line5.length ? line5 : " "}</tspan>`;
    }).join("")}</tspan>`;
  });
}
function estimateWrappedTextHeight(blocks) {
  return sum(blocks, (b25) => b25._estimatedHeight);
}
var allowedSvgTextTags = ["text", "tspan", "textPath", "altGlyph", "altGlyphDef", "altGlyphItem", "glyphRef", "textRef", "textArea"];
function renderTextToSvgTextElement(textElement, text, options, trimmed) {
  var _a, _b;
  const wrappedText = getWrappedText(text, options.width, void 0, options.fastMode, options.separator, options.wordBreak);
  const textElementX = (_a = options.x) !== null && _a !== void 0 ? _a : +textElement.getAttribute("x");
  const textElementY = (_b = options.y) !== null && _b !== void 0 ? _b : +textElement.getAttribute("y");
  const x21 = textElementX !== null && textElementX !== void 0 ? textElementX : 0;
  let y25 = textElementY !== null && textElementY !== void 0 ? textElementY : 0;
  if (options.textAlign) {
    textElement.setAttribute("text-anchor", getTextAnchorFromTextAlign(options.textAlign));
  }
  if (options.verticalAlign && options.verticalAlign !== VerticalAlign.Top) {
    const height = estimateWrappedTextHeight(wrappedText);
    const dy = options.verticalAlign === VerticalAlign.Middle ? -height / 2 : options.verticalAlign === VerticalAlign.Bottom ? -height : 0;
    y25 += dy;
  }
  if (options.textRotationAngle) {
    textElement.setAttribute("transform", `rotate(${options.textRotationAngle === 0 || options.textRotationAngle ? options.textRotationAngle : 0} ${x21} ${y25})`);
  } else {
    textElement.removeAttribute("transform");
  }
  if (!trimmed) {
    const parser = new DOMParser();
    textElement.textContent = "";
    wrappedText.forEach((block) => {
      const svgCode = renderTextToTspanStrings([block], x21, y25).join("");
      const svgCodeSanitized = (0, import_striptags.default)(svgCode, allowedSvgTextTags);
      const parsedSvgCode = parser.parseFromString(svgCodeSanitized, "image/svg+xml").firstChild;
      textElement.appendChild(parsedSvgCode);
    });
  }
}
function renderTextIntoFrame(group3, text, frameOptions) {
  var _a, _b;
  const wrappedText = getWrappedText(text, frameOptions.width, frameOptions.height, frameOptions.fastMode, frameOptions.separator, frameOptions.wordBreak);
  const x21 = frameOptions.textAlign === TextAlign.Center ? frameOptions.width / 2 : frameOptions.textAlign === TextAlign.Right ? frameOptions.width : 0;
  let y25 = 0;
  const height = estimateWrappedTextHeight(wrappedText);
  const dh = frameOptions.height - height;
  y25 = frameOptions.verticalAlign === VerticalAlign.Middle ? dh / 2 : frameOptions.verticalAlign === VerticalAlign.Bottom ? dh : 0;
  const translate = frameOptions.x || frameOptions.y ? `transform="translate(${(_a = frameOptions.x) !== null && _a !== void 0 ? _a : 0},${(_b = frameOptions.y) !== null && _b !== void 0 ? _b : 0})"` : "";
  const svgCode = `<text
    xmlns="http://www.w3.org/2000/svg"
    text-anchor="${getTextAnchorFromTextAlign(frameOptions.textAlign)}"
    ${translate}
  >
    ${renderTextToTspanStrings(wrappedText, x21, y25).join("")}
  </text>`;
  const parser = new DOMParser();
  const svgCodeSanitized = (0, import_striptags.default)(svgCode, allowedSvgTextTags);
  const parsedSvgCode = parser.parseFromString(svgCodeSanitized, "image/svg+xml").firstChild;
  group3.textContent = "";
  group3.appendChild(parsedSvgCode);
}

// node_modules/@unovis/ts/components/axis/config.js
var AxisDefaultConfig = Object.assign(Object.assign({}, XYComponentDefaultConfig), { position: void 0, type: void 0, label: void 0, labelFontSize: null, labelTextFitMode: FitMode.Wrap, labelTextTrimType: TrimMode.Middle, gridLine: true, tickLine: true, domainLine: true, numTicks: void 0, minMaxTicksOnly: false, minMaxTicksOnlyWhenWidthIsLess: 250, tickTextWidth: void 0, tickTextSeparator: void 0, tickTextForceWordBreak: false, tickTextTrimType: TrimMode.Middle, tickTextFitMode: FitMode.Wrap, tickTextFontSize: null, tickTextAlign: void 0, tickTextColor: null, tickTextAngle: void 0, labelMargin: 8, labelColor: null, tickFormat: void 0, tickValues: void 0, fullSize: true, tickPadding: 8, tickTextHideOverlapping: void 0 });

// node_modules/@unovis/ts/components/axis/style.js
var style_exports5 = {};
__export(style_exports5, {
  axis: () => axis2,
  cssVarDefaults: () => cssVarDefaults,
  grid: () => grid,
  hideDomain: () => hideDomain,
  hideTickLine: () => hideTickLine,
  label: () => label,
  root: () => root6,
  tick: () => tick,
  tickLabel: () => tickLabel,
  tickLabelHideable: () => tickLabelHideable,
  variables: () => variables3
});

// node_modules/@unovis/ts/utils/style.js
function getCssVarNames(cssVarsObject, prefix) {
  const defaultPrefix = "--vis-";
  const entries = Object.entries(cssVarsObject);
  return Object.fromEntries(entries.map(([key]) => [kebabCaseToCamel(key.replace(prefix !== null && prefix !== void 0 ? prefix : defaultPrefix, "")), key]));
}
function injectGlobalCssVariables(cssVarsObject, componentRootClassName) {
  injectGlobal({
    ":root": cssVarsObject,
    [`body.theme-dark .${componentRootClassName}`]: Object.keys(cssVarsObject).filter((key) => key.includes("--vis-dark")).map((key) => ({
      [key.replace("--vis-dark", "--vis")]: `var(${key})`
    }))
  });
}
function cssvar(name2) {
  return `var(${name2})`;
}

// node_modules/@unovis/ts/components/axis/style.js
var root6 = css`
  label: axis-component;
`;
var cssVarDefaults = {
  // Undefined by default to allow proper fallback to var(--vis-font-family)
  /* --vis-axis-font-family: */
  "--vis-axis-tick-color": "#e8e9ef",
  /* --vis-axis-domain-color: // Undefined by default to allow fallback to var(--vis-axis-tick-color) */
  "--vis-axis-grid-color": "#e8e9ef",
  "--vis-axis-grid-line-width": "1px",
  "--vis-axis-grid-line-dasharray": "none",
  "--vis-axis-label-font-size": "14px",
  "--vis-axis-label-color": "#6c778c",
  "--vis-axis-label-weight": "500",
  "--vis-axis-tick-label-color": "#6c778c",
  "--vis-axis-tick-label-font-size": "12px",
  "--vis-axis-tick-label-weight": "500",
  "--vis-axis-tick-label-cursor": "default",
  "--vis-axis-tick-label-text-decoration": "none",
  "--vis-axis-tick-line-width": "1px",
  "--vis-axis-tick-label-hide-transition": "opacity 400ms ease-in-out",
  /* --vis-axis-domain-line-width: // Undefined by default to allow fallback to var(--vis-axis-grid-line-width) */
  "--vis-dark-axis-tick-color": "#6c778c",
  /* --vis-dark-axis-domain-color: // Undefined by default to allow fallback to var(--vis-dark-axis-tick-color) */
  "--vis-dark-axis-tick-label-color": "#e8e9ef",
  "--vis-dark-axis-grid-color": "#6c778c",
  "--vis-dark-axis-label-color": "#fefefe"
};
var variables3 = getCssVarNames(cssVarDefaults);
injectGlobalCssVariables(cssVarDefaults, root6);
var hideTickLine = css`
  label: hide-tick-line;
`;
var hideDomain = css`
  label: hide-domain;
`;
var axis2 = css`
  label: axis;

  user-select: none;

  .domain {
    stroke: var(--vis-axis-domain-color, var(--vis-axis-tick-color));
    stroke-width: var(--vis-axis-domain-line-width, var(--vis-axis-grid-line-width));
    stroke-dasharray: var(--vis-axis-domain-line-dasharray, var(--vis-axis-grid-line-dasharray));
  }

  &${`.${hideTickLine}`} {
    .tick > line {
      opacity: 0;
    }
  }

  &${`.${hideDomain}`} {
    .domain {
      opacity: 0;
    }
  }
`;
var grid = css`
  label: grid;

  .domain {
    opacity: 0;
  }

  line {
    stroke: var(--vis-axis-grid-color);
    stroke-width: var(--vis-axis-grid-line-width);
    stroke-dasharray: var(--vis-axis-grid-line-dasharray);
  }
`;
var tick = css`
  label: tick;

  stroke: none;
  font-size: var(--vis-axis-tick-label-font-size);
  font-weight: var(--vis-axis-tick-label-weight);

  line {
    stroke: var(--vis-axis-tick-color);
    stroke-width: var(--vis-axis-tick-line-width);
  }

  text {
    fill: var(--vis-axis-tick-label-color);
    cursor: var(--vis-axis-tick-label-cursor);
    font-family: var(--vis-axis-font-family, var(--vis-font-family));
    text-decoration: var(--vis-axis-tick-label-text-decoration);
    stroke: none;
  }
`;
var label = css`
  label: label;
  fill: var(--vis-axis-label-color);
  font-size: var(--vis-axis-label-font-size);
  font-weight: var(--vis-axis-label-weight);
  font-family: var(--vis-axis-font-family, var(--vis-font-family));
  text-anchor: middle;
`;
var tickLabel = css`
  label: tick-label;
`;
var tickLabelHideable = css`
  label: tick-label-hideable;
  opacity: 0;
  transition: var(--vis-axis-tick-label-hide-transition);
`;

// node_modules/@unovis/ts/components/axis/index.js
var Axis = class extends XYComponentCore {
  constructor(config) {
    super();
    this._defaultConfig = AxisDefaultConfig;
    this.config = this._defaultConfig;
    this._defaultNumTicks = 3;
    this.events = {};
    if (config)
      this.setConfig(config);
    this.axisGroup = this.g.append("g");
    this.gridGroup = this.g.append("g").attr("class", grid);
  }
  /** Renders axis to an invisible grouped to calculate automatic chart margins */
  preRender() {
    const { config } = this;
    const axisRenderHelperGroup = this.g.append("g").attr("opacity", 0);
    this._renderAxis(axisRenderHelperGroup, 0);
    this._axisRawBBox = axisRenderHelperGroup.node().getBBox();
    if (config.tickTextAlign)
      this._alignTickLabels();
    this._renderAxisLabel(axisRenderHelperGroup);
    this._axisSizeBBox = this._getAxisSize(axisRenderHelperGroup);
    this._requiredMargin = this._getRequiredMargin(this._axisSizeBBox);
    axisRenderHelperGroup.remove();
  }
  getPosition() {
    const { config: { type: type2, position } } = this;
    return position !== null && position !== void 0 ? position : type2 === AxisType.X ? Position.Bottom : Position.Left;
  }
  _getAxisSize(selection2) {
    const bBox = selection2.node().getBBox();
    return bBox;
  }
  _getRequiredMargin(axisSize = this._axisSizeBBox) {
    const { config: { type: type2, position } } = this;
    switch (type2) {
      case AxisType.X: {
        const tolerancePx = 1;
        const xEnd = this._axisSizeBBox.x + this._axisSizeBBox.width;
        const left3 = this._axisSizeBBox.x < 0 ? Math.abs(this._axisSizeBBox.x) : 0;
        const right3 = xEnd - this._width > tolerancePx ? xEnd - this._width : 0;
        switch (position) {
          case Position.Top:
            return { top: axisSize.height, left: left3, right: right3 };
          case Position.Bottom:
          default:
            return { bottom: axisSize.height, left: left3, right: right3 };
        }
      }
      case AxisType.Y: {
        const bleedY = axisSize.height > this._height ? (axisSize.height - this._height) / 2 : 0;
        const top2 = bleedY;
        const bottom2 = bleedY;
        switch (position) {
          case Position.Right:
            return { right: axisSize.width, top: top2, bottom: bottom2 };
          case Position.Left:
          default:
            return { left: axisSize.width, top: top2, bottom: bottom2 };
        }
      }
    }
  }
  getRequiredMargin() {
    return this._requiredMargin;
  }
  /** Calculates axis transform:translate offset based on passed container margins */
  getOffset(containerMargin) {
    const { config: { type: type2, position } } = this;
    switch (type2) {
      case AxisType.X:
        switch (position) {
          case Position.Top:
            return { top: containerMargin.top, left: containerMargin.left };
          case Position.Bottom:
          default:
            return { top: containerMargin.top + this._height, left: containerMargin.left };
        }
      case AxisType.Y:
        switch (position) {
          case Position.Right:
            return { top: containerMargin.top, left: containerMargin.left + this._width };
          case Position.Left:
          default:
            return { top: containerMargin.top, left: containerMargin.left };
        }
    }
  }
  _render(duration = this.config.duration, selection2 = this.axisGroup) {
    const { config } = this;
    this._renderAxis(selection2, duration);
    this._renderAxisLabel(selection2);
    if (config.gridLine) {
      const gridGen = this._buildGrid().tickFormat(() => "");
      gridGen.tickValues(this._getConfiguredTickValues());
      this.gridGroup.selectAll("*").interrupt();
      smartTransition(this.gridGroup, duration).call(gridGen).style("opacity", 1);
    } else {
      smartTransition(this.gridGroup, duration).style("opacity", 0);
    }
    if (config.tickTextAlign)
      this._alignTickLabels();
    this._resolveTickLabelOverlap(selection2);
  }
  _buildAxis() {
    const { config: { type: type2, position, tickPadding } } = this;
    const ticks2 = this._getNumTicks();
    switch (type2) {
      case AxisType.X:
        switch (position) {
          case Position.Top:
            return axisTop(this.xScale).ticks(ticks2).tickPadding(tickPadding);
          case Position.Bottom:
          default:
            return axisBottom(this.xScale).ticks(ticks2).tickPadding(tickPadding);
        }
      case AxisType.Y:
        switch (position) {
          case Position.Right:
            return axisRight(this.yScale).ticks(ticks2).tickPadding(tickPadding);
          case Position.Left:
          default:
            return axisLeft(this.yScale).ticks(ticks2).tickPadding(tickPadding);
        }
    }
  }
  _buildGrid() {
    const { config: { type: type2, position } } = this;
    const ticks2 = this._getNumTicks();
    switch (type2) {
      case AxisType.X:
        switch (position) {
          case Position.Top:
            return axisTop(this.xScale).ticks(ticks2 * 2).tickSize(-this._height).tickSizeOuter(0);
          case Position.Bottom:
          default:
            return axisBottom(this.xScale).ticks(ticks2 * 2).tickSize(-this._height).tickSizeOuter(0);
        }
      case AxisType.Y:
        switch (position) {
          case Position.Right:
            return axisRight(this.yScale).ticks(ticks2 * 2).tickSize(-this._width).tickSizeOuter(0);
          case Position.Left:
          default:
            return axisLeft(this.yScale).ticks(ticks2 * 2).tickSize(-this._width).tickSizeOuter(0);
        }
    }
  }
  _renderAxis(selection2 = this.axisGroup, duration = this.config.duration) {
    const { config } = this;
    const axisGen = this._buildAxis();
    const tickValues = this._getConfiguredTickValues() || axisGen.scale().ticks(this._getNumTicks());
    axisGen.tickValues(tickValues);
    selection2.selectAll("*").interrupt();
    smartTransition(selection2, duration).call(axisGen);
    const ticks2 = selection2.selectAll("g.tick");
    ticks2.classed(tick, true).style("font-size", config.tickTextFontSize);
    const tickText = selection2.selectAll("g.tick > text").filter((tickValue) => tickValues.some((t4) => isEqual(tickValue, t4))).classed(tickLabel, true).classed(tickLabelHideable, Boolean(config.tickTextHideOverlapping)).style("fill", config.tickTextColor);
    tickText.nodes().forEach((node4) => interrupt_default(node4));
    tickText.each((value2, i8, elements) => {
      var _a, _b;
      let text = (_b = (_a = config.tickFormat) === null || _a === void 0 ? void 0 : _a.call(config, value2, i8, tickValues)) !== null && _b !== void 0 ? _b : `${value2}`;
      const textElement = elements[i8];
      const textMaxWidth = config.tickTextWidth || (config.type === AxisType.X ? this._containerWidth / (ticks2.size() + 1) : this._containerWidth / 5);
      const styleDeclaration = getComputedStyle(textElement);
      const fontSize = Number.parseFloat(styleDeclaration.fontSize);
      const fontFamily = styleDeclaration.fontFamily;
      const textOptions = {
        verticalAlign: config.type === AxisType.X ? VerticalAlign.Top : VerticalAlign.Middle,
        width: textMaxWidth,
        textRotationAngle: config.tickTextAngle,
        separator: config.tickTextSeparator,
        wordBreak: config.tickTextForceWordBreak
      };
      if (config.tickTextFitMode === FitMode.Trim) {
        const textElementSelection = select_default2(textElement).text(text);
        trimSVGText(textElementSelection, textMaxWidth, config.tickTextTrimType, true, fontSize, 0.58);
        text = select_default2(textElement).text();
      }
      const textBlock = { text, fontFamily, fontSize };
      renderTextToSvgTextElement(textElement, textBlock, textOptions);
    });
    selection2.classed(axis2, true).classed(hideTickLine, !config.tickLine).classed(hideDomain, !config.domainLine);
    if (config.fullSize) {
      const path3 = this._getFullDomainPath(0);
      smartTransition(selection2.select(".domain"), duration).attr("d", path3);
    }
  }
  _resolveTickLabelOverlap(selection2 = this.axisGroup) {
    const { config } = this;
    const tickTextSelection = selection2.selectAll("g.tick > text");
    if (!config.tickTextHideOverlapping) {
      tickTextSelection.style("opacity", null);
      return;
    }
    cancelAnimationFrame(this._collideTickLabelsAnimFrameId);
    this._collideTickLabelsAnimFrameId = requestAnimationFrame(() => {
      this._collideTickLabels(tickTextSelection);
    });
  }
  _collideTickLabels(selection2) {
    selection2.each((d18, i8, elements) => {
      const node4 = elements[i8];
      node4._visible = true;
    });
    const numIterations = 3;
    for (let i8 = 0; i8 < numIterations; i8 += 1) {
      selection2.each((d18, i9, elements) => {
        const label1 = elements[i9];
        const isLabel1Visible = label1._visible;
        if (!isLabel1Visible)
          return;
        const label1BoundingRect = label1.getBoundingClientRect();
        for (let j6 = i9 + 1; j6 < elements.length; j6 += 1) {
          if (i9 === j6)
            continue;
          const label22 = elements[j6];
          const isLabel2Visible = label22._visible;
          if (isLabel2Visible) {
            const label2BoundingRect = label22.getBoundingClientRect();
            const intersect2 = rectIntersect(label1BoundingRect, label2BoundingRect, -5);
            if (intersect2) {
              label22._visible = false;
              break;
            }
          }
        }
      });
    }
    selection2.each((d18, i8, elements) => {
      const label14 = elements[i8];
      select_default2(label14).style("opacity", label14._visible ? 1 : 0);
    });
  }
  _getNumTicks() {
    const { config: { type: type2, numTicks } } = this;
    if (numTicks)
      return numTicks;
    if (type2 === AxisType.X) {
      const xRange = this.xScale.range();
      const width = xRange[1] - xRange[0];
      return Math.floor(width / 175);
    }
    if (type2 === AxisType.Y) {
      const yRange = this.yScale.range();
      const height = Math.abs(yRange[0] - yRange[1]);
      return Math.pow(height, 0.85) / 25;
    }
    return this._defaultNumTicks;
  }
  _getConfiguredTickValues() {
    const { config } = this;
    const scale = config.type === AxisType.X ? this.xScale : this.yScale;
    const scaleDomain = scale === null || scale === void 0 ? void 0 : scale.domain();
    if (config.tickValues) {
      return config.tickValues.filter((v28) => v28 >= scaleDomain[0] && v28 <= scaleDomain[1]);
    }
    if (config.minMaxTicksOnly || config.type === AxisType.X && this._width < config.minMaxTicksOnlyWhenWidthIsLess) {
      return scaleDomain;
    }
    return null;
  }
  _getFullDomainPath(tickSize = 0) {
    const { config: { type: type2 } } = this;
    switch (type2) {
      case AxisType.X:
        return `M0.5, ${tickSize} V0.5 H${this._width + 0.5} V${tickSize}`;
      case AxisType.Y:
        return `M${-tickSize}, ${this._height + 0.5} H0.5 V0.5 H${-tickSize}`;
    }
  }
  _renderAxisLabel(selection2 = this.axisGroup) {
    var _a;
    const { type: type2, label: label$1, labelMargin, labelFontSize, labelTextFitMode } = this.config;
    selection2.selectAll(`.${label}`).remove();
    if (!label$1)
      return;
    const axisPosition = this.getPosition();
    const { width: axisWidth, height: axisHeight } = (_a = this._axisRawBBox) !== null && _a !== void 0 ? _a : selection2.node().getBBox();
    const rotation = type2 === AxisType.Y ? -90 : 0;
    const textElement = selection2.append("text").attr("class", label).attr("dy", `${this._getLabelDY()}em`).style("font-size", labelFontSize).style("fill", this.config.labelColor);
    textElement.text(label$1);
    if (labelTextFitMode === FitMode.Wrap) {
      const maxWidth = type2 === AxisType.Y ? this._height : this._width;
      wrapSVGText(textElement, maxWidth);
    }
    let labelWidth = axisWidth;
    let labelHeight = axisHeight;
    if (labelTextFitMode === FitMode.Wrap) {
      const labelBBox = textElement.node().getBBox();
      labelWidth = labelBBox.width;
      labelHeight = labelBBox.height;
    } else {
      const trimWidth = type2 === AxisType.X ? labelWidth : labelHeight;
      const styleDeclaration = getComputedStyle(textElement.node());
      const fontSize = Number.parseFloat(styleDeclaration.fontSize);
      trimSVGText(textElement, trimWidth, this.config.labelTextTrimType, true, fontSize);
      const trimmedBBox = textElement.node().getBBox();
      labelWidth = trimmedBBox.width;
      labelHeight = trimmedBBox.height;
    }
    const offsetX = type2 === AxisType.X ? this._width / 2 : type2 === AxisType.Y && labelTextFitMode === FitMode.Wrap ? axisPosition === Position.Left ? -labelHeight / 2 : 0 : Math.pow(-1, +(axisPosition === Position.Left)) * axisWidth;
    const offsetY = type2 === AxisType.Y ? this._height / 2 : type2 === AxisType.X && labelTextFitMode === FitMode.Wrap ? axisPosition === Position.Top ? -axisHeight - labelHeight / 2 : axisHeight : Math.pow(-1, +(axisPosition === Position.Top)) * axisHeight;
    const marginX = type2 === AxisType.X ? 0 : labelTextFitMode === FitMode.Wrap ? Math.pow(-1, +(axisPosition === Position.Left)) * (labelHeight / 2 + labelMargin * 2) : axisPosition === Position.Right ? labelMargin : -labelMargin;
    const marginY = type2 === AxisType.X ? Math.pow(-1, +(axisPosition === Position.Top)) * labelMargin : 0;
    textElement.attr("transform", `translate(${offsetX + marginX},${offsetY + marginY}) rotate(${rotation})`);
  }
  _getLabelDY() {
    const { type: type2, position } = this.config;
    switch (type2) {
      case AxisType.X:
        switch (position) {
          case Position.Top:
            return 0;
          case Position.Bottom:
          default:
            return 0.75;
        }
      case AxisType.Y:
        switch (position) {
          case Position.Right:
            return 0.75;
          case Position.Left:
          default:
            return -0.25;
        }
    }
  }
  _alignTickLabels() {
    const { config: { type: type2, tickTextAlign, tickTextAngle, position } } = this;
    const tickText = this.g.selectAll("g.tick > text");
    const textAnchor = textAlignToAnchor(tickTextAlign);
    const translateX2 = type2 === AxisType.X ? 0 : this._getYTickTextTranslate(tickTextAlign, position);
    const translateValue = tickTextAngle ? `translate(${translateX2},0) rotate(${tickTextAngle})` : `translate(${translateX2},0)`;
    tickText.attr("transform", translateValue).attr("text-anchor", textAnchor);
  }
  _getYTickTextTranslate(textAlign, axisPosition = Position.Left) {
    const defaultTickTextSpacingPx = 9;
    const width = this._axisRawBBox.width - defaultTickTextSpacingPx;
    switch (textAlign) {
      case TextAlign.Left:
        return axisPosition === Position.Left ? width * -1 : 0;
      case TextAlign.Right:
        return axisPosition === Position.Left ? 0 : width;
      case TextAlign.Center:
        return axisPosition === Position.Left ? width * -0.5 : width * 0.5;
      default:
        return 0;
    }
  }
};
Axis.selectors = style_exports5;

// node_modules/@unovis/ts/types/symbol.js
var SymbolType;
(function(SymbolType2) {
  SymbolType2["Circle"] = "circle";
  SymbolType2["Cross"] = "cross";
  SymbolType2["Diamond"] = "diamond";
  SymbolType2["Square"] = "square";
  SymbolType2["Star"] = "star";
  SymbolType2["Triangle"] = "triangle";
  SymbolType2["Wye"] = "wye";
})(SymbolType || (SymbolType = {}));
var Symbol3 = {
  [SymbolType.Circle]: circle_default,
  [SymbolType.Cross]: cross_default,
  [SymbolType.Diamond]: diamond_default,
  [SymbolType.Square]: square_default,
  [SymbolType.Star]: star_default,
  [SymbolType.Triangle]: triangle_default,
  [SymbolType.Wye]: wye_default
};

// node_modules/@unovis/ts/components/scatter/config.js
var ScatterDefaultConfig = Object.assign(Object.assign({}, XYComponentDefaultConfig), { color: (d18) => d18.color, size: 10, sizeScale: Scale.scaleSqrt(), sizeRange: void 0, shape: SymbolType.Circle, label: void 0, labelColor: void 0, labelPosition: Position.Bottom, labelHideOverlapping: true, cursor: null, labelTextBrightnessRatio: 0.65, strokeColor: void 0, strokeWidth: void 0 });

// node_modules/@unovis/ts/components/scatter/modules/utils.js
function isLabelPositionCenter(labelPosition) {
  return labelPosition !== Position.Top && labelPosition !== Position.Bottom && labelPosition !== Position.Left && labelPosition !== Position.Right;
}
function getCentralLabelFontSize(pointDiameter, textLength) {
  return textLength ? 0.7 * pointDiameter / Math.pow(textLength, 0.5) : 0;
}
function getLabelShift(labelPosition, pointDiameter, labelPadding = 5) {
  switch (labelPosition) {
    case Position.Top:
      return [0, -pointDiameter / 2 - labelPadding];
    case Position.Bottom:
      return [0, pointDiameter / 2 + labelPadding];
    case Position.Left:
      return [-pointDiameter / 2 - labelPadding, 0];
    case Position.Right:
      return [pointDiameter / 2 + labelPadding, 0];
    default:
      return [0, 0];
  }
}
function getEstimatedLabelBBox(d18, labelPosition, xScale, yScale, fontSizePx) {
  var _a;
  const x21 = xScale(d18._point.xValue);
  const y25 = yScale(d18._point.yValue);
  const pointDiameter = d18._point.sizePx;
  const pointLabelText = (_a = d18._point.label) !== null && _a !== void 0 ? _a : "";
  const textLength = pointLabelText.length;
  const centralLabelFontSize = getCentralLabelFontSize(pointDiameter, textLength);
  const width = estimateStringPixelLength(pointLabelText, isLabelPositionCenter(labelPosition) ? centralLabelFontSize : fontSizePx, 0.6);
  const height = fontSizePx;
  const labelShift = getLabelShift(labelPosition, pointDiameter);
  const dx = labelPosition === Position.Left ? -width : labelPosition === Position.Right ? 0 : -width / 2;
  const dy = labelPosition === Position.Top ? -height : labelPosition === Position.Bottom ? 0 : -height / 2;
  const bbox = {
    x: x21 + labelShift[0] + dx,
    y: y25 + labelShift[1] + dy,
    width,
    height
  };
  return bbox;
}
function collideLabels(selection2, config, xScale, yScale) {
  selection2.each((datum1, i8, elements) => {
    const node4 = elements[i8];
    node4._labelVisible = true;
  });
  selection2.each((datum1, i8, elements) => {
    var _a, _b;
    const group1Node = elements[i8];
    const label1Position = getValue(datum1, config.labelPosition, datum1._point.pointIndex);
    if (!group1Node._labelVisible || isLabelPositionCenter(label1Position))
      return;
    const label1 = select_default2(group1Node).select("text");
    const label1FontSize = Number.parseFloat((_a = window.getComputedStyle(label1.node())) === null || _a === void 0 ? void 0 : _a.fontSize);
    const label1BoundingRect = getEstimatedLabelBBox(datum1, label1Position, xScale, yScale, label1FontSize);
    for (let j6 = 0; j6 < elements.length; j6 += 1) {
      if (i8 === j6)
        continue;
      const group2Node = elements[j6];
      const group22 = select_default2(group2Node);
      const label22 = group22.select("text");
      const datum2 = group22.datum();
      const p2Pos = [xScale(datum2._point.xValue), yScale(datum2._point.yValue)];
      const p2Radius = datum2._point.sizePx / 2;
      const point2BoundingRect = {
        x: p2Pos[0] - p2Radius,
        y: p2Pos[1] - p2Radius,
        width: 2 * p2Radius,
        height: 2 * p2Radius
      };
      let intersect2 = rectIntersect(label1BoundingRect, point2BoundingRect, 2);
      const label2Visible = group2Node._labelVisible;
      if (!intersect2 && label2Visible) {
        const label2FontSize = Number.parseFloat((_b = window.getComputedStyle(label22.node())) === null || _b === void 0 ? void 0 : _b.fontSize);
        const label2Position = getValue(datum2, config.labelPosition, datum2._point.pointIndex);
        const label2BoundingRect = getEstimatedLabelBBox(datum2, label2Position, xScale, yScale, label2FontSize);
        intersect2 = rectIntersect(label1BoundingRect, label2BoundingRect, 0.25);
      }
      if (intersect2) {
        if (group1Node._forceShowLabel)
          group2Node._labelVisible = false;
        else {
          group1Node._labelVisible = false;
          break;
        }
      }
    }
  });
  selection2.each((datum1, i8, elements) => {
    const node4 = elements[i8];
    const label14 = select_default2(node4).select("text");
    label14.attr("opacity", node4._labelVisible ? 1 : 0);
  });
}

// node_modules/@unovis/ts/components/scatter/modules/point.js
function createPoints(selection2, xScale, yScale) {
  selection2.attr("transform", (d18) => `translate(${d18._point.xValue},${d18._point.yValue})`);
  selection2.append("path").style("fill", (d18) => d18._point.color);
  selection2.append("text").style("pointer-events", "none");
  selection2.attr("transform", (d18) => `translate(${xScale(d18._point.xValue)},${yScale(d18._point.yValue)}) scale(0)`);
}
function updatePoints(selection2, config, xScale, yScale, duration) {
  const symbolGenerator = Symbol2();
  selection2.each((d18, index3, elements) => {
    var _a, _b, _c, _d;
    const group3 = select_default2(elements[index3]);
    const label14 = group3.select("text");
    const path3 = group3.select("path");
    const pointDiameter = d18._point.sizePx;
    const pointColor = d18._point.color;
    const pointStrokeColor = (_a = d18._point.strokeColor) !== null && _a !== void 0 ? _a : null;
    const pointStrokeWidth = (_b = d18._point.strokeWidthPx) !== null && _b !== void 0 ? _b : null;
    path3.attr("d", () => {
      const svgPath = d18._point.shape ? symbolGenerator.size(Math.PI * pointDiameter * pointDiameter / 4).type(Symbol3[d18._point.shape])() : null;
      return svgPath;
    });
    smartTransition(path3, duration).style("fill", pointColor).style("stroke", pointStrokeColor).style("stroke-width", `${pointStrokeWidth}px`);
    const labelPosition = d18._point.labelPosition;
    const isLabelPositionCenter2 = labelPosition !== Position.Top && labelPosition !== Position.Bottom && labelPosition !== Position.Left && labelPosition !== Position.Right;
    const pointLabelText = (_c = d18._point.label) !== null && _c !== void 0 ? _c : "";
    const textLength = pointLabelText.length;
    const centralLabelFontSize = getCentralLabelFontSize(pointDiameter, textLength);
    let labelColor = d18._point.labelColor;
    if (!labelColor && isLabelPositionCenter2) {
      const c6 = pointColor || "var(--vis-scatter-fill-color)";
      const hex2 = (_d = color(isStringCSSVariable(c6) ? getCSSVariableValue(c6, group3.node()) : c6)) === null || _d === void 0 ? void 0 : _d.hex();
      const brightness = hexToBrightness(hex2);
      labelColor = brightness > config.labelTextBrightnessRatio ? "var(--vis-scatter-point-label-text-color-dark)" : "var(--vis-scatter-point-label-text-color-light)";
    }
    const labelShift = getLabelShift(labelPosition, pointDiameter);
    label14.html(pointLabelText).attr("x", labelShift[0]).attr("y", labelShift[1]).style("font-size", isLabelPositionCenter2 ? centralLabelFontSize : null).style("text-anchor", () => {
      switch (labelPosition) {
        case Position.Right:
          return null;
        case Position.Left:
          return "end";
        default:
          return "middle";
      }
    }).style("dominant-baseline", () => {
      switch (labelPosition) {
        case Position.Top:
          return null;
        case Position.Bottom:
          return "hanging";
        default:
          return "central";
      }
    });
    smartTransition(label14, duration).style("fill", labelColor);
    path3.style("cursor", d18._point.cursor);
  });
  smartTransition(selection2, duration).attr("transform", (d18) => `translate(${xScale(d18._point.xValue)},${yScale(d18._point.yValue)}) scale(1)`);
}
function removePoints(selection2, xScale, yScale, duration) {
  smartTransition(selection2, duration).attr("transform", (d18) => `translate(${xScale(d18._point.xValue)},${yScale(d18._point.yValue)}) scale(0)`).remove();
}

// node_modules/@unovis/ts/components/scatter/style.js
var style_exports6 = {};
__export(style_exports6, {
  globalStyles: () => globalStyles4,
  point: () => point6,
  pointGroup: () => pointGroup,
  pointGroupExit: () => pointGroupExit,
  root: () => root7
});
var globalStyles4 = injectGlobal`
  :root {
    --vis-scatter-cursor: default;
    --vis-scatter-fill-color: var(--vis-color-main);
    --vis-scatter-stroke-color: 'none';
    --vis-scatter-stroke-width: 1px;
    --vis-scatter-fill-opacity: 1;
    --vis-scatter-stroke-opacity: 1;
    --vis-scatter-hover-stroke-width: 2px;

    --vis-scatter-point-label-text-color-dark: #5b5f6d;
    --vis-scatter-point-label-text-color-light: #fff;
    --vis-scatter-point-label-text-font-weight: 500;
    --vis-scatter-point-label-text-font-size: 12px;
    // Undefined by default to allow proper fallback to var(--vis-font-family)
    /* --vis-scatter-point-label-text-font-family: */
  }
`;
var root7 = css`
  label: scatter-component;
`;
var pointGroup = css`
  label: point-group;
`;
var pointGroupExit = css`
  label: point-group-exit;
`;
var point6 = css`
  label: point;

  > path {
    cursor: var(--vis-scatter-cursor);
    fill: var(--vis-scatter-fill-color);
    fill-opacity: var(--vis-scatter-fill-opacity);
    stroke-opacity: var(--vis-scatter-stroke-opacity);
    stroke-width: var(--vis-scatter-stroke-width);
    stroke: var(--vis-scatter-stroke-color);

    &:hover {
        stroke-width: var(--vis-scatter-hover-stroke-width);
    }
  }

  > text {
    font-weight: var(--vis-scatter-point-label-text-font-weight);
    font-size: var(--vis-scatter-point-label-text-font-size);
    font-family: var(--vis-scatter-point-label-text-font-family, var(--vis-font-family));
    fill: var(--vis-scatter-point-label-text-color-dark);
    user-select: none;
  }
`;

// node_modules/@unovis/ts/components/scatter/index.js
var Scatter = class _Scatter extends XYComponentCore {
  constructor(config) {
    super();
    this._defaultConfig = ScatterDefaultConfig;
    this.config = this._defaultConfig;
    this.events = {
      [_Scatter.selectors.point]: {
        mouseenter: this._onPointMouseOver.bind(this),
        mouseleave: this._onPointMouseOut.bind(this)
      }
    };
    this._pointData = [];
    if (config)
      this.setConfig(config);
  }
  setConfig(config) {
    super.setConfig(config);
    this._updateSizeScale();
  }
  setData(data) {
    super.setData(data);
    this._updateSizeScale();
  }
  get bleed() {
    this._pointData = this._getOnScreenData();
    const pointDataFlat = flatten(this._pointData);
    const yRangeStart = min(this.yScale.range());
    const yRangeEnd = max(this.yScale.range());
    const xRangeStart = this.xScale.range()[0];
    const xRangeEnd = this.xScale.range()[1];
    const fontSizePx = getCSSVariableValueInPixels("var(--vis-scatter-point-label-text-font-size)", this.element);
    const extent2 = pointDataFlat.reduce((ext, d18) => {
      const x21 = this.xScale(d18._point.xValue);
      const y25 = this.yScale(d18._point.yValue);
      const r4 = d18._point.sizePx / 2;
      ext.minX = Math.min(ext.minX, x21 - r4);
      ext.maxX = Math.max(ext.maxX, x21 + r4);
      ext.minY = Math.min(ext.minY, y25 - r4);
      ext.maxY = Math.max(ext.maxY, y25 + r4);
      if (d18._point.label) {
        const labelBBox = getEstimatedLabelBBox(d18, d18._point.labelPosition, this.xScale, this.yScale, fontSizePx);
        ext.minX = Math.min(ext.minX, labelBBox.x);
        ext.maxX = Math.max(ext.maxX, labelBBox.x + labelBBox.width);
        ext.minY = Math.min(ext.minY, labelBBox.y);
        ext.maxY = Math.max(ext.maxY, labelBBox.y + labelBBox.height);
      }
      return ext;
    }, {
      minX: Number.POSITIVE_INFINITY,
      maxX: Number.NEGATIVE_INFINITY,
      minY: Number.POSITIVE_INFINITY,
      maxY: Number.NEGATIVE_INFINITY
    });
    const coeff = 1.2;
    const top2 = extent2.minY < yRangeStart ? coeff * (yRangeStart - extent2.minY) : 0;
    const bottom2 = extent2.maxY > yRangeEnd ? coeff * (extent2.maxY - yRangeEnd) : 0;
    const left3 = extent2.minX < xRangeStart ? coeff * (xRangeStart - extent2.minX) : 0;
    const right3 = extent2.maxX > xRangeEnd ? coeff * (extent2.maxX - xRangeEnd) : 0;
    return { top: top2, bottom: bottom2, left: left3, right: right3 };
  }
  _render(customDuration) {
    const { config } = this;
    const duration = isNumber(customDuration) ? customDuration : config.duration;
    const pointGroups = this.g.selectAll(`.${pointGroup}`).data(this._pointData);
    const pointGroupsEnter = pointGroups.enter().append("g").attr("class", pointGroup);
    const pointGroupsMerged = pointGroupsEnter.merge(pointGroups);
    smartTransition(pointGroupsMerged, duration).style("opacity", 1);
    const pointGroupExit$1 = pointGroups.exit().attr("class", pointGroupExit);
    smartTransition(pointGroupExit$1, duration).style("opacity", 0).remove();
    const points3 = pointGroupsMerged.selectAll(`.${point6}`).data((d18) => d18, (d18) => {
      var _a;
      return `${(_a = getString(d18, config.id, d18._point.pointIndex)) !== null && _a !== void 0 ? _a : d18._point.pointIndex}`;
    });
    const pointsEnter = points3.enter().append("g").attr("class", point6);
    createPoints(pointsEnter, this.xScale, this.yScale);
    this._points = pointsEnter.merge(points3);
    updatePoints(this._points, config, this.xScale, this.yScale, duration);
    removePoints(points3.exit(), this.xScale, this.yScale, duration);
    if (this._hasLabels()) {
      this._resolveLabelOverlap();
    }
  }
  _hasLabels() {
    if (!this.config.label)
      return false;
    const pointDataFlat = flatten(this._pointData);
    return pointDataFlat.some((d18) => d18._point.label);
  }
  _resolveLabelOverlap() {
    if (!this.config.labelHideOverlapping) {
      const label14 = this._points.selectAll("text");
      label14.attr("opacity", null);
      return;
    }
    cancelAnimationFrame(this._collideLabelsAnimFrameId);
    this._collideLabelsAnimFrameId = requestAnimationFrame(() => {
      collideLabels(this._points, this.config, this.xScale, this.yScale);
    });
  }
  _updateSizeScale() {
    var _a;
    const { config, datamodel } = this;
    this._sizeScale = config.sizeScale.copy();
    this._sizeScale.domain(getExtent(datamodel.data, config.size));
    this._sizeScale.range((_a = config.sizeRange) !== null && _a !== void 0 ? _a : [0, 0]);
  }
  _getOnScreenData() {
    const { config, datamodel: { data } } = this;
    const xDomain = this.xScale.domain().map((d18) => +d18);
    const yDomain = this.yScale.domain().map((d18) => +d18);
    const yAccessors = isArray(config.y) ? config.y : [config.y];
    const maxSizeValue = max(flatten(yAccessors.map((y25, j6) => data === null || data === void 0 ? void 0 : data.map((d18) => getNumber(d18, config.size, j6)))));
    const maxSizePx = config.sizeRange ? this._sizeScale(maxSizeValue) : maxSizeValue;
    const maxSizeXDomain = this.xScale.invert(maxSizePx) - this.xScale.invert(0);
    const maxSizeYDomain = Math.abs(this.yScale.invert(maxSizePx) - this.yScale.invert(0));
    return yAccessors.map((y25, j6) => {
      var _a;
      return (_a = data === null || data === void 0 ? void 0 : data.reduce((acc, d18, i8) => {
        const xValue = getNumber(d18, config.x, i8);
        const yValue = getNumber(d18, y25, j6);
        const pointSize = getNumber(d18, config.size, i8);
        const pointSizeScaled = config.sizeRange ? this._sizeScale(pointSize) : pointSize;
        const pointSizeXDomain = this.xScale.invert(pointSizeScaled) - this.xScale.invert(0);
        const pointSizeYDomain = Math.abs(this.yScale.invert(pointSizeScaled) - this.yScale.invert(0));
        if (xValue - pointSizeXDomain / 2 >= xDomain[0] - maxSizeXDomain / 2 && xValue + pointSizeXDomain / 2 <= xDomain[1] + maxSizeXDomain / 2 && yValue - pointSizeYDomain / 2 >= yDomain[0] - maxSizeYDomain / 2 && yValue + pointSizeYDomain / 2 <= yDomain[1] + maxSizeYDomain / 2) {
          acc.push(Object.assign(Object.assign({}, d18), { _point: {
            xValue,
            yValue,
            sizePx: pointSizeScaled,
            color: getColor(d18, config.color, j6),
            strokeColor: getColor(d18, config.strokeColor, j6, true),
            strokeWidthPx: getNumber(d18, config.strokeWidth, j6),
            shape: getString(d18, config.shape, j6),
            label: getString(d18, config.label, j6),
            labelColor: getColor(d18, config.labelColor, j6, true),
            labelPosition: getValue(d18, config.labelPosition, i8),
            cursor: getString(d18, config.cursor, j6),
            groupIndex: j6,
            pointIndex: i8
          } }));
        }
        return acc;
      }, [])) !== null && _a !== void 0 ? _a : [];
    });
  }
  _onPointMouseOver(d18, event) {
    const point13 = select_default2(event.target);
    const pointNode = point13.node();
    if (pointNode)
      pointNode._forceShowLabel = true;
    point13.raise();
    this._resolveLabelOverlap();
  }
  _onPointMouseOut(d18, event) {
    const pointNode = select_default2(event.target).node();
    if (pointNode)
      delete pointNode._forceShowLabel;
    this._resolveLabelOverlap();
  }
};
Scatter.selectors = style_exports6;

// node_modules/d3-drag/src/noevent.js
var nonpassive = { passive: false };
var nonpassivecapture = { capture: true, passive: false };
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent_default(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-drag/src/nodrag.js
function nodrag_default(view) {
  var root29 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
  if ("onselectstart" in root29) {
    selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
  } else {
    root29.__noselect = root29.style.MozUserSelect;
    root29.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root29 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent_default, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root29) {
    selection2.on("selectstart.drag", null);
  } else {
    root29.style.MozUserSelect = root29.__noselect;
    delete root29.__noselect;
  }
}

// node_modules/d3-drag/src/constant.js
var constant_default4 = (x21) => () => x21;

// node_modules/d3-drag/src/event.js
function DragEvent(type2, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x: x21,
  y: y25,
  dx,
  dy,
  dispatch
}) {
  Object.defineProperties(this, {
    type: { value: type2, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    subject: { value: subject, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    identifier: { value: identifier, enumerable: true, configurable: true },
    active: { value: active, enumerable: true, configurable: true },
    x: { value: x21, enumerable: true, configurable: true },
    y: { value: y25, enumerable: true, configurable: true },
    dx: { value: dx, enumerable: true, configurable: true },
    dy: { value: dy, enumerable: true, configurable: true },
    _: { value: dispatch }
  });
}
DragEvent.prototype.on = function() {
  var value2 = this._.on.apply(this._, arguments);
  return value2 === this._ ? this : value2;
};

// node_modules/d3-drag/src/drag.js
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(event, d18) {
  return d18 == null ? { x: event.x, y: event.y } : d18;
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag_default() {
  var filter3 = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch_default("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
  function drag(selection2) {
    selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned(event, d18) {
    if (touchending || !filter3.call(this, event, d18)) return;
    var gesture = beforestart(this, container.call(this, event, d18), event, d18, "mouse");
    if (!gesture) return;
    select_default2(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
    nodrag_default(event.view);
    nopropagation(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }
  function mousemoved(event) {
    noevent_default(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }
  function mouseupped(event) {
    select_default2(event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(event.view, mousemoving);
    noevent_default(event);
    gestures.mouse("end", event);
  }
  function touchstarted(event, d18) {
    if (!filter3.call(this, event, d18)) return;
    var touches = event.changedTouches, c6 = container.call(this, event, d18), n = touches.length, i8, gesture;
    for (i8 = 0; i8 < n; ++i8) {
      if (gesture = beforestart(this, c6, event, d18, touches[i8].identifier, touches[i8])) {
        nopropagation(event);
        gesture("start", event, touches[i8]);
      }
    }
  }
  function touchmoved(event) {
    var touches = event.changedTouches, n = touches.length, i8, gesture;
    for (i8 = 0; i8 < n; ++i8) {
      if (gesture = gestures[touches[i8].identifier]) {
        noevent_default(event);
        gesture("drag", event, touches[i8]);
      }
    }
  }
  function touchended(event) {
    var touches = event.changedTouches, n = touches.length, i8, gesture;
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, 500);
    for (i8 = 0; i8 < n; ++i8) {
      if (gesture = gestures[touches[i8].identifier]) {
        nopropagation(event);
        gesture("end", event, touches[i8]);
      }
    }
  }
  function beforestart(that, container2, event, d18, identifier, touch) {
    var dispatch = listeners.copy(), p13 = pointer_default(touch || event, container2), dx, dy, s12;
    if ((s12 = subject.call(that, new DragEvent("beforestart", {
      sourceEvent: event,
      target: drag,
      identifier,
      active,
      x: p13[0],
      y: p13[1],
      dx: 0,
      dy: 0,
      dispatch
    }), d18)) == null) return;
    dx = s12.x - p13[0] || 0;
    dy = s12.y - p13[1] || 0;
    return function gesture(type2, event2, touch2) {
      var p0 = p13, n;
      switch (type2) {
        case "start":
          gestures[identifier] = gesture, n = active++;
          break;
        case "end":
          delete gestures[identifier], --active;
        // falls through
        case "drag":
          p13 = pointer_default(touch2 || event2, container2), n = active;
          break;
      }
      dispatch.call(
        type2,
        that,
        new DragEvent(type2, {
          sourceEvent: event2,
          subject: s12,
          target: drag,
          identifier,
          active: n,
          x: p13[0] + dx,
          y: p13[1] + dy,
          dx: p13[0] - p0[0],
          dy: p13[1] - p0[1],
          dispatch
        }),
        d18
      );
    };
  }
  drag.filter = function(_17) {
    return arguments.length ? (filter3 = typeof _17 === "function" ? _17 : constant_default4(!!_17), drag) : filter3;
  };
  drag.container = function(_17) {
    return arguments.length ? (container = typeof _17 === "function" ? _17 : constant_default4(_17), drag) : container;
  };
  drag.subject = function(_17) {
    return arguments.length ? (subject = typeof _17 === "function" ? _17 : constant_default4(_17), drag) : subject;
  };
  drag.touchable = function(_17) {
    return arguments.length ? (touchable = typeof _17 === "function" ? _17 : constant_default4(!!_17), drag) : touchable;
  };
  drag.on = function() {
    var value2 = listeners.on.apply(listeners, arguments);
    return value2 === listeners ? drag : value2;
  };
  drag.clickDistance = function(_17) {
    return arguments.length ? (clickDistance2 = (_17 = +_17) * _17, drag) : Math.sqrt(clickDistance2);
  };
  return drag;
}

// node_modules/d3-brush/src/constant.js
var constant_default5 = (x21) => () => x21;

// node_modules/d3-brush/src/event.js
function BrushEvent(type2, {
  sourceEvent,
  target,
  selection: selection2,
  mode,
  dispatch
}) {
  Object.defineProperties(this, {
    type: { value: type2, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    selection: { value: selection2, enumerable: true, configurable: true },
    mode: { value: mode, enumerable: true, configurable: true },
    _: { value: dispatch }
  });
}

// node_modules/d3-brush/src/noevent.js
function nopropagation2(event) {
  event.stopImmediatePropagation();
}
function noevent_default2(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-brush/src/brush.js
var MODE_DRAG = { name: "drag" };
var MODE_SPACE = { name: "space" };
var MODE_HANDLE = { name: "handle" };
var MODE_CENTER = { name: "center" };
var { abs: abs2, max: max3, min: min3 } = Math;
function number1(e3) {
  return [+e3[0], +e3[1]];
}
function number22(e3) {
  return [number1(e3[0]), number1(e3[1])];
}
var X = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x21, e3) {
    return x21 == null ? null : [[+x21[0], e3[0][1]], [+x21[1], e3[1][1]]];
  },
  output: function(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y25, e3) {
    return y25 == null ? null : [[e3[0][0], +y25[0]], [e3[1][0], +y25[1]]];
  },
  output: function(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function(xy) {
    return xy == null ? null : number22(xy);
  },
  output: function(xy) {
    return xy;
  }
};
var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};
var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};
var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};
var signsX = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
};
var signsY = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function type(t4) {
  return { type: t4 };
}
function defaultFilter2(event) {
  return !event.ctrlKey && !event.button;
}
function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  if (svg.hasAttribute("viewBox")) {
    svg = svg.viewBox.baseVal;
    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
  }
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}
function defaultTouchable2() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function local2(node4) {
  while (!node4.__brush) if (!(node4 = node4.parentNode)) return;
  return node4.__brush;
}
function empty2(extent2) {
  return extent2[0][0] === extent2[1][0] || extent2[0][1] === extent2[1][1];
}
function brushX() {
  return brush(X);
}
function brushY() {
  return brush(Y);
}
function brush_default() {
  return brush(XY);
}
function brush(dim2) {
  var extent2 = defaultExtent, filter3 = defaultFilter2, touchable = defaultTouchable2, keys = true, listeners = dispatch_default("start", "brush", "end"), handleSize = 6, touchending;
  function brush5(group3) {
    var overlay = group3.property("__brush", initialize).selectAll(".overlay").data([type("overlay")]);
    overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function() {
      var extent3 = local2(this).extent;
      select_default2(this).attr("x", extent3[0][0]).attr("y", extent3[0][1]).attr("width", extent3[1][0] - extent3[0][0]).attr("height", extent3[1][1] - extent3[0][1]);
    });
    group3.selectAll(".selection").data([type("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var handle = group3.selectAll(".handle").data(dim2.handles, function(d18) {
      return d18.type;
    });
    handle.exit().remove();
    handle.enter().append("rect").attr("class", function(d18) {
      return "handle handle--" + d18.type;
    }).attr("cursor", function(d18) {
      return cursors[d18.type];
    });
    group3.each(redraw).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", started).filter(touchable).on("touchstart.brush", started).on("touchmove.brush", touchmoved).on("touchend.brush touchcancel.brush", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  brush5.move = function(group3, selection2, event) {
    if (group3.tween) {
      group3.on("start.brush", function(event2) {
        emitter(this, arguments).beforestart().start(event2);
      }).on("interrupt.brush end.brush", function(event2) {
        emitter(this, arguments).end(event2);
      }).tween("brush", function() {
        var that = this, state = that.__brush, emit = emitter(that, arguments), selection0 = state.selection, selection1 = dim2.input(typeof selection2 === "function" ? selection2.apply(this, arguments) : selection2, state.extent), i8 = value_default(selection0, selection1);
        function tween(t4) {
          state.selection = t4 === 1 && selection1 === null ? null : i8(t4);
          redraw.call(that);
          emit.brush();
        }
        return selection0 !== null && selection1 !== null ? tween : tween(1);
      });
    } else {
      group3.each(function() {
        var that = this, args = arguments, state = that.__brush, selection1 = dim2.input(typeof selection2 === "function" ? selection2.apply(that, args) : selection2, state.extent), emit = emitter(that, args).beforestart();
        interrupt_default(that);
        state.selection = selection1 === null ? null : selection1;
        redraw.call(that);
        emit.start(event).brush(event).end(event);
      });
    }
  };
  brush5.clear = function(group3, event) {
    brush5.move(group3, null, event);
  };
  function redraw() {
    var group3 = select_default2(this), selection2 = local2(this).selection;
    if (selection2) {
      group3.selectAll(".selection").style("display", null).attr("x", selection2[0][0]).attr("y", selection2[0][1]).attr("width", selection2[1][0] - selection2[0][0]).attr("height", selection2[1][1] - selection2[0][1]);
      group3.selectAll(".handle").style("display", null).attr("x", function(d18) {
        return d18.type[d18.type.length - 1] === "e" ? selection2[1][0] - handleSize / 2 : selection2[0][0] - handleSize / 2;
      }).attr("y", function(d18) {
        return d18.type[0] === "s" ? selection2[1][1] - handleSize / 2 : selection2[0][1] - handleSize / 2;
      }).attr("width", function(d18) {
        return d18.type === "n" || d18.type === "s" ? selection2[1][0] - selection2[0][0] + handleSize : handleSize;
      }).attr("height", function(d18) {
        return d18.type === "e" || d18.type === "w" ? selection2[1][1] - selection2[0][1] + handleSize : handleSize;
      });
    } else {
      group3.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
    }
  }
  function emitter(that, args, clean2) {
    var emit = that.__brush.emitter;
    return emit && (!clean2 || !emit.clean) ? emit : new Emitter(that, args, clean2);
  }
  function Emitter(that, args, clean2) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
    this.clean = clean2;
  }
  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function(event, mode) {
      if (this.starting) this.starting = false, this.emit("start", event, mode);
      else this.emit("brush", event);
      return this;
    },
    brush: function(event, mode) {
      this.emit("brush", event, mode);
      return this;
    },
    end: function(event, mode) {
      if (--this.active === 0) delete this.state.emitter, this.emit("end", event, mode);
      return this;
    },
    emit: function(type2, event, mode) {
      var d18 = select_default2(this.that).datum();
      listeners.call(
        type2,
        this.that,
        new BrushEvent(type2, {
          sourceEvent: event,
          target: brush5,
          selection: dim2.output(this.state.selection),
          mode,
          dispatch: listeners
        }),
        d18
      );
    }
  };
  function started(event) {
    if (touchending && !event.touches) return;
    if (!filter3.apply(this, arguments)) return;
    var that = this, type2 = event.target.__data__.type, mode = (keys && event.metaKey ? type2 = "overlay" : type2) === "selection" ? MODE_DRAG : keys && event.altKey ? MODE_CENTER : MODE_HANDLE, signX = dim2 === Y ? null : signsX[type2], signY = dim2 === X ? null : signsY[type2], state = local2(that), extent3 = state.extent, selection2 = state.selection, W = extent3[0][0], w0, w1, N = extent3[0][1], n0, n1, E6 = extent3[1][0], e0, e1, S6 = extent3[1][1], s0, s1, dx = 0, dy = 0, moving, shifting = signX && signY && keys && event.shiftKey, lockX, lockY, points3 = Array.from(event.touches || [event], (t4) => {
      const i8 = t4.identifier;
      t4 = pointer_default(t4, that);
      t4.point0 = t4.slice();
      t4.identifier = i8;
      return t4;
    });
    interrupt_default(that);
    var emit = emitter(that, arguments, true).beforestart();
    if (type2 === "overlay") {
      if (selection2) moving = true;
      const pts = [points3[0], points3[1] || points3[0]];
      state.selection = selection2 = [[
        w0 = dim2 === Y ? W : min3(pts[0][0], pts[1][0]),
        n0 = dim2 === X ? N : min3(pts[0][1], pts[1][1])
      ], [
        e0 = dim2 === Y ? E6 : max3(pts[0][0], pts[1][0]),
        s0 = dim2 === X ? S6 : max3(pts[0][1], pts[1][1])
      ]];
      if (points3.length > 1) move(event);
    } else {
      w0 = selection2[0][0];
      n0 = selection2[0][1];
      e0 = selection2[1][0];
      s0 = selection2[1][1];
    }
    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;
    var group3 = select_default2(that).attr("pointer-events", "none");
    var overlay = group3.selectAll(".overlay").attr("cursor", cursors[type2]);
    if (event.touches) {
      emit.moved = moved;
      emit.ended = ended;
    } else {
      var view = select_default2(event.view).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
      if (keys) view.on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true);
      nodrag_default(event.view);
    }
    redraw.call(that);
    emit.start(event, mode.name);
    function moved(event2) {
      for (const p13 of event2.changedTouches || [event2]) {
        for (const d18 of points3)
          if (d18.identifier === p13.identifier) d18.cur = pointer_default(p13, that);
      }
      if (shifting && !lockX && !lockY && points3.length === 1) {
        const point13 = points3[0];
        if (abs2(point13.cur[0] - point13[0]) > abs2(point13.cur[1] - point13[1]))
          lockY = true;
        else
          lockX = true;
      }
      for (const point13 of points3)
        if (point13.cur) point13[0] = point13.cur[0], point13[1] = point13.cur[1];
      moving = true;
      noevent_default2(event2);
      move(event2);
    }
    function move(event2) {
      const point13 = points3[0], point0 = point13.point0;
      var t4;
      dx = point13[0] - point0[0];
      dy = point13[1] - point0[1];
      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX) dx = max3(W - w0, min3(E6 - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY) dy = max3(N - n0, min3(S6 - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (points3[1]) {
            if (signX) w1 = max3(W, min3(E6, points3[0][0])), e1 = max3(W, min3(E6, points3[1][0])), signX = 1;
            if (signY) n1 = max3(N, min3(S6, points3[0][1])), s1 = max3(N, min3(S6, points3[1][1])), signY = 1;
          } else {
            if (signX < 0) dx = max3(W - w0, min3(E6 - w0, dx)), w1 = w0 + dx, e1 = e0;
            else if (signX > 0) dx = max3(W - e0, min3(E6 - e0, dx)), w1 = w0, e1 = e0 + dx;
            if (signY < 0) dy = max3(N - n0, min3(S6 - n0, dy)), n1 = n0 + dy, s1 = s0;
            else if (signY > 0) dy = max3(N - s0, min3(S6 - s0, dy)), n1 = n0, s1 = s0 + dy;
          }
          break;
        }
        case MODE_CENTER: {
          if (signX) w1 = max3(W, min3(E6, w0 - dx * signX)), e1 = max3(W, min3(E6, e0 + dx * signX));
          if (signY) n1 = max3(N, min3(S6, n0 - dy * signY)), s1 = max3(N, min3(S6, s0 + dy * signY));
          break;
        }
      }
      if (e1 < w1) {
        signX *= -1;
        t4 = w0, w0 = e0, e0 = t4;
        t4 = w1, w1 = e1, e1 = t4;
        if (type2 in flipX) overlay.attr("cursor", cursors[type2 = flipX[type2]]);
      }
      if (s1 < n1) {
        signY *= -1;
        t4 = n0, n0 = s0, s0 = t4;
        t4 = n1, n1 = s1, s1 = t4;
        if (type2 in flipY) overlay.attr("cursor", cursors[type2 = flipY[type2]]);
      }
      if (state.selection) selection2 = state.selection;
      if (lockX) w1 = selection2[0][0], e1 = selection2[1][0];
      if (lockY) n1 = selection2[0][1], s1 = selection2[1][1];
      if (selection2[0][0] !== w1 || selection2[0][1] !== n1 || selection2[1][0] !== e1 || selection2[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush(event2, mode.name);
      }
    }
    function ended(event2) {
      nopropagation2(event2);
      if (event2.touches) {
        if (event2.touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() {
          touchending = null;
        }, 500);
      } else {
        yesdrag(event2.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group3.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection2 = state.selection;
      if (empty2(selection2)) state.selection = null, redraw.call(that);
      emit.end(event2, mode.name);
    }
    function keydowned(event2) {
      switch (event2.keyCode) {
        case 16: {
          shifting = signX && signY;
          break;
        }
        case 18: {
          if (mode === MODE_HANDLE) {
            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move(event2);
          }
          break;
        }
        case 32: {
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0) e0 = e1 - dx;
            else if (signX > 0) w0 = w1 - dx;
            if (signY < 0) s0 = s1 - dy;
            else if (signY > 0) n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move(event2);
          }
          break;
        }
        default:
          return;
      }
      noevent_default2(event2);
    }
    function keyupped(event2) {
      switch (event2.keyCode) {
        case 16: {
          if (shifting) {
            lockX = lockY = shifting = false;
            move(event2);
          }
          break;
        }
        case 18: {
          if (mode === MODE_CENTER) {
            if (signX < 0) e0 = e1;
            else if (signX > 0) w0 = w1;
            if (signY < 0) s0 = s1;
            else if (signY > 0) n0 = n1;
            mode = MODE_HANDLE;
            move(event2);
          }
          break;
        }
        case 32: {
          if (mode === MODE_SPACE) {
            if (event2.altKey) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0) e0 = e1;
              else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1;
              else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type2]);
            move(event2);
          }
          break;
        }
        default:
          return;
      }
      noevent_default2(event2);
    }
  }
  function touchmoved(event) {
    emitter(this, arguments).moved(event);
  }
  function touchended(event) {
    emitter(this, arguments).ended(event);
  }
  function initialize() {
    var state = this.__brush || { selection: null };
    state.extent = number22(extent2.apply(this, arguments));
    state.dim = dim2;
    return state;
  }
  brush5.extent = function(_17) {
    return arguments.length ? (extent2 = typeof _17 === "function" ? _17 : constant_default5(number22(_17)), brush5) : extent2;
  };
  brush5.filter = function(_17) {
    return arguments.length ? (filter3 = typeof _17 === "function" ? _17 : constant_default5(!!_17), brush5) : filter3;
  };
  brush5.touchable = function(_17) {
    return arguments.length ? (touchable = typeof _17 === "function" ? _17 : constant_default5(!!_17), brush5) : touchable;
  };
  brush5.handleSize = function(_17) {
    return arguments.length ? (handleSize = +_17, brush5) : handleSize;
  };
  brush5.keyModifiers = function(_17) {
    return arguments.length ? (keys = !!_17, brush5) : keys;
  };
  brush5.on = function() {
    var value2 = listeners.on.apply(listeners, arguments);
    return value2 === listeners ? brush5 : value2;
  };
  return brush5;
}

// node_modules/@unovis/ts/components/brush/config.js
var BrushDefaultConfig = Object.assign(Object.assign({}, XYComponentDefaultConfig), {
  /* eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function */
  onBrush: (s12, e3, userDriven) => {
  },
  /* eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function */
  onBrushStart: (s12, e3, userDriven) => {
  },
  /* eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function */
  onBrushMove: (s12, e3, userDriven) => {
  },
  /* eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function */
  onBrushEnd: (s12, e3, userDriven) => {
  },
  handleWidth: 9,
  selection: null,
  draggable: false,
  handlePosition: Arrangement.Inside,
  selectionMinLength: void 0
});

// node_modules/@unovis/ts/components/brush/types.js
var BrushDirection;
(function(BrushDirection2) {
  BrushDirection2["West"] = "w";
  BrushDirection2["East"] = "e";
})(BrushDirection || (BrushDirection = {}));

// node_modules/@unovis/ts/components/brush/style.js
var style_exports7 = {};
__export(style_exports7, {
  brush: () => brush2,
  cssVarDefaults: () => cssVarDefaults2,
  handleLine: () => handleLine,
  root: () => root8,
  unselected: () => unselected,
  variables: () => variables4
});
var root8 = css`
  label: brush-component;
`;
var cssVarDefaults2 = {
  "--vis-brush-selection-fill-color": "none",
  "--vis-brush-selection-stroke-color": "none",
  "--vis-brush-selection-stroke-width": "0",
  "--vis-brush-selection-opacity": "0",
  "--vis-brush-unselected-fill-color": "#0b1640",
  "--vis-brush-unselected-stroke-color": "#acb2b9",
  "--vis-brush-unselected-stroke-width": "0",
  "--vis-brush-unselected-opacity": "0.4",
  "--vis-brush-handle-fill-color": "#6d778c",
  "--vis-brush-handle-stroke-color": "#eee",
  /* Dark Theme */
  "--vis-dark-brush-selection-fill-color": "none",
  "--vis-dark-brush-selection-stroke-color": "none",
  "--vis-dark-brush-selection-stroke-width": "0",
  "--vis-dark-brush-selection-opacity": "0",
  "--vis-dark-brush-unselected-fill-color": "#acb2b9",
  "--vis-dark-brush-unselected-stroke-color": "#0b1640",
  "--vis-dark-brush-unselected-stroke-width": "0",
  "--vis-dark-brush-unselected-opacity": "0.4",
  "--vis-dark-brush-handle-fill-color": "#acb2b9",
  "--vis-dark-brush-handle-stroke-color": "var(--vis-color-grey)"
};
var variables4 = getCssVarNames(cssVarDefaults2);
injectGlobalCssVariables(cssVarDefaults2, root8);
var brush2 = css`
  label: brush;

  .selection {
    fill: var(${variables4.brushSelectionFillColor});
    stroke: var(${variables4.brushSelectionStrokeColor});
    stroke-width: var(${variables4.brushSelectionStrokeWidth});
    opacity: var(${variables4.brushSelectionOpacity});
  }

  .handle {
    fill: var(${variables4.brushHandleFillColor});
  }

  &.non-draggable {
    .selection, .overlay {
      pointer-events: none;
    }
  }
`;
var unselected = css`
  label: unselected;
  fill: var(${variables4.brushUnselectedFillColor});
  stroke: var(${variables4.brushUnselectedStrokeColor});
  stroke-width: var(${variables4.brushUnselectedStrokeWidth});
  stroke-opacity: var(${variables4.brushUnselectedOpacity});
  opacity: var(${variables4.brushUnselectedOpacity});
  pointer-events: none;
`;
var handleLine = css`
  label: handle-line;
  stroke: var(${variables4.brushHandleStrokeColor});
  stroke-width: 1;
  fill: none;
  pointer-events: none;
`;

// node_modules/@unovis/ts/components/brush/index.js
var Brush = class _Brush extends XYComponentCore {
  constructor(config) {
    super();
    this._defaultConfig = BrushDefaultConfig;
    this.clippable = false;
    this.config = this._defaultConfig;
    this.brushBehaviour = brushX();
    this.events = {
      [_Brush.selectors.brush]: {}
    };
    this._selection = null;
    this._firstRender = true;
    if (config)
      this.setConfig(config);
    const directions = [{ type: BrushDirection.West }, { type: BrushDirection.East }];
    this.unselectedRange = this.g.selectAll(`.${unselected}`).data(directions).enter().append("rect").attr("class", unselected);
    this.brush = this.g.append("g").attr("class", brush2);
    this.handleLines = this.g.selectAll(`.${handleLine}`).data(directions).enter().append("line").attr("class", handleLine);
  }
  _render(customDuration) {
    var _a, _b, _c, _d;
    const { brushBehaviour, config } = this;
    const duration = isNumber(customDuration) ? customDuration : config.duration;
    const xScale = this.xScale;
    brushBehaviour.extent([[0, 0], [this._width, this._height]]).on("start", this._onBrushStart.bind(this)).on("brush", this._onBrushMove.bind(this)).on("end", this._onBrushEnd.bind(this));
    this.brush.call(brushBehaviour).classed("non-draggable", !config.draggable);
    const yRange = [this._height, 0];
    const h17 = yRange[0] - yRange[1];
    this.g.selectAll(".handle").attr("y", yRange[1]).attr("height", h17);
    this.unselectedRange.attr("y", yRange[1]).attr("height", h17);
    this.handleLines.attr("y1", yRange[1] + 10).attr("y2", yRange[1] + h17 - 10);
    const xRange = [0, this._width];
    const xScaleRange = xScale.range();
    xScale.range(xRange);
    const selectionMin = clamp((_b = xScale((_a = config.selection || this._selection) === null || _a === void 0 ? void 0 : _a[0])) !== null && _b !== void 0 ? _b : 0, xRange[0], xRange[1]);
    const selectionMax = clamp((_d = xScale((_c = config.selection || this._selection) === null || _c === void 0 ? void 0 : _c[1])) !== null && _d !== void 0 ? _d : 0, xRange[0], xRange[1]);
    xScale.range(xScaleRange);
    const selectionLength = selectionMax - selectionMin;
    const brushRange = selectionLength ? [selectionMin, selectionMax] : xRange;
    this._positionHandles(brushRange);
    smartTransition(this.brush, duration).call(brushBehaviour.move, brushRange).on("end interrupt", () => {
      this._firstRender = false;
    });
    if (!duration)
      this._firstRender = false;
  }
  _updateSelection(s12) {
    const xRange = [0, this._width];
    this.unselectedRange.attr("x", (d18) => d18.type === BrushDirection.West ? xRange[0] : s12[1]).attr("width", (d18) => {
      const length = d18.type === BrushDirection.West ? s12[0] - xRange[0] : xRange[1] - s12[1];
      const lengthClamped = clamp(length, 0, xRange[1] - xRange[0]);
      return lengthClamped;
    });
    this._positionHandles(s12);
    const yRange = [this._height, 0];
    const h17 = yRange[0] - yRange[1];
    this.g.selectAll(".handle").attr("y", yRange[1]).attr("height", h17);
  }
  _positionHandles(s12) {
    const { config } = this;
    this.brush.selectAll(".handle").attr("width", config.handleWidth).attr("x", (d18) => {
      if (!s12)
        return 0;
      const west = d18.type === BrushDirection.West;
      const inside = config.handlePosition === Arrangement.Inside;
      if (west)
        return s12[0] + (inside ? 0 : -config.handleWidth);
      else
        return s12[1] + (inside ? -config.handleWidth : 0);
    });
    this.handleLines.attr("transform", (d18) => {
      if (!s12)
        return null;
      const west = d18.type === BrushDirection.West;
      const inside = config.handlePosition === Arrangement.Inside;
      return `translate(${west ? s12[0] - Math.pow(-1, Number(inside)) * config.handleWidth / 2 : s12[1] + Math.pow(-1, Number(inside)) * config.handleWidth / 2},0)`;
    });
  }
  _onBrush(event) {
    var _a;
    const { config } = this;
    const xScale = this.xScale;
    const xRange = [0, this._width];
    const s12 = (event === null || event === void 0 ? void 0 : event.selection) || xRange;
    const userDriven = !!(event === null || event === void 0 ? void 0 : event.sourceEvent);
    if (userDriven && ((event === null || event === void 0 ? void 0 : event.selection) === null || // happens when user clicks to reset the selection
    (s12 === null || s12 === void 0 ? void 0 : s12[0]) === (s12 === null || s12 === void 0 ? void 0 : s12[1]) || // happens when user drags the selection out of range
    (s12 === null || s12 === void 0 ? void 0 : s12[0]) < xRange[0] || //
    (s12 === null || s12 === void 0 ? void 0 : s12[0]) > xRange[1] || // happens when you drag the brush and the domain updates
    (s12 === null || s12 === void 0 ? void 0 : s12[1]) < xRange[0] || // to a smaller one and brush goes out of range
    (s12 === null || s12 === void 0 ? void 0 : s12[1]) > xRange[1])) {
      this.brush.call(this.brushBehaviour.move, xRange);
      return;
    }
    if (s12[0] !== s12[1] && isNumber(s12[0]) && isNumber(s12[1])) {
      const xScaleRange = xScale.range();
      xScale.range(xRange);
      const selectedDomain = s12.map((n) => +xScale.invert(n));
      if (userDriven) {
        const xDomain = xScale.domain();
        const xDomainLength = Math.abs(xDomain[1] - xDomain[0]);
        const selectionLength = Math.abs(selectedDomain[1] - selectedDomain[0]);
        if (config.selectionMinLength >= xDomainLength) {
          console.warn("Unovis | Brush: Configured `selectionMinLength` is bigger than the brush domain");
        }
        if (selectionLength < config.selectionMinLength && config.selectionMinLength < xDomainLength) {
          const selection2 = (_a = config.selection) !== null && _a !== void 0 ? _a : this._selection;
          const range3 = [xScale(selection2[0]), xScale(selection2[1])];
          this.brush.call(this.brushBehaviour.move, range3);
          xScale.range(xScaleRange);
          return;
        } else {
          this._selection = selectedDomain;
          xScale.range(xScaleRange);
        }
      }
      this._updateSelection(s12);
      if (!this._firstRender)
        config.onBrush(selectedDomain, event, userDriven);
    }
  }
  _onBrushStart(event) {
    const { config } = this;
    this._onBrush(event);
    if (!this._firstRender)
      config.onBrushStart(this._selection, event, !!(event === null || event === void 0 ? void 0 : event.sourceEvent));
  }
  _onBrushMove(event) {
    const { config } = this;
    this._onBrush(event);
    if (!this._firstRender)
      config.onBrushMove(this._selection, event, !!(event === null || event === void 0 ? void 0 : event.sourceEvent));
  }
  _onBrushEnd(event) {
    const { config } = this;
    this._onBrush(event);
    if (!this._firstRender)
      config.onBrushEnd(this._selection, event, !!(event === null || event === void 0 ? void 0 : event.sourceEvent));
  }
};
Brush.selectors = style_exports7;

// node_modules/@unovis/ts/components/bullet-legend/index.js
var import_to_px3 = __toESM(require_browser(), 1);

// node_modules/@unovis/ts/components/bullet-legend/types.js
var BulletShape = Object.assign(Object.assign({}, SymbolType), { Line: "line" });
var BulletLegendOrientation;
(function(BulletLegendOrientation2) {
  BulletLegendOrientation2["Horizontal"] = "horizontal";
  BulletLegendOrientation2["Vertical"] = "vertical";
})(BulletLegendOrientation || (BulletLegendOrientation = {}));

// node_modules/@unovis/ts/components/bullet-legend/config.js
var BulletLegendDefaultConfig = {
  items: [],
  labelClassName: "",
  onLegendItemClick: void 0,
  labelFontSize: null,
  labelMaxWidth: null,
  bulletSize: null,
  bulletSpacing: 4,
  bulletShape: (d18) => {
    var _a;
    return (_a = d18.shape) !== null && _a !== void 0 ? _a : BulletShape.Circle;
  },
  orientation: BulletLegendOrientation.Horizontal,
  renderIntoProvidedDomNode: false
};

// node_modules/@unovis/ts/components/bullet-legend/modules/shape.js
var import_to_px2 = __toESM(require_browser(), 1);
var BULLET_SIZE = PATTERN_SIZE_PX * 3;
var shapeScale = {
  [BulletShape.Circle]: Math.PI / 4,
  [BulletShape.Cross]: 5 / 9,
  [BulletShape.Diamond]: Math.sqrt(3) / 6,
  [BulletShape.Square]: 1,
  [BulletShape.Star]: 0.3,
  [BulletShape.Triangle]: Math.sqrt(3) / 4,
  [BulletShape.Wye]: 5 / 11
};
function getBulletsTotalWidth(bulletSize, numBullets, spacing) {
  if (numBullets < 1)
    return 0;
  return bulletSize * numBullets + spacing * (numBullets - 1);
}
function createBullets(container) {
  container.each((d18, i8, els) => {
    select_default2(els[i8]).append("svg").attr("width", "100%").attr("height", "100%").append("path");
  });
}
function updateBullets(container, config, colorAccessor) {
  container.each((d18, i8, els) => {
    var _a;
    const shape = getString(d18, config.bulletShape, i8);
    const colors2 = ensureArray((_a = d18.color) !== null && _a !== void 0 ? _a : getColor(d18, colorAccessor, i8));
    const numBullets = colors2.length;
    const bulletWidth = BULLET_SIZE;
    const defaultBulletSize = (0, import_to_px2.default)(getComputedStyle(els[i8]).getPropertyValue("--vis-legend-bullet-size"));
    const spacing = config.bulletSpacing * (BULLET_SIZE / defaultBulletSize);
    const width = getBulletsTotalWidth(bulletWidth, numBullets, spacing);
    const height = shape === BulletShape.Line ? BULLET_SIZE / 2.5 : BULLET_SIZE;
    const selection2 = select_default2(els[i8]).select("svg").attr("viewBox", `0 0 ${width} ${height}`);
    selection2.selectAll("path").remove();
    const opacity = d18.inactive ? "var(--vis-legend-bullet-inactive-opacity)" : 1;
    colors2.forEach((color2, colorIndex) => {
      const bulletPath = selection2.append("path");
      if (shape === BulletShape.Line) {
        const x110 = colorIndex * (bulletWidth + spacing);
        const x22 = x110 + bulletWidth;
        bulletPath.attr("d", `M${x110},${height / 2} L${x22},${height / 2}`).attr("transform", null).style("opacity", opacity).style("stroke", color2).style("stroke-width", "3px").style("fill", null).style("fill-opacity", null).style("marker-start", "none").style("marker-end", "none");
      } else {
        const symbolGen = Symbol2().type(Symbol3[shape]).size(bulletWidth * height * shapeScale[shape]);
        const scale = (bulletWidth - 2) / bulletWidth;
        let dy = height / 2;
        switch (shape) {
          case BulletShape.Triangle:
            dy += height / 8;
            break;
          case BulletShape.Star:
            dy += height / 16;
            break;
          case BulletShape.Wye:
            dy -= height / 16;
            break;
        }
        const dx = colorIndex * (bulletWidth + spacing) + bulletWidth / 2;
        bulletPath.attr("d", symbolGen).attr("transform", `translate(${dx}, ${Math.round(dy)}) scale(${scale})`).style("stroke", color2).style("stroke-width", "1px").style("opacity", null).style("fill", color2).style("fill-opacity", opacity);
      }
    });
  });
}

// node_modules/@unovis/ts/components/bullet-legend/style.js
var style_exports8 = {};
__export(style_exports8, {
  bullet: () => bullet,
  clickable: () => clickable,
  item: () => item,
  itemVertical: () => itemVertical,
  label: () => label2,
  root: () => root9,
  variables: () => variables5
});
var root9 = css`
  label: bullet-legend-component;
`;
var variables5 = injectGlobal`
  :root {
    // Undefined by default to allow proper fallback to var(--vis-font-family)
    /* --vis-legend-font-family: */

    --vis-legend-label-color: #6c778c;
    --vis-legend-label-max-width: 300px;
    --vis-legend-label-font-size: 12px;
    --vis-legend-bullet-size: 9px;
    --vis-legend-bullet-inactive-opacity: 0.15;
    --vis-legend-item-spacing: 20px;
    --vis-legend-vertical-item-spacing: 5px;
    --vis-legend-bullet-label-spacing: 8px;

    --vis-dark-legend-label-color: #eee;
  }

  body.theme-dark ${`.${root9}`} {
    --vis-legend-label-color: var(--vis-dark-legend-label-color);
  }

  body.theme-patterns {
    --vis-legend-bullet-size: 14px;
  }
`;
var item = css`
  label: legendItem;
  display: inline-flex;
  align-items: center;
  font-family: var(--vis-legend-font-family, var(--vis-font-family));
  margin-right: var(--vis-legend-item-spacing);
  white-space: nowrap;
  cursor: default;
  user-select: none;
  max-width: min-content;
`;
var itemVertical = css`
  label: legendItemVertical;
  display: flex;
  margin-top: var(--vis-legend-vertical-item-spacing);
`;
var clickable = css`
  cursor: pointer;
`;
var label2 = css`
  label: legendItemLabel;
  font-size: var(--vis-legend-label-font-size);
  display: inline-block;
  vertical-align: middle;
  color: var(--vis-legend-label-color);
  max-width: var(--vis-legend-label-max-width);
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
`;
var bullet = css`
  flex: 0 0 auto;
  label: legendItemBullet;
  margin-right: var(--vis-legend-bullet-label-spacing);
  height: var(--vis-legend-bullet-size);
  width: var(--vis-legend-bullet-size);

  svg {
    display: block;
  }
`;

// node_modules/@unovis/ts/components/bullet-legend/index.js
var BulletLegend = class {
  constructor(element, config) {
    this._defaultConfig = BulletLegendDefaultConfig;
    this.config = this._defaultConfig;
    this._colorAccessor = (d18) => d18.color;
    this._container = element;
    this.div = (config === null || config === void 0 ? void 0 : config.renderIntoProvidedDomNode) ? select_default2(this._container) : select_default2(this._container).append("div");
    this.div.classed(root9, true);
    this.element = this.div.node();
    if (config)
      this.update(config);
  }
  update(config) {
    this.prevConfig = this.config;
    this.config = merge2(this._defaultConfig, config);
    this.render();
  }
  render() {
    const { config } = this;
    const legendItems = this.div.selectAll(`.${item}`).data(config.items);
    const legendItemsEnter = legendItems.enter().append("div").on("click", this._onItemClick.bind(this));
    const legendItemsMerged = legendItemsEnter.merge(legendItems);
    legendItemsMerged.attr("class", (d18) => {
      var _a;
      return `${item} ${(_a = d18.className) !== null && _a !== void 0 ? _a : ""}`;
    }).classed(itemVertical, config.orientation === BulletLegendOrientation.Vertical).classed(clickable, (d18) => !!config.onLegendItemClick && this._isItemClickable(d18)).attr("title", (d18) => d18.name).style("display", (d18) => d18.hidden ? "none" : null);
    legendItemsEnter.append("span").attr("class", bullet).call(createBullets);
    legendItemsMerged.select(`.${bullet}`).style("width", function(d18) {
      const colors2 = Array.isArray(d18.color) ? d18.color : [d18.color];
      const numColors = colors2.length;
      const defaultSize = (0, import_to_px3.default)(getComputedStyle(this).getPropertyValue("--vis-legend-bullet-size")) || 9;
      const baseSize = config.bulletSize ? (0, import_to_px3.default)(config.bulletSize) : defaultSize;
      const spacing = config.bulletSpacing;
      return `${getBulletsTotalWidth(baseSize, numColors, spacing)}px`;
    }).style("height", config.bulletSize).style("box-sizing", "content-box").call(updateBullets, this.config, this._colorAccessor);
    legendItemsEnter.append("span").attr("class", label2).classed(config.labelClassName, true).style("max-width", config.labelMaxWidth).style("font-size", config.labelFontSize);
    legendItemsMerged.select(`.${label2}`).text((d18) => d18.name);
    legendItems.exit().remove();
  }
  _isItemClickable(item4) {
    return item4.pointer === void 0 ? true : item4.pointer;
  }
  _onItemClick(event, d18) {
    const { config: { onLegendItemClick } } = this;
    const legendItems = this.div.selectAll(`.${item}`).nodes();
    const index3 = legendItems.indexOf(event.currentTarget);
    if (onLegendItemClick)
      onLegendItemClick(d18, index3);
  }
  destroy() {
    if (this.element !== this._container)
      this.div.remove();
  }
};
BulletLegend.selectors = style_exports8;

// node_modules/@unovis/ts/components/rolling-pin-legend/config.js
var RollingPinLegendDefaultConfig = {
  rects: [],
  leftLabelText: void 0,
  rightLabelText: void 0,
  labelClassName: "",
  labelFontSize: null,
  renderIntoProvidedDomNode: false
};

// node_modules/@unovis/ts/components/rolling-pin-legend/style.js
var style_exports9 = {};
__export(style_exports9, {
  cssVarDefaults: () => cssVarDefaults3,
  label: () => label3,
  leftLabel: () => leftLabel,
  rect: () => rect,
  rectsContainer: () => rectsContainer,
  rightLabel: () => rightLabel,
  root: () => root10,
  variables: () => variables6
});
var root10 = css`
  display: flex;
`;
var cssVarDefaults3 = {
  "--vis-rolling-pin-legend-label-color": "#6c778c",
  "--vis-rolling-pin-legend-label-max-width": "300px",
  "--vis-rolling-pin-legend-label-font-size": "12px",
  "--vis-rolling-pin-legend-spacing": "4px",
  "--vis-rolling-pin-legend-item-width": "8px",
  "--vis-dark-rolling-pin-legend-label-color": "#eee"
};
var variables6 = getCssVarNames(cssVarDefaults3);
injectGlobalCssVariables(cssVarDefaults3, root10);
var rectsContainer = css`
  display: flex;
`;
var label3 = css`
  font-family: var(--vis-rolling-pin-legend-font-family, var(--vis-font-family));
  font-size: var(${variables6.rollingPinLegendLabelFontSize});
  max-width: var(${variables6.rollingPinLegendLabelMaxWidth});
  color: var(${variables6.rollingPinLegendLabelColor});
`;
var leftLabel = css`
  margin-right: var(${variables6.rollingPinLegendSpacing});
`;
var rightLabel = css`
  margin-left: var(${variables6.rollingPinLegendSpacing});
`;
var rect = css`
  display: inline-block;
  flex: 1;
  width: var(${variables6.rollingPinLegendItemWidth});
`;

// node_modules/@unovis/ts/components/rolling-pin-legend/index.js
var RollingPinLegend = class {
  constructor(element, config) {
    this._defaultConfig = RollingPinLegendDefaultConfig;
    this.config = this._defaultConfig;
    this._container = element;
    this.div = (config === null || config === void 0 ? void 0 : config.renderIntoProvidedDomNode) ? select_default2(this._container) : select_default2(this._container).append("div");
    this.div.classed(root10, true);
    this.element = this.div.node();
    if (config)
      this.setConfig(config);
  }
  setConfig(config) {
    this.prevConfig = this.config;
    this.config = merge2(this._defaultConfig, config);
    this.render();
  }
  render() {
    const { config } = this;
    const newRoot = this.div.selectAll(`.${root10}`).data([0]).enter().append("div").attr("class", root10);
    newRoot.append("span").attr("class", label3).classed(config.labelClassName, true).style("font-size", config.labelFontSize);
    newRoot.append("div").attr("class", rectsContainer);
    newRoot.append("span").attr("class", label3).classed(config.labelClassName, true).style("font-size", config.labelFontSize);
    const root$1 = this.div.select(`.${root10}`);
    root$1.selectAll(`.${label3}`).data([config.leftLabelText, config.rightLabelText]).text((d18) => d18).classed(leftLabel, (d18, i8) => i8 === 0 && typeof d18 === "string" && d18.length > 0).classed(rightLabel, (d18, i8) => i8 === 1 && typeof d18 === "string" && d18.length > 0);
    const rectsContainer$1 = root$1.select(`.${rectsContainer}`);
    const rects = rectsContainer$1.selectAll(`.${rect}`).data(config.rects);
    const rectsEnter = rects.enter().append("div").attr("class", rect);
    const rectsMerged = rectsEnter.merge(rects);
    rectsMerged.style("background-color", (d18) => d18);
    rects.exit().remove();
  }
  destroy() {
    if (this.element !== this._container)
      this.div.remove();
  }
};
RollingPinLegend.selectors = style_exports9;

// node_modules/@unovis/ts/components/flow-legend/types.js
var FlowLegendItemType;
(function(FlowLegendItemType2) {
  FlowLegendItemType2["Label"] = "label";
  FlowLegendItemType2["Symbol"] = "symbol";
})(FlowLegendItemType || (FlowLegendItemType = {}));

// node_modules/@unovis/ts/components/flow-legend/style.js
var root11 = css`
  label: flow-legend-component;

  position: relative;
  user-select: none;
`;
var globalStyles5 = injectGlobal`
  :root {
    --vis-flow-legend-label-background: #ffffff;
    --vis-flow-legend-label-color: #71788a;
    --vis-flow-legend-link-color: #E5E9F7;
    --vis-flow-legend-arrow-color: #E5E9F7;
    --vis-flow-legend-label-padding: 5px 15px;
    --vis-flow-legend-arrow-padding: 0 10px;
    /* --vis-flow-legend-arrow-font-family: Undefined by default to allow proper fallback to var(DEFAULT_ICON_FONT_FAMILY)*/

    --vis-dark-flow-legend-label-background: #292b34;
    --vis-dark-flow-legend-label-color: #E5E9F7;
    --vis-dark-flow-legend-link-color: #71788a;
    --vis-dark-flow-legend-arrow-color: #71788a;
  }

  body.theme-dark ${`.${root11}`} {
    --vis-flow-legend-label-background: var(--vis-dark-flow-legend-label-background);
    --vis-flow-legend-label-color: var(--vis-dark-flow-legend-label-color);
    --vis-flow-legend-link-color: var(--vis-dark-flow-legend-link-color);
    --vis-flow-legend-arrow-color: var(--vis-dark-flow-legend-arrow-color);
  }
`;
var labels = css`
  label: labels;

  position: relative;
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
`;
var item2 = css`
  label: item;

  position: relative;
  max-width: 50px;

  padding: 10px;
`;
var clickable2 = css`
  cursor: pointer;

  &:hover {
    text-decoration: underline;
  }
`;

// node_modules/@unovis/ts/components/crosshair/config.js
var CrosshairDefaultConfig = Object.assign(Object.assign({}, XYComponentDefaultConfig), { yStacked: void 0, baseline: null, duration: 100, tooltip: void 0, template: (d18, x21, data, leftNearestDatumIndex) => "", hideWhenFarFromPointer: true, hideWhenFarFromPointerDistance: 100, snapToData: true, getCircles: void 0, color: void 0, strokeColor: void 0, strokeWidth: void 0, onCrosshairMove: void 0, forceShowAt: void 0 });

// node_modules/@unovis/ts/components/crosshair/style.js
var style_exports10 = {};
__export(style_exports10, {
  circle: () => circle,
  globalStyles: () => globalStyles6,
  line: () => line3,
  root: () => root12
});
var globalStyles6 = injectGlobal`
  :root {
    --vis-crosshair-line-stroke-color: #888;
    --vis-crosshair-line-stroke-width: 1px;
    --vis-crosshair-line-stroke-opacity: 1;
    --vis-crosshair-circle-stroke-color: #fff;
    --vis-crosshair-circle-stroke-width: 1px;
    --vis-crosshair-circle-stroke-opacity: 0.75;
  }
`;
var root12 = css`
  label: crosshair-component;
`;
var line3 = css`
  stroke: var(--vis-crosshair-line-stroke-color);
  stroke-width: var(--vis-crosshair-line-stroke-width);
  stroke-opacity: var(--vis-crosshair-line-stroke-opacity);
  pointer-events: none;
`;
var circle = css`
  stroke: var(--vis-crosshair-circle-stroke-color);
  stroke-width: var(--vis-crosshair-circle-stroke-width);
  stroke-opacity: var(--vis-crosshair-circle-stroke-opacity);
  pointer-events: none;
`;

// node_modules/@unovis/ts/components/crosshair/index.js
var Crosshair = class extends XYComponentCore {
  constructor(config) {
    super();
    this.clippable = true;
    this._defaultConfig = CrosshairDefaultConfig;
    this.config = this._defaultConfig;
    this._xPx = void 0;
    this._yPx = void 0;
    this._mouseEvent = void 0;
    this._animFrameId = null;
    this._accessors = {
      x: void 0,
      y: void 0,
      yStacked: void 0,
      baseline: void 0
    };
    if (config)
      this.setConfig(config);
    this.g.style("opacity", 0);
    this.line = this.g.append("line").attr("class", line3);
  }
  set accessors(accessors) {
    this._accessors = accessors;
  }
  get accessors() {
    var _a;
    const { config } = this;
    const hasConfig = !!(config.x || config.y || config.yStacked);
    const x21 = hasConfig ? config.x : this._accessors.x;
    const yAcc = hasConfig ? config.y : this._accessors.y;
    const y25 = yAcc ? isArray(yAcc) ? yAcc : [yAcc] : void 0;
    const yStacked = hasConfig ? config.yStacked : this._accessors.yStacked;
    const baseline = (_a = config.baseline) !== null && _a !== void 0 ? _a : this._accessors.baseline;
    return { x: x21, y: y25, yStacked, baseline };
  }
  _isContainerInViewport() {
    var _a;
    if (!((_a = this.container) === null || _a === void 0 ? void 0 : _a.node()))
      return false;
    const containerRect = this.container.node().getBoundingClientRect();
    const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
    const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
    const visibleWidth = Math.max(0, Math.min(containerRect.right, viewportWidth) - Math.max(containerRect.left, 0));
    const visibleHeight = Math.max(0, Math.min(containerRect.bottom, viewportHeight) - Math.max(containerRect.top, 0));
    const containerArea = containerRect.width * containerRect.height;
    const visibleArea = visibleWidth * visibleHeight;
    return containerArea > 0 && visibleArea / containerArea >= 0.35;
  }
  setContainer(containerSvg) {
    if (this.container === containerSvg)
      return;
    this.container = containerSvg;
    this.container.on("mousemove.crosshair", this._onMouseMove.bind(this));
    this.container.on("mouseout.crosshair", this._onMouseOut.bind(this));
    this.container.on("wheel.crosshair", this._onWheel.bind(this));
  }
  _render(customDuration) {
    var _a, _b, _c, _d, _e;
    const { config, datamodel } = this;
    const duration = isNumber(customDuration) ? customDuration : config.duration;
    const isForceShowAtDefined = config.forceShowAt !== void 0;
    const xPx = isForceShowAtDefined ? this.xScale(config.forceShowAt) : this._xPx;
    const xValue = this.xScale.invert(xPx);
    const leftNearestDatumIndex = ((_a = datamodel.data) === null || _a === void 0 ? void 0 : _a.length) && this.accessors.x ? datamodel.data.indexOf(getNearest(datamodel.data, xValue, this.accessors.x, FindNearestDirection.Left)) : void 0;
    let nearestDatum;
    let nearestDatumIndex;
    if (config.snapToData) {
      if (!this.accessors.y && !this.accessors.yStacked && ((_b = datamodel.data) === null || _b === void 0 ? void 0 : _b.length)) {
        console.warn("Unovis | Crosshair: Y accessors have not been configured. Please check if they're present in the configuration object");
      }
      if (!((_c = datamodel.data) === null || _c === void 0 ? void 0 : _c.length) && this._mouseEvent) {
        console.warn("Unovis | Crosshair: No data to snap to. Make sure the data has been passed to the container or to the crosshair itself");
      }
      nearestDatum = getNearest(datamodel.data, xValue, this.accessors.x);
      nearestDatumIndex = datamodel.data.indexOf(nearestDatum);
    }
    const xRange = this.xScale.range();
    const yRange = this.yScale.range();
    const xClamped = config.snapToData && nearestDatum ? clamp(Math.round(this.xScale(getNumber(nearestDatum, this.accessors.x, nearestDatumIndex))), 0, this._width) : clamp(xPx, xRange[0], xRange[1]);
    const isCrosshairWithinXRange = xPx >= xRange[0] && xPx <= xRange[1];
    const isCrosshairWithinYRange = this._yPx >= yRange[1] && this._yPx <= yRange[0];
    let shouldShow = this._xPx ? isCrosshairWithinXRange && isCrosshairWithinYRange : isCrosshairWithinXRange;
    if (config.hideWhenFarFromPointer && Math.abs(xClamped - +xPx) >= config.hideWhenFarFromPointerDistance) {
      shouldShow = false;
    }
    const tooltip2 = (_d = config.tooltip) !== null && _d !== void 0 ? _d : this.tooltip;
    if (shouldShow && tooltip2 && this._isContainerInViewport()) {
      const container = tooltip2.getContainer() || this.container.node();
      const isContainerBody = tooltip2.isContainerBody();
      if (isForceShowAtDefined) {
        const containerRect = this.container.node().getBoundingClientRect();
        const screenX = (isContainerBody ? xPx + containerRect.left : xPx) + this._containerMargin.left;
        const screenY = this._height / 2 + (isContainerBody ? containerRect.top : 0);
        const pos = [screenX, screenY];
        this._showTooltip(nearestDatum, xValue, pos, leftNearestDatumIndex);
      } else if (this._mouseEvent) {
        const pos = isContainerBody ? [this._mouseEvent.clientX, this._mouseEvent.clientY] : pointer_default(this._mouseEvent, container);
        this._showTooltip(nearestDatum, xValue, pos, leftNearestDatumIndex);
      }
    } else
      this._hideTooltip();
    if (this._mouseEvent) {
      (_e = config.onCrosshairMove) === null || _e === void 0 ? void 0 : _e.call(config, shouldShow ? this.xScale.invert(this._xPx) : void 0, nearestDatum, nearestDatumIndex, this._mouseEvent);
      this._mouseEvent = void 0;
    }
    smartTransition(this.g, duration).style("opacity", shouldShow ? 1 : 0);
    if (!isFinite(xPx))
      return;
    this.line.attr("y1", 0).attr("y2", this._height);
    smartTransition(this.line, duration, linear2).attr("x1", xClamped).attr("x2", xClamped);
    const circleData = isFunction(config.getCircles) ? config.getCircles(xValue, datamodel.data, this.yScale, leftNearestDatumIndex) : this.getCircleData(nearestDatum, nearestDatumIndex);
    const circles = this.g.selectAll("circle").data(circleData, (d18, i8) => {
      var _a2;
      return (_a2 = d18.id) !== null && _a2 !== void 0 ? _a2 : i8;
    });
    const circlesEnter = circles.enter().append("circle").attr("class", circle).attr("r", 0).attr("cx", xClamped).attr("cy", (d18) => d18.y).style("fill", (d18) => d18.color).style("stroke", (d18) => d18.strokeColor).style("stroke-width", (d18) => d18.strokeWidth);
    smartTransition(circlesEnter.merge(circles), duration, linear2).attr("cx", xClamped).attr("cy", (d18) => d18.y).attr("r", 4).style("opacity", (d18) => d18.opacity).style("fill", (d18) => d18.color).style("stroke", (d18) => d18.strokeColor).style("stroke-width", (d18) => d18.strokeWidth);
    circles.exit().remove();
  }
  hide(sourceEvent) {
    window.cancelAnimationFrame(this._animFrameId);
    this._animFrameId = window.requestAnimationFrame(() => {
      var _a, _b;
      this._xPx = void 0;
      this._yPx = void 0;
      this._mouseEvent = void 0;
      (_b = (_a = this.config).onCrosshairMove) === null || _b === void 0 ? void 0 : _b.call(_a, void 0, void 0, void 0, sourceEvent);
      this._render();
    });
  }
  _onMouseMove(event) {
    var _a;
    const { datamodel, element } = this;
    if (!this.accessors.x && ((_a = datamodel.data) === null || _a === void 0 ? void 0 : _a.length)) {
      console.warn("Unovis | Crosshair: X accessor function has not been configured. Please check if it's present in the configuration object");
    }
    const [x21, y25] = pointer_default(event, element);
    this._xPx = x21;
    this._yPx = y25;
    this._mouseEvent = event;
    window.cancelAnimationFrame(this._animFrameId);
    this._animFrameId = window.requestAnimationFrame(() => {
      this._render();
    });
  }
  _onMouseOut(event) {
    var _a;
    if (!event || !((_a = this.container) === null || _a === void 0 ? void 0 : _a.node().contains(event.relatedTarget))) {
      this.hide(event);
    }
  }
  _onWheel(event) {
    this.hide(event);
  }
  _showTooltip(datum2, xValue, pos, nearestDatumIndex) {
    var _a;
    const { config, datamodel } = this;
    const tooltip2 = (_a = config.tooltip) !== null && _a !== void 0 ? _a : this.tooltip;
    if (!tooltip2 || !pos)
      return;
    const [x21, y25] = pos;
    const content = config.template(datum2, xValue, datamodel.data, nearestDatumIndex);
    tooltip2.config.followCursor = true;
    if (!tooltip2.config.horizontalPlacement || tooltip2.config.horizontalPlacement === Position.Auto) {
      const xRelative = tooltip2.isContainerBody() ? x21 - this.container.node().getBoundingClientRect().left : x21;
      tooltip2.overrideHorizontalPlacement(xRelative > this._containerWidth / 2 ? Position.Left : Position.Right);
    }
    if (content)
      tooltip2.show(content, { x: x21, y: y25 });
  }
  _hideTooltip() {
    var _a;
    const { config } = this;
    const tooltip2 = (_a = config.tooltip) !== null && _a !== void 0 ? _a : this.tooltip;
    tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.hide();
  }
  // We don't want Crosshair to be be taken in to account in domain calculations
  getYDataExtent() {
    return [void 0, void 0];
  }
  getCircleData(datum2, datumIndex) {
    var _a, _b;
    const { config } = this;
    if (config.snapToData && datum2) {
      const yAccessors = (_a = this.accessors.y) !== null && _a !== void 0 ? _a : [];
      const yStackedAccessors = (_b = this.accessors.yStacked) !== null && _b !== void 0 ? _b : [];
      const baselineValue = getNumber(datum2, this.accessors.baseline, datumIndex) || 0;
      const stackedValues = getStackedValues(datum2, datumIndex, ...yStackedAccessors).map((value2, index3) => ({
        y: this.yScale(value2 + baselineValue),
        opacity: isNumber(getNumber(datum2, yStackedAccessors[index3], index3)) ? 1 : 0,
        color: getColor(datum2, config.color, index3),
        strokeColor: config.strokeColor ? getColor(datum2, config.strokeColor, index3) : void 0,
        strokeWidth: config.strokeWidth ? getNumber(datum2, config.strokeWidth, index3) : void 0
      }));
      const regularValues = yAccessors.map((a7, index3) => {
        const value2 = getNumber(datum2, a7, datumIndex);
        return {
          y: this.yScale(value2),
          opacity: isNumber(value2) ? 1 : 0,
          color: getColor(datum2, config.color, stackedValues.length + index3),
          strokeColor: config.strokeColor ? getColor(datum2, config.strokeColor, index3) : void 0,
          strokeWidth: config.strokeWidth ? getNumber(datum2, config.strokeWidth, index3) : void 0
        };
      });
      return stackedValues.concat(regularValues);
    }
    return [];
  }
};
Crosshair.selectors = style_exports10;

// node_modules/@unovis/ts/types/shape.js
var Shape;
(function(Shape2) {
  Shape2["Square"] = "square";
  Shape2["Circle"] = "circle";
  Shape2["Hexagon"] = "hexagon";
  Shape2["Triangle"] = "triangle";
  Shape2["Cluster"] = "cluster";
})(Shape || (Shape = {}));

// node_modules/@unovis/ts/components/chord-diagram/types.js
var ChordLabelAlignment;
(function(ChordLabelAlignment2) {
  ChordLabelAlignment2["Along"] = "along";
  ChordLabelAlignment2["Perpendicular"] = "perpendicular";
})(ChordLabelAlignment || (ChordLabelAlignment = {}));

// node_modules/d3-geo/src/math.js
var epsilon5 = 1e-6;
var epsilon22 = 1e-12;
var pi4 = Math.PI;
var halfPi3 = pi4 / 2;
var quarterPi = pi4 / 4;
var tau4 = pi4 * 2;
var degrees3 = 180 / pi4;
var radians2 = pi4 / 180;
var abs3 = Math.abs;
var atan = Math.atan;
var atan22 = Math.atan2;
var cos2 = Math.cos;
var exp = Math.exp;
var log2 = Math.log;
var pow2 = Math.pow;
var sin2 = Math.sin;
var sign2 = Math.sign || function(x21) {
  return x21 > 0 ? 1 : x21 < 0 ? -1 : 0;
};
var sqrt4 = Math.sqrt;
var tan = Math.tan;
function acos2(x21) {
  return x21 > 1 ? 0 : x21 < -1 ? pi4 : Math.acos(x21);
}
function asin2(x21) {
  return x21 > 1 ? halfPi3 : x21 < -1 ? -halfPi3 : Math.asin(x21);
}

// node_modules/d3-geo/src/noop.js
function noop() {
}

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object2, stream) {
    streamGeometry(object2.geometry, stream);
  },
  FeatureCollection: function(object2, stream) {
    var features2 = object2.features, i8 = -1, n = features2.length;
    while (++i8 < n) streamGeometry(features2[i8].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object2, stream) {
    stream.sphere();
  },
  Point: function(object2, stream) {
    object2 = object2.coordinates;
    stream.point(object2[0], object2[1], object2[2]);
  },
  MultiPoint: function(object2, stream) {
    var coordinates = object2.coordinates, i8 = -1, n = coordinates.length;
    while (++i8 < n) object2 = coordinates[i8], stream.point(object2[0], object2[1], object2[2]);
  },
  LineString: function(object2, stream) {
    streamLine(object2.coordinates, stream, 0);
  },
  MultiLineString: function(object2, stream) {
    var coordinates = object2.coordinates, i8 = -1, n = coordinates.length;
    while (++i8 < n) streamLine(coordinates[i8], stream, 0);
  },
  Polygon: function(object2, stream) {
    streamPolygon(object2.coordinates, stream);
  },
  MultiPolygon: function(object2, stream) {
    var coordinates = object2.coordinates, i8 = -1, n = coordinates.length;
    while (++i8 < n) streamPolygon(coordinates[i8], stream);
  },
  GeometryCollection: function(object2, stream) {
    var geometries = object2.geometries, i8 = -1, n = geometries.length;
    while (++i8 < n) streamGeometry(geometries[i8], stream);
  }
};
function streamLine(coordinates, stream, closed) {
  var i8 = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i8 < n) coordinate = coordinates[i8], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates, stream) {
  var i8 = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i8 < n) streamLine(coordinates[i8], stream, 1);
  stream.polygonEnd();
}
function stream_default(object2, stream) {
  if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
    streamObjectType[object2.type](object2, stream);
  } else {
    streamGeometry(object2, stream);
  }
}

// node_modules/d3-geo/src/area.js
var areaRingSum = new Adder();
var areaSum = new Adder();

// node_modules/d3-geo/src/cartesian.js
function spherical(cartesian2) {
  return [atan22(cartesian2[1], cartesian2[0]), asin2(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);
  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
}
function cartesianDot(a7, b25) {
  return a7[0] * b25[0] + a7[1] * b25[1] + a7[2] * b25[2];
}
function cartesianCross(a7, b25) {
  return [a7[1] * b25[2] - a7[2] * b25[1], a7[2] * b25[0] - a7[0] * b25[2], a7[0] * b25[1] - a7[1] * b25[0]];
}
function cartesianAddInPlace(a7, b25) {
  a7[0] += b25[0], a7[1] += b25[1], a7[2] += b25[2];
}
function cartesianScale(vector, k17) {
  return [vector[0] * k17, vector[1] * k17, vector[2] * k17];
}
function cartesianNormalizeInPlace(d18) {
  var l7 = sqrt4(d18[0] * d18[0] + d18[1] * d18[1] + d18[2] * d18[2]);
  d18[0] /= l7, d18[1] /= l7, d18[2] /= l7;
}

// node_modules/d3-geo/src/compose.js
function compose_default(a7, b25) {
  function compose(x21, y25) {
    return x21 = a7(x21, y25), b25(x21[0], x21[1]);
  }
  if (a7.invert && b25.invert) compose.invert = function(x21, y25) {
    return x21 = b25.invert(x21, y25), x21 && a7.invert(x21[0], x21[1]);
  };
  return compose;
}

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi2) {
  if (abs3(lambda) > pi4) lambda -= Math.round(lambda / tau4) * tau4;
  return [lambda, phi2];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau4) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi2) {
    lambda += deltaLambda;
    if (abs3(lambda) > pi4) lambda -= Math.round(lambda / tau4) * tau4;
    return [lambda, phi2];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
  function rotation(lambda, phi2) {
    var cosPhi = cos2(phi2), x21 = cos2(lambda) * cosPhi, y25 = sin2(lambda) * cosPhi, z3 = sin2(phi2), k17 = z3 * cosDeltaPhi + x21 * sinDeltaPhi;
    return [
      atan22(y25 * cosDeltaGamma - k17 * sinDeltaGamma, x21 * cosDeltaPhi - z3 * sinDeltaPhi),
      asin2(k17 * cosDeltaGamma + y25 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi2) {
    var cosPhi = cos2(phi2), x21 = cos2(lambda) * cosPhi, y25 = sin2(lambda) * cosPhi, z3 = sin2(phi2), k17 = z3 * cosDeltaGamma - y25 * sinDeltaGamma;
    return [
      atan22(y25 * cosDeltaGamma + z3 * sinDeltaGamma, x21 * cosDeltaPhi + k17 * sinDeltaPhi),
      asin2(k17 * cosDeltaPhi - x21 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate) {
  rotate = rotateRadians(rotate[0] * radians2, rotate[1] * radians2, rotate.length > 2 ? rotate[2] * radians2 : 0);
  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * radians2, coordinates[1] * radians2);
    return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
  }
  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * radians2, coordinates[1] * radians2);
    return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
  };
  return forward;
}

// node_modules/d3-geo/src/circle.js
function circleStream(stream, radius, delta, direction, t03, t13) {
  if (!delta) return;
  var cosRadius = cos2(radius), sinRadius = sin2(radius), step = direction * delta;
  if (t03 == null) {
    t03 = radius + direction * tau4;
    t13 = radius - step / 2;
  } else {
    t03 = circleRadius(cosRadius, t03);
    t13 = circleRadius(cosRadius, t13);
    if (direction > 0 ? t03 < t13 : t03 > t13) t03 += direction * tau4;
  }
  for (var point13, t4 = t03; direction > 0 ? t4 > t13 : t4 < t13; t4 -= step) {
    point13 = spherical([cosRadius, -sinRadius * cos2(t4), -sinRadius * sin2(t4)]);
    stream.point(point13[0], point13[1]);
  }
}
function circleRadius(cosRadius, point13) {
  point13 = cartesian(point13), point13[0] -= cosRadius;
  cartesianNormalizeInPlace(point13);
  var radius = acos2(-point13[1]);
  return ((-point13[2] < 0 ? -radius : radius) + tau4 - epsilon5) % tau4;
}

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines3 = [], line5;
  return {
    point: function(x21, y25, m30) {
      line5.push([x21, y25, m30]);
    },
    lineStart: function() {
      lines3.push(line5 = []);
    },
    lineEnd: noop,
    rejoin: function() {
      if (lines3.length > 1) lines3.push(lines3.pop().concat(lines3.shift()));
    },
    result: function() {
      var result = lines3;
      lines3 = [];
      line5 = null;
      return result;
    }
  };
}

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a7, b25) {
  return abs3(a7[0] - b25[0]) < epsilon5 && abs3(a7[1] - b25[1]) < epsilon5;
}

// node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point13, points3, other, entry) {
  this.x = point13;
  this.z = points3;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments, compareIntersection2, startInside, interpolate, stream) {
  var subject = [], clip = [], i8, n;
  segments.forEach(function(segment3) {
    if ((n2 = segment3.length - 1) <= 0) return;
    var n2, p0 = segment3[0], p1 = segment3[n2], x21;
    if (pointEqual_default(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i8 = 0; i8 < n2; ++i8) stream.point((p0 = segment3[i8])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon5;
    }
    subject.push(x21 = new Intersection(p0, segment3, null, true));
    clip.push(x21.o = new Intersection(p0, null, x21, false));
    subject.push(x21 = new Intersection(p1, segment3, null, false));
    clip.push(x21.o = new Intersection(p1, null, x21, true));
  });
  if (!subject.length) return;
  clip.sort(compareIntersection2);
  link2(subject);
  link2(clip);
  for (i8 = 0, n = clip.length; i8 < n; ++i8) {
    clip[i8].e = startInside = !startInside;
  }
  var start2 = subject[0], points3, point13;
  while (1) {
    var current = start2, isSubject = true;
    while (current.v) if ((current = current.n) === start2) return;
    points3 = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i8 = 0, n = points3.length; i8 < n; ++i8) stream.point((point13 = points3[i8])[0], point13[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points3 = current.p.z;
          for (i8 = points3.length - 1; i8 >= 0; --i8) stream.point((point13 = points3[i8])[0], point13[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points3 = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link2(array3) {
  if (!(n = array3.length)) return;
  var n, i8 = 0, a7 = array3[0], b25;
  while (++i8 < n) {
    a7.n = b25 = array3[i8];
    b25.p = a7;
    a7 = b25;
  }
  a7.n = b25 = array3[0];
  b25.p = a7;
}

// node_modules/d3-geo/src/polygonContains.js
function longitude(point13) {
  return abs3(point13[0]) <= pi4 ? point13[0] : sign2(point13[0]) * ((abs3(point13[0]) + pi4) % tau4 - pi4);
}
function polygonContains_default(polygon2, point13) {
  var lambda = longitude(point13), phi2 = point13[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle = 0, winding = 0;
  var sum5 = new Adder();
  if (sinPhi === 1) phi2 = halfPi3 + epsilon5;
  else if (sinPhi === -1) phi2 = -halfPi3 - epsilon5;
  for (var i8 = 0, n = polygon2.length; i8 < n; ++i8) {
    if (!(m30 = (ring = polygon2[i8]).length)) continue;
    var ring, m30, point0 = ring[m30 - 1], lambda0 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi0 = sin2(phi02), cosPhi0 = cos2(phi02);
    for (var j6 = 0; j6 < m30; ++j6, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j6], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi1), cosPhi1 = cos2(phi1), delta = lambda1 - lambda0, sign5 = delta >= 0 ? 1 : -1, absDelta = sign5 * delta, antimeridian = absDelta > pi4, k17 = sinPhi0 * sinPhi1;
      sum5.add(atan22(k17 * sign5 * sin2(absDelta), cosPhi0 * cosPhi1 + k17 * cos2(absDelta)));
      angle += antimeridian ? delta + sign5 * tau4 : delta;
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc2 = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc2);
        var intersection2 = cartesianCross(normal, arc2);
        cartesianNormalizeInPlace(intersection2);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin2(intersection2[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc2[0] || arc2[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle < -epsilon5 || angle < epsilon5 && sum5 < -epsilon22) ^ winding & 1;
}

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate, start2) {
  return function(sink) {
    var line5 = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon2, segments, ring;
    var clip = {
      point: point13,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon2 = [];
      },
      polygonEnd: function() {
        clip.point = point13;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains_default(polygon2, start2);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon2 = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point13(lambda, phi2) {
      if (pointVisible(lambda, phi2)) sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line5.point(lambda, phi2);
    }
    function lineStart() {
      clip.point = pointLine;
      line5.lineStart();
    }
    function lineEnd() {
      clip.point = point13;
      line5.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean2 = ringSink.clean(), ringSegments = ringBuffer.result(), i8, n = ringSegments.length, m30, segment3, point14;
      ring.pop();
      polygon2.push(ring);
      ring = null;
      if (!n) return;
      if (clean2 & 1) {
        segment3 = ringSegments[0];
        if ((m30 = segment3.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i8 = 0; i8 < m30; ++i8) sink.point((point14 = segment3[i8])[0], point14[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean2 & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment3) {
  return segment3.length > 1;
}
function compareIntersection(a7, b25) {
  return ((a7 = a7.x)[0] < 0 ? a7[1] - halfPi3 - epsilon5 : halfPi3 - a7[1]) - ((b25 = b25.x)[0] < 0 ? b25[1] - halfPi3 - epsilon5 : halfPi3 - b25[1]);
}

// node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi4, -halfPi3]
);
function clipAntimeridianLine(stream) {
  var lambda0 = NaN, phi02 = NaN, sign0 = NaN, clean2;
  return {
    lineStart: function() {
      stream.lineStart();
      clean2 = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi4 : -pi4, delta = abs3(lambda1 - lambda0);
      if (abs3(delta - pi4) < epsilon5) {
        stream.point(lambda0, phi02 = (phi02 + phi1) / 2 > 0 ? halfPi3 : -halfPi3);
        stream.point(sign0, phi02);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi02);
        stream.point(lambda1, phi02);
        clean2 = 0;
      } else if (sign0 !== sign1 && delta >= pi4) {
        if (abs3(lambda0 - sign0) < epsilon5) lambda0 -= sign0 * epsilon5;
        if (abs3(lambda1 - sign1) < epsilon5) lambda1 -= sign1 * epsilon5;
        phi02 = clipAntimeridianIntersect(lambda0, phi02, lambda1, phi1);
        stream.point(sign0, phi02);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi02);
        clean2 = 0;
      }
      stream.point(lambda0 = lambda1, phi02 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi02 = NaN;
    },
    clean: function() {
      return 2 - clean2;
    }
  };
}
function clipAntimeridianIntersect(lambda0, phi02, lambda1, phi1) {
  var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin2(lambda0 - lambda1);
  return abs3(sinLambda0Lambda1) > epsilon5 ? atan((sin2(phi02) * (cosPhi1 = cos2(phi1)) * sin2(lambda1) - sin2(phi1) * (cosPhi0 = cos2(phi02)) * sin2(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi2;
  if (from == null) {
    phi2 = direction * halfPi3;
    stream.point(-pi4, phi2);
    stream.point(0, phi2);
    stream.point(pi4, phi2);
    stream.point(pi4, 0);
    stream.point(pi4, -phi2);
    stream.point(0, -phi2);
    stream.point(-pi4, -phi2);
    stream.point(-pi4, 0);
    stream.point(-pi4, phi2);
  } else if (abs3(from[0] - to[0]) > epsilon5) {
    var lambda = from[0] < to[0] ? pi4 : -pi4;
    phi2 = direction * lambda / 2;
    stream.point(-lambda, phi2);
    stream.point(0, phi2);
    stream.point(lambda, phi2);
  } else {
    stream.point(to[0], to[1]);
  }
}

// node_modules/d3-geo/src/clip/circle.js
function circle_default2(radius) {
  var cr = cos2(radius), delta = 2 * radians2, smallRadius = cr > 0, notHemisphere = abs3(cr) > epsilon5;
  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }
  function visible(lambda, phi2) {
    return cos2(lambda) * cos2(phi2) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean2;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean2 = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point22, v28 = visible(lambda, phi2), c6 = smallRadius ? v28 ? 0 : code(lambda, phi2) : v28 ? code(lambda + (lambda < 0 ? pi4 : -pi4), phi2) : 0;
        if (!point0 && (v00 = v0 = v28)) stream.lineStart();
        if (v28 !== v0) {
          point22 = intersect2(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
            point1[2] = 1;
        }
        if (v28 !== v0) {
          clean2 = 0;
          if (v28) {
            stream.lineStart();
            point22 = intersect2(point1, point0);
            stream.point(point22[0], point22[1]);
          } else {
            point22 = intersect2(point0, point1);
            stream.point(point22[0], point22[1], 2);
            stream.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v28) {
          var t4;
          if (!(c6 & c0) && (t4 = intersect2(point1, point0, true))) {
            clean2 = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t4[0][0], t4[0][1]);
              stream.point(t4[1][0], t4[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t4[1][0], t4[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t4[0][0], t4[0][1], 3);
            }
          }
        }
        if (v28 && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v28, c0 = c6;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean2 | (v00 && v0) << 1;
      }
    };
  }
  function intersect2(a7, b25, two) {
    var pa = cartesian(a7), pb = cartesian(b25);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant) return !two && a7;
    var c1 = cr * n2n2 / determinant, c22 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A8 = cartesianScale(n1, c1), B12 = cartesianScale(n2, c22);
    cartesianAddInPlace(A8, B12);
    var u15 = n1xn2, w14 = cartesianDot(A8, u15), uu = cartesianDot(u15, u15), t22 = w14 * w14 - uu * (cartesianDot(A8, A8) - 1);
    if (t22 < 0) return;
    var t4 = sqrt4(t22), q3 = cartesianScale(u15, (-w14 - t4) / uu);
    cartesianAddInPlace(q3, A8);
    q3 = spherical(q3);
    if (!two) return q3;
    var lambda0 = a7[0], lambda1 = b25[0], phi02 = a7[1], phi1 = b25[1], z3;
    if (lambda1 < lambda0) z3 = lambda0, lambda0 = lambda1, lambda1 = z3;
    var delta2 = lambda1 - lambda0, polar = abs3(delta2 - pi4) < epsilon5, meridian = polar || delta2 < epsilon5;
    if (!polar && phi1 < phi02) z3 = phi02, phi02 = phi1, phi1 = z3;
    if (meridian ? polar ? phi02 + phi1 > 0 ^ q3[1] < (abs3(q3[0] - lambda0) < epsilon5 ? phi02 : phi1) : phi02 <= q3[1] && q3[1] <= phi1 : delta2 > pi4 ^ (lambda0 <= q3[0] && q3[0] <= lambda1)) {
      var q1 = cartesianScale(u15, (-w14 + t4) / uu);
      cartesianAddInPlace(q1, A8);
      return [q3, spherical(q1)];
    }
  }
  function code(lambda, phi2) {
    var r4 = smallRadius ? radius : pi4 - radius, code2 = 0;
    if (lambda < -r4) code2 |= 1;
    else if (lambda > r4) code2 |= 2;
    if (phi2 < -r4) code2 |= 4;
    else if (phi2 > r4) code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi4, radius - pi4]);
}

// node_modules/d3-geo/src/clip/line.js
function line_default2(a7, b25, x06, y06, x110, y110) {
  var ax = a7[0], ay = a7[1], bx = b25[0], by = b25[1], t03 = 0, t13 = 1, dx = bx - ax, dy = by - ay, r4;
  r4 = x06 - ax;
  if (!dx && r4 > 0) return;
  r4 /= dx;
  if (dx < 0) {
    if (r4 < t03) return;
    if (r4 < t13) t13 = r4;
  } else if (dx > 0) {
    if (r4 > t13) return;
    if (r4 > t03) t03 = r4;
  }
  r4 = x110 - ax;
  if (!dx && r4 < 0) return;
  r4 /= dx;
  if (dx < 0) {
    if (r4 > t13) return;
    if (r4 > t03) t03 = r4;
  } else if (dx > 0) {
    if (r4 < t03) return;
    if (r4 < t13) t13 = r4;
  }
  r4 = y06 - ay;
  if (!dy && r4 > 0) return;
  r4 /= dy;
  if (dy < 0) {
    if (r4 < t03) return;
    if (r4 < t13) t13 = r4;
  } else if (dy > 0) {
    if (r4 > t13) return;
    if (r4 > t03) t03 = r4;
  }
  r4 = y110 - ay;
  if (!dy && r4 < 0) return;
  r4 /= dy;
  if (dy < 0) {
    if (r4 > t13) return;
    if (r4 > t03) t03 = r4;
  } else if (dy > 0) {
    if (r4 < t03) return;
    if (r4 < t13) t13 = r4;
  }
  if (t03 > 0) a7[0] = ax + t03 * dx, a7[1] = ay + t03 * dy;
  if (t13 < 1) b25[0] = ax + t13 * dx, b25[1] = ay + t13 * dy;
  return true;
}

// node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x06, y06, x110, y110) {
  function visible(x21, y25) {
    return x06 <= x21 && x21 <= x110 && y06 <= y25 && y25 <= y110;
  }
  function interpolate(from, to, direction, stream) {
    var a7 = 0, a1 = 0;
    if (from == null || (a7 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream.point(a7 === 0 || a7 === 3 ? x06 : x110, a7 > 1 ? y110 : y06);
      while ((a7 = (a7 + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p13, direction) {
    return abs3(p13[0] - x06) < epsilon5 ? direction > 0 ? 0 : 3 : abs3(p13[0] - x110) < epsilon5 ? direction > 0 ? 2 : 1 : abs3(p13[1] - y06) < epsilon5 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a7, b25) {
    return comparePoint(a7.x, b25.x);
  }
  function comparePoint(a7, b25) {
    var ca = corner(a7, 1), cb = corner(b25, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b25[1] - a7[1] : ca === 1 ? a7[0] - b25[0] : ca === 2 ? a7[1] - b25[1] : b25[0] - a7[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default(), segments, polygon2, ring, x__, y__, v__, x_, y_, v_, first, clean2;
    var clipStream = {
      point: point13,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point13(x21, y25) {
      if (visible(x21, y25)) activeStream.point(x21, y25);
    }
    function polygonInside() {
      var winding = 0;
      for (var i8 = 0, n = polygon2.length; i8 < n; ++i8) {
        for (var ring2 = polygon2[i8], j6 = 1, m30 = ring2.length, point14 = ring2[0], a0, a1, b02 = point14[0], b110 = point14[1]; j6 < m30; ++j6) {
          a0 = b02, a1 = b110, point14 = ring2[j6], b02 = point14[0], b110 = point14[1];
          if (a1 <= y110) {
            if (b110 > y110 && (b02 - a0) * (y110 - a1) > (b110 - a1) * (x06 - a0)) ++winding;
          } else {
            if (b110 <= y110 && (b02 - a0) * (y110 - a1) < (b110 - a1) * (x06 - a0)) --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon2 = [], clean2 = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean2 && startInside, visible2 = (segments = merge(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments, compareIntersection2, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon2 = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint;
      if (polygon2) polygon2.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point13;
      if (v_) activeStream.lineEnd();
    }
    function linePoint(x21, y25) {
      var v28 = visible(x21, y25);
      if (polygon2) ring.push([x21, y25]);
      if (first) {
        x__ = x21, y__ = y25, v__ = v28;
        first = false;
        if (v28) {
          activeStream.lineStart();
          activeStream.point(x21, y25);
        }
      } else {
        if (v28 && v_) activeStream.point(x21, y25);
        else {
          var a7 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b25 = [x21 = Math.max(clipMin, Math.min(clipMax, x21)), y25 = Math.max(clipMin, Math.min(clipMax, y25))];
          if (line_default2(a7, b25, x06, y06, x110, y110)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a7[0], a7[1]);
            }
            activeStream.point(b25[0], b25[1]);
            if (!v28) activeStream.lineEnd();
            clean2 = false;
          } else if (v28) {
            activeStream.lineStart();
            activeStream.point(x21, y25);
            clean2 = false;
          }
        }
      }
      x_ = x21, y_ = y25, v_ = v28;
    }
    return clipStream;
  };
}

// node_modules/d3-geo/src/identity.js
var identity_default4 = (x21) => x21;

// node_modules/d3-geo/src/path/area.js
var areaSum2 = new Adder();
var areaRingSum2 = new Adder();
var x00;
var y00;
var x0;
var y0;
var areaStream2 = {
  point: noop,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: function() {
    areaStream2.lineStart = areaRingStart;
    areaStream2.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop;
    areaSum2.add(abs3(areaRingSum2));
    areaRingSum2 = new Adder();
  },
  result: function() {
    var area2 = areaSum2 / 2;
    areaSum2 = new Adder();
    return area2;
  }
};
function areaRingStart() {
  areaStream2.point = areaPointFirst;
}
function areaPointFirst(x21, y25) {
  areaStream2.point = areaPoint;
  x00 = x0 = x21, y00 = y0 = y25;
}
function areaPoint(x21, y25) {
  areaRingSum2.add(y0 * x21 - x0 * y25);
  x0 = x21, y0 = y25;
}
function areaRingEnd() {
  areaPoint(x00, y00);
}
var area_default2 = areaStream2;

// node_modules/d3-geo/src/path/bounds.js
var x02 = Infinity;
var y02 = x02;
var x1 = -x02;
var y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop,
  result: function() {
    var bounds = [[x02, y02], [x1, y1]];
    x1 = y1 = -(y02 = x02 = Infinity);
    return bounds;
  }
};
function boundsPoint(x21, y25) {
  if (x21 < x02) x02 = x21;
  if (x21 > x1) x1 = x21;
  if (y25 < y02) y02 = y25;
  if (y25 > y1) y1 = y25;
}
var bounds_default = boundsStream;

// node_modules/d3-geo/src/path/centroid.js
var X0 = 0;
var Y0 = 0;
var Z0 = 0;
var X1 = 0;
var Y1 = 0;
var Z1 = 0;
var X2 = 0;
var Y2 = 0;
var Z2 = 0;
var x002;
var y002;
var x03;
var y03;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    return centroid;
  }
};
function centroidPoint(x21, y25) {
  X0 += x21;
  Y0 += y25;
  ++Z0;
}
function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x21, y25) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x03 = x21, y03 = y25);
}
function centroidPointLine(x21, y25) {
  var dx = x21 - x03, dy = y25 - y03, z3 = sqrt4(dx * dx + dy * dy);
  X1 += z3 * (x03 + x21) / 2;
  Y1 += z3 * (y03 + y25) / 2;
  Z1 += z3;
  centroidPoint(x03 = x21, y03 = y25);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}
function centroidRingEnd() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x21, y25) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x002 = x03 = x21, y002 = y03 = y25);
}
function centroidPointRing(x21, y25) {
  var dx = x21 - x03, dy = y25 - y03, z3 = sqrt4(dx * dx + dy * dy);
  X1 += z3 * (x03 + x21) / 2;
  Y1 += z3 * (y03 + y25) / 2;
  Z1 += z3;
  z3 = y03 * x21 - x03 * y25;
  X2 += z3 * (x03 + x21);
  Y2 += z3 * (y03 + y25);
  Z2 += z3 * 3;
  centroidPoint(x03 = x21, y03 = y25);
}
var centroid_default = centroidStream;

// node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_17) {
    return this._radius = _17, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x21, y25) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x21, y25);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x21, y25);
        break;
      }
      default: {
        this._context.moveTo(x21 + this._radius, y25);
        this._context.arc(x21, y25, this._radius, 0, tau4);
        break;
      }
    }
  },
  result: noop
};

// node_modules/d3-geo/src/path/measure.js
var lengthSum = new Adder();
var lengthRing;
var x003;
var y003;
var x04;
var y04;
var lengthStream = {
  point: noop,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint(x003, y003);
    lengthStream.point = noop;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum;
    lengthSum = new Adder();
    return length;
  }
};
function lengthPointFirst(x21, y25) {
  lengthStream.point = lengthPoint;
  x003 = x04 = x21, y003 = y04 = y25;
}
function lengthPoint(x21, y25) {
  x04 -= x21, y04 -= y25;
  lengthSum.add(sqrt4(x04 * x04 + y04 * y04));
  x04 = x21, y04 = y25;
}
var measure_default = lengthStream;

// node_modules/d3-geo/src/path/string.js
var cacheDigits;
var cacheAppend;
var cacheRadius;
var cacheCircle;
var PathString = class {
  constructor(digits) {
    this._append = digits == null ? append2 : appendRound2(digits);
    this._radius = 4.5;
    this._ = "";
  }
  pointRadius(_17) {
    this._radius = +_17;
    return this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line === 0) this._ += "Z";
    this._point = NaN;
  }
  point(x21, y25) {
    switch (this._point) {
      case 0: {
        this._append`M${x21},${y25}`;
        this._point = 1;
        break;
      }
      case 1: {
        this._append`L${x21},${y25}`;
        break;
      }
      default: {
        this._append`M${x21},${y25}`;
        if (this._radius !== cacheRadius || this._append !== cacheAppend) {
          const r4 = this._radius;
          const s12 = this._;
          this._ = "";
          this._append`m0,${r4}a${r4},${r4} 0 1,1 0,${-2 * r4}a${r4},${r4} 0 1,1 0,${2 * r4}z`;
          cacheRadius = r4;
          cacheAppend = this._append;
          cacheCircle = this._;
          this._ = s12;
        }
        this._ += cacheCircle;
        break;
      }
    }
  }
  result() {
    const result = this._;
    this._ = "";
    return result.length ? result : null;
  }
};
function append2(strings) {
  let i8 = 1;
  this._ += strings[0];
  for (const j6 = strings.length; i8 < j6; ++i8) {
    this._ += arguments[i8] + strings[i8];
  }
}
function appendRound2(digits) {
  const d18 = Math.floor(digits);
  if (!(d18 >= 0)) throw new RangeError(`invalid digits: ${digits}`);
  if (d18 > 15) return append2;
  if (d18 !== cacheDigits) {
    const k17 = 10 ** d18;
    cacheDigits = d18;
    cacheAppend = function append3(strings) {
      let i8 = 1;
      this._ += strings[0];
      for (const j6 = strings.length; i8 < j6; ++i8) {
        this._ += Math.round(arguments[i8] * k17) / k17 + strings[i8];
      }
    };
  }
  return cacheAppend;
}

// node_modules/d3-geo/src/path/index.js
function path_default(projection2, context) {
  let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
  function path3(object2) {
    if (object2) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object2, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path3.area = function(object2) {
    stream_default(object2, projectionStream(area_default2));
    return area_default2.result();
  };
  path3.measure = function(object2) {
    stream_default(object2, projectionStream(measure_default));
    return measure_default.result();
  };
  path3.bounds = function(object2) {
    stream_default(object2, projectionStream(bounds_default));
    return bounds_default.result();
  };
  path3.centroid = function(object2) {
    stream_default(object2, projectionStream(centroid_default));
    return centroid_default.result();
  };
  path3.projection = function(_17) {
    if (!arguments.length) return projection2;
    projectionStream = _17 == null ? (projection2 = null, identity_default4) : (projection2 = _17).stream;
    return path3;
  };
  path3.context = function(_17) {
    if (!arguments.length) return context;
    contextStream = _17 == null ? (context = null, new PathString(digits)) : new PathContext(context = _17);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path3;
  };
  path3.pointRadius = function(_17) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _17 === "function" ? _17 : (contextStream.pointRadius(+_17), +_17);
    return path3;
  };
  path3.digits = function(_17) {
    if (!arguments.length) return digits;
    if (_17 == null) digits = null;
    else {
      const d18 = Math.floor(_17);
      if (!(d18 >= 0)) throw new RangeError(`invalid digits: ${_17}`);
      digits = d18;
    }
    if (context === null) contextStream = new PathString(digits);
    return path3;
  };
  return path3.projection(projection2).digits(digits).context(context);
}

// node_modules/d3-geo/src/transform.js
function transformer4(methods) {
  return function(stream) {
    var s12 = new TransformStream();
    for (var key in methods) s12[key] = methods[key];
    s12.stream = stream;
    return s12;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x21, y25) {
    this.stream.point(x21, y25);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// node_modules/d3-geo/src/projection/fit.js
function fit(projection2, fitBounds, object2) {
  var clip = projection2.clipExtent && projection2.clipExtent();
  projection2.scale(150).translate([0, 0]);
  if (clip != null) projection2.clipExtent(null);
  stream_default(object2, projection2.stream(bounds_default));
  fitBounds(bounds_default.result());
  if (clip != null) projection2.clipExtent(clip);
  return projection2;
}
function fitExtent(projection2, extent2, object2) {
  return fit(projection2, function(b25) {
    var w14 = extent2[1][0] - extent2[0][0], h17 = extent2[1][1] - extent2[0][1], k17 = Math.min(w14 / (b25[1][0] - b25[0][0]), h17 / (b25[1][1] - b25[0][1])), x21 = +extent2[0][0] + (w14 - k17 * (b25[1][0] + b25[0][0])) / 2, y25 = +extent2[0][1] + (h17 - k17 * (b25[1][1] + b25[0][1])) / 2;
    projection2.scale(150 * k17).translate([x21, y25]);
  }, object2);
}
function fitSize(projection2, size2, object2) {
  return fitExtent(projection2, [[0, 0], size2], object2);
}
function fitWidth(projection2, width, object2) {
  return fit(projection2, function(b25) {
    var w14 = +width, k17 = w14 / (b25[1][0] - b25[0][0]), x21 = (w14 - k17 * (b25[1][0] + b25[0][0])) / 2, y25 = -k17 * b25[0][1];
    projection2.scale(150 * k17).translate([x21, y25]);
  }, object2);
}
function fitHeight(projection2, height, object2) {
  return fit(projection2, function(b25) {
    var h17 = +height, k17 = h17 / (b25[1][1] - b25[0][1]), x21 = -k17 * b25[0][0], y25 = (h17 - k17 * (b25[1][1] + b25[0][1])) / 2;
    projection2.scale(150 * k17).translate([x21, y25]);
  }, object2);
}

// node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos2(30 * radians2);
function resample_default(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}
function resampleNone(project) {
  return transformer4({
    point: function(x21, y25) {
      x21 = project(x21, y25);
      this.stream.point(x21[0], x21[1]);
    }
  });
}
function resample(project, delta2) {
  function resampleLineTo(x06, y06, lambda0, a0, b02, c0, x110, y110, lambda1, a1, b110, c1, depth, stream) {
    var dx = x110 - x06, dy = y110 - y06, d22 = dx * dx + dy * dy;
    if (d22 > 4 * delta2 && depth--) {
      var a7 = a0 + a1, b25 = b02 + b110, c6 = c0 + c1, m30 = sqrt4(a7 * a7 + b25 * b25 + c6 * c6), phi2 = asin2(c6 /= m30), lambda2 = abs3(abs3(c6) - 1) < epsilon5 || abs3(lambda0 - lambda1) < epsilon5 ? (lambda0 + lambda1) / 2 : atan22(b25, a7), p13 = project(lambda2, phi2), x22 = p13[0], y25 = p13[1], dx2 = x22 - x06, dy2 = y25 - y06, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d22 > delta2 || abs3((dx * dx2 + dy * dy2) / d22 - 0.5) > 0.3 || a0 * a1 + b02 * b110 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x06, y06, lambda0, a0, b02, c0, x22, y25, lambda2, a7 /= m30, b25 /= m30, c6, depth, stream);
        stream.point(x22, y25);
        resampleLineTo(x22, y25, lambda2, a7, b25, c6, x110, y110, lambda1, a1, b110, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x004, y004, a00, b00, c00, lambda0, x06, y06, a0, b02, c0;
    var resampleStream = {
      point: point13,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point13(x21, y25) {
      x21 = project(x21, y25);
      stream.point(x21[0], x21[1]);
    }
    function lineStart() {
      x06 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }
    function linePoint(lambda, phi2) {
      var c6 = cartesian([lambda, phi2]), p13 = project(lambda, phi2);
      resampleLineTo(x06, y06, lambda0, a0, b02, c0, x06 = p13[0], y06 = p13[1], lambda0 = lambda, a0 = c6[0], b02 = c6[1], c0 = c6[2], maxDepth, stream);
      stream.point(x06, y06);
    }
    function lineEnd() {
      resampleStream.point = point13;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint(lambda00 = lambda, phi2), x004 = x06, y004 = y06, a00 = a0, b00 = b02, c00 = c0;
      resampleStream.point = linePoint;
    }
    function ringEnd() {
      resampleLineTo(x06, y06, lambda0, a0, b02, c0, x004, y004, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer4({
  point: function(x21, y25) {
    this.stream.point(x21 * radians2, y25 * radians2);
  }
});
function transformRotate(rotate) {
  return transformer4({
    point: function(x21, y25) {
      var r4 = rotate(x21, y25);
      return this.stream.point(r4[0], r4[1]);
    }
  });
}
function scaleTranslate(k17, dx, dy, sx, sy) {
  function transform2(x21, y25) {
    x21 *= sx;
    y25 *= sy;
    return [dx + k17 * x21, dy - k17 * y25];
  }
  transform2.invert = function(x21, y25) {
    return [(x21 - dx) / k17 * sx, (dy - y25) / k17 * sy];
  };
  return transform2;
}
function scaleTranslateRotate(k17, dx, dy, sx, sy, alpha) {
  if (!alpha) return scaleTranslate(k17, dx, dy, sx, sy);
  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a7 = cosAlpha * k17, b25 = sinAlpha * k17, ai = cosAlpha / k17, bi = sinAlpha / k17, ci = (sinAlpha * dy - cosAlpha * dx) / k17, fi = (sinAlpha * dx + cosAlpha * dy) / k17;
  function transform2(x21, y25) {
    x21 *= sx;
    y25 *= sy;
    return [a7 * x21 - b25 * y25 + dx, dy - b25 * x21 - a7 * y25];
  }
  transform2.invert = function(x21, y25) {
    return [sx * (ai * x21 - bi * y25 + ci), sy * (fi - bi * x21 - ai * y25)];
  };
  return transform2;
}
function projection(project) {
  return projectionMutator(function() {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project, k17 = 150, x21 = 480, y25 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x06 = null, y06, x110, y110, postclip = identity_default4, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache2, cacheStream;
  function projection2(point13) {
    return projectRotateTransform(point13[0] * radians2, point13[1] * radians2);
  }
  function invert(point13) {
    point13 = projectRotateTransform.invert(point13[0], point13[1]);
    return point13 && [point13[0] * degrees3, point13[1] * degrees3];
  }
  projection2.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection2.preclip = function(_17) {
    return arguments.length ? (preclip = _17, theta = void 0, reset()) : preclip;
  };
  projection2.postclip = function(_17) {
    return arguments.length ? (postclip = _17, x06 = y06 = x110 = y110 = null, reset()) : postclip;
  };
  projection2.clipAngle = function(_17) {
    return arguments.length ? (preclip = +_17 ? circle_default2(theta = _17 * radians2) : (theta = null, antimeridian_default), reset()) : theta * degrees3;
  };
  projection2.clipExtent = function(_17) {
    return arguments.length ? (postclip = _17 == null ? (x06 = y06 = x110 = y110 = null, identity_default4) : clipRectangle(x06 = +_17[0][0], y06 = +_17[0][1], x110 = +_17[1][0], y110 = +_17[1][1]), reset()) : x06 == null ? null : [[x06, y06], [x110, y110]];
  };
  projection2.scale = function(_17) {
    return arguments.length ? (k17 = +_17, recenter()) : k17;
  };
  projection2.translate = function(_17) {
    return arguments.length ? (x21 = +_17[0], y25 = +_17[1], recenter()) : [x21, y25];
  };
  projection2.center = function(_17) {
    return arguments.length ? (lambda = _17[0] % 360 * radians2, phi2 = _17[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi2 * degrees3];
  };
  projection2.rotate = function(_17) {
    return arguments.length ? (deltaLambda = _17[0] % 360 * radians2, deltaPhi = _17[1] % 360 * radians2, deltaGamma = _17.length > 2 ? _17[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];
  };
  projection2.angle = function(_17) {
    return arguments.length ? (alpha = _17 % 360 * radians2, recenter()) : alpha * degrees3;
  };
  projection2.reflectX = function(_17) {
    return arguments.length ? (sx = _17 ? -1 : 1, recenter()) : sx < 0;
  };
  projection2.reflectY = function(_17) {
    return arguments.length ? (sy = _17 ? -1 : 1, recenter()) : sy < 0;
  };
  projection2.precision = function(_17) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _17 * _17), reset()) : sqrt4(delta2);
  };
  projection2.fitExtent = function(extent2, object2) {
    return fitExtent(projection2, extent2, object2);
  };
  projection2.fitSize = function(size2, object2) {
    return fitSize(projection2, size2, object2);
  };
  projection2.fitWidth = function(width, object2) {
    return fitWidth(projection2, width, object2);
  };
  projection2.fitHeight = function(height, object2) {
    return fitHeight(projection2, height, object2);
  };
  function recenter() {
    var center3 = scaleTranslateRotate(k17, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi2)), transform2 = scaleTranslateRotate(k17, x21 - center3[0], y25 - center3[1], sx, sy, alpha);
    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project, transform2);
    projectRotateTransform = compose_default(rotate, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset();
  }
  function reset() {
    cache2 = cacheStream = null;
    return projection2;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection2.invert = project.invert && invert;
    return recenter();
  };
}

// node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi02 = 0, phi1 = pi4 / 3, m30 = projectionMutator(projectAt), p13 = m30(phi02, phi1);
  p13.parallels = function(_17) {
    return arguments.length ? m30(phi02 = _17[0] * radians2, phi1 = _17[1] * radians2) : [phi02 * degrees3, phi1 * degrees3];
  };
  return p13;
}

// node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi02) {
  var cosPhi0 = cos2(phi02);
  function forward(lambda, phi2) {
    return [lambda * cosPhi0, sin2(phi2) / cosPhi0];
  }
  forward.invert = function(x21, y25) {
    return [x21 / cosPhi0, asin2(y25 * cosPhi0)];
  };
  return forward;
}

// node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y06, y110) {
  var sy0 = sin2(y06), n = (sy0 + sin2(y110)) / 2;
  if (abs3(n) < epsilon5) return cylindricalEqualAreaRaw(y06);
  var c6 = 1 + sy0 * (2 * n - sy0), r0 = sqrt4(c6) / n;
  function project(x21, y25) {
    var r4 = sqrt4(c6 - 2 * n * sin2(y25)) / n;
    return [r4 * sin2(x21 *= n), r0 - r4 * cos2(x21)];
  }
  project.invert = function(x21, y25) {
    var r0y = r0 - y25, l7 = atan22(x21, abs3(r0y)) * sign2(r0y);
    if (r0y * n < 0)
      l7 -= pi4 * sign2(x21) * sign2(r0y);
    return [l7 / n, asin2((c6 - (x21 * x21 + r0y * r0y) * n * n) / (2 * n))];
  };
  return project;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

// node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

// node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x21, y25) {
      var i8 = -1;
      while (++i8 < n) streams[i8].point(x21, y25);
    },
    sphere: function() {
      var i8 = -1;
      while (++i8 < n) streams[i8].sphere();
    },
    lineStart: function() {
      var i8 = -1;
      while (++i8 < n) streams[i8].lineStart();
    },
    lineEnd: function() {
      var i8 = -1;
      while (++i8 < n) streams[i8].lineEnd();
    },
    polygonStart: function() {
      var i8 = -1;
      while (++i8 < n) streams[i8].polygonStart();
    },
    polygonEnd: function() {
      var i8 = -1;
      while (++i8 < n) streams[i8].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache2, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point13, pointStream = { point: function(x21, y25) {
    point13 = [x21, y25];
  } };
  function albersUsa(coordinates) {
    var x21 = coordinates[0], y25 = coordinates[1];
    return point13 = null, (lower48Point.point(x21, y25), point13) || (alaskaPoint.point(x21, y25), point13) || (hawaiiPoint.point(x21, y25), point13);
  }
  albersUsa.invert = function(coordinates) {
    var k17 = lower48.scale(), t4 = lower48.translate(), x21 = (coordinates[0] - t4[0]) / k17, y25 = (coordinates[1] - t4[1]) / k17;
    return (y25 >= 0.12 && y25 < 0.234 && x21 >= -0.425 && x21 < -0.214 ? alaska : y25 >= 0.166 && y25 < 0.234 && x21 >= -0.214 && x21 < -0.115 ? hawaii : lower48).invert(coordinates);
  };
  albersUsa.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa.precision = function(_17) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_17), alaska.precision(_17), hawaii.precision(_17);
    return reset();
  };
  albersUsa.scale = function(_17) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_17), alaska.scale(_17 * 0.35), hawaii.scale(_17);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_17) {
    if (!arguments.length) return lower48.translate();
    var k17 = lower48.scale(), x21 = +_17[0], y25 = +_17[1];
    lower48Point = lower48.translate(_17).clipExtent([[x21 - 0.455 * k17, y25 - 0.238 * k17], [x21 + 0.455 * k17, y25 + 0.238 * k17]]).stream(pointStream);
    alaskaPoint = alaska.translate([x21 - 0.307 * k17, y25 + 0.201 * k17]).clipExtent([[x21 - 0.425 * k17 + epsilon5, y25 + 0.12 * k17 + epsilon5], [x21 - 0.214 * k17 - epsilon5, y25 + 0.234 * k17 - epsilon5]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x21 - 0.205 * k17, y25 + 0.212 * k17]).clipExtent([[x21 - 0.214 * k17 + epsilon5, y25 + 0.166 * k17 + epsilon5], [x21 - 0.115 * k17 - epsilon5, y25 + 0.234 * k17 - epsilon5]]).stream(pointStream);
    return reset();
  };
  albersUsa.fitExtent = function(extent2, object2) {
    return fitExtent(albersUsa, extent2, object2);
  };
  albersUsa.fitSize = function(size2, object2) {
    return fitSize(albersUsa, size2, object2);
  };
  albersUsa.fitWidth = function(width, object2) {
    return fitWidth(albersUsa, width, object2);
  };
  albersUsa.fitHeight = function(height, object2) {
    return fitHeight(albersUsa, height, object2);
  };
  function reset() {
    cache2 = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale) {
  return function(x21, y25) {
    var cx = cos2(x21), cy = cos2(y25), k17 = scale(cx * cy);
    if (k17 === Infinity) return [2, 0];
    return [
      k17 * cy * sin2(x21),
      k17 * sin2(y25)
    ];
  };
}
function azimuthalInvert(angle) {
  return function(x21, y25) {
    var z3 = sqrt4(x21 * x21 + y25 * y25), c6 = angle(z3), sc = sin2(c6), cc = cos2(c6);
    return [
      atan22(x21 * sc, z3 * cc),
      asin2(z3 && y25 * sc / z3)
    ];
  };
}

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt4(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z3) {
  return 2 * asin2(z3 / 2);
});
function azimuthalEqualArea_default() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c6) {
  return (c6 = acos2(c6)) && c6 / sin2(c6);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z3) {
  return z3;
});
function azimuthalEquidistant_default() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi2) {
  return [lambda, log2(tan((halfPi3 + phi2) / 2))];
}
mercatorRaw.invert = function(x21, y25) {
  return [x21, 2 * atan(exp(y25)) - halfPi3];
};
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau4);
}
function mercatorProjection(project) {
  var m30 = projection(project), center3 = m30.center, scale = m30.scale, translate = m30.translate, clipExtent = m30.clipExtent, x06 = null, y06, x110, y110;
  m30.scale = function(_17) {
    return arguments.length ? (scale(_17), reclip()) : scale();
  };
  m30.translate = function(_17) {
    return arguments.length ? (translate(_17), reclip()) : translate();
  };
  m30.center = function(_17) {
    return arguments.length ? (center3(_17), reclip()) : center3();
  };
  m30.clipExtent = function(_17) {
    return arguments.length ? (_17 == null ? x06 = y06 = x110 = y110 = null : (x06 = +_17[0][0], y06 = +_17[0][1], x110 = +_17[1][0], y110 = +_17[1][1]), reclip()) : x06 == null ? null : [[x06, y06], [x110, y110]];
  };
  function reclip() {
    var k17 = pi4 * scale(), t4 = m30(rotation_default(m30.rotate()).invert([0, 0]));
    return clipExtent(x06 == null ? [[t4[0] - k17, t4[1] - k17], [t4[0] + k17, t4[1] + k17]] : project === mercatorRaw ? [[Math.max(t4[0] - k17, x06), y06], [Math.min(t4[0] + k17, x110), y110]] : [[x06, Math.max(t4[1] - k17, y06)], [x110, Math.min(t4[1] + k17, y110)]]);
  }
  return reclip();
}

// node_modules/d3-geo/src/projection/conicConformal.js
function tany(y25) {
  return tan((halfPi3 + y25) / 2);
}
function conicConformalRaw(y06, y110) {
  var cy0 = cos2(y06), n = y06 === y110 ? sin2(y06) : log2(cy0 / cos2(y110)) / log2(tany(y110) / tany(y06)), f29 = cy0 * pow2(tany(y06), n) / n;
  if (!n) return mercatorRaw;
  function project(x21, y25) {
    if (f29 > 0) {
      if (y25 < -halfPi3 + epsilon5) y25 = -halfPi3 + epsilon5;
    } else {
      if (y25 > halfPi3 - epsilon5) y25 = halfPi3 - epsilon5;
    }
    var r4 = f29 / pow2(tany(y25), n);
    return [r4 * sin2(n * x21), f29 - r4 * cos2(n * x21)];
  }
  project.invert = function(x21, y25) {
    var fy = f29 - y25, r4 = sign2(n) * sqrt4(x21 * x21 + fy * fy), l7 = atan22(x21, abs3(fy)) * sign2(fy);
    if (fy * n < 0)
      l7 -= pi4 * sign2(x21) * sign2(fy);
    return [l7 / n, 2 * atan(pow2(f29 / r4, 1 / n)) - halfPi3];
  };
  return project;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular_default() {
  return projection(equirectangularRaw).scale(152.63);
}

// node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y06, y110) {
  var cy0 = cos2(y06), n = y06 === y110 ? sin2(y06) : (cy0 - cos2(y110)) / (y110 - y06), g15 = cy0 / n + y06;
  if (abs3(n) < epsilon5) return equirectangularRaw;
  function project(x21, y25) {
    var gy = g15 - y25, nx = n * x21;
    return [gy * sin2(nx), g15 - gy * cos2(nx)];
  }
  project.invert = function(x21, y25) {
    var gy = g15 - y25, l7 = atan22(x21, abs3(gy)) * sign2(gy);
    if (gy * n < 0)
      l7 -= pi4 * sign2(x21) * sign2(gy);
    return [l7 / n, g15 - sign2(n) * sqrt4(x21 * x21 + gy * gy)];
  };
  return project;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

// node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A2 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M = sqrt4(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi2) {
  var l7 = asin2(M * sin2(phi2)), l22 = l7 * l7, l62 = l22 * l22 * l22;
  return [
    lambda * cos2(l7) / (M * (A1 + 3 * A2 * l22 + l62 * (7 * A3 + 9 * A4 * l22))),
    l7 * (A1 + A2 * l22 + l62 * (A3 + A4 * l22))
  ];
}
equalEarthRaw.invert = function(x21, y25) {
  var l7 = y25, l22 = l7 * l7, l62 = l22 * l22 * l22;
  for (var i8 = 0, delta, fy, fpy; i8 < iterations; ++i8) {
    fy = l7 * (A1 + A2 * l22 + l62 * (A3 + A4 * l22)) - y25;
    fpy = A1 + 3 * A2 * l22 + l62 * (7 * A3 + 9 * A4 * l22);
    l7 -= delta = fy / fpy, l22 = l7 * l7, l62 = l22 * l22 * l22;
    if (abs3(delta) < epsilon22) break;
  }
  return [
    M * x21 * (A1 + 3 * A2 * l22 + l62 * (7 * A3 + 9 * A4 * l22)) / cos2(l7),
    asin2(sin2(l7) / M)
  ];
};
function equalEarth_default() {
  return projection(equalEarthRaw).scale(177.158);
}

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x21, y25) {
  var cy = cos2(y25), k17 = cos2(x21) * cy;
  return [cy * sin2(x21) / k17, sin2(y25) / k17];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic_default() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}

// node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x21, y25) {
  var phi2 = y25, i8 = 25, delta;
  do {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y25) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
  } while (abs3(delta) > epsilon5 && --i8 > 0);
  return [
    x21 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
    phi2
  ];
};
function naturalEarth1_default() {
  return projection(naturalEarth1Raw).scale(175.295);
}

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x21, y25) {
  return [cos2(y25) * sin2(x21), sin2(y25)];
}
orthographicRaw.invert = azimuthalInvert(asin2);
function orthographic_default() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon5);
}

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x21, y25) {
  var cy = cos2(y25), k17 = 1 + cos2(x21) * cy;
  return [cy * sin2(x21) / k17, sin2(y25) / k17];
}
stereographicRaw.invert = azimuthalInvert(function(z3) {
  return 2 * atan(z3);
});
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi2) {
  return [log2(tan((halfPi3 + phi2) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x21, y25) {
  return [-y25, 2 * atan(exp(x21)) - halfPi3];
};
function transverseMercator_default() {
  var m30 = mercatorProjection(transverseMercatorRaw), center3 = m30.center, rotate = m30.rotate;
  m30.center = function(_17) {
    return arguments.length ? center3([-_17[1], _17[0]]) : (_17 = center3(), [_17[1], -_17[0]]);
  };
  m30.rotate = function(_17) {
    return arguments.length ? rotate([_17[0], _17[1], _17.length > 2 ? _17[2] + 90 : 90]) : (_17 = rotate(), [_17[0], _17[1], _17[2] - 90]);
  };
  return rotate([0, 0, 90]).scale(159.155);
}

// node_modules/d3-geo-projection/src/math.js
var abs4 = Math.abs;
var atan3 = Math.atan;
var atan23 = Math.atan2;
var cos3 = Math.cos;
var exp2 = Math.exp;
var floor = Math.floor;
var log3 = Math.log;
var max4 = Math.max;
var min4 = Math.min;
var pow3 = Math.pow;
var sign3 = Math.sign || function(x21) {
  return x21 > 0 ? 1 : x21 < 0 ? -1 : 0;
};
var sin3 = Math.sin;
var tan2 = Math.tan;
var epsilon6 = 1e-6;
var epsilon23 = 1e-12;
var pi5 = Math.PI;
var halfPi4 = pi5 / 2;
var quarterPi2 = pi5 / 4;
var sqrt1_2 = Math.SQRT1_2;
var sqrt22 = sqrt5(2);
var sqrtPi = sqrt5(pi5);
var tau5 = pi5 * 2;
var degrees4 = 180 / pi5;
var radians3 = pi5 / 180;
function sinci(x21) {
  return x21 ? x21 / Math.sin(x21) : 1;
}
function asin3(x21) {
  return x21 > 1 ? halfPi4 : x21 < -1 ? -halfPi4 : Math.asin(x21);
}
function acos3(x21) {
  return x21 > 1 ? 0 : x21 < -1 ? pi5 : Math.acos(x21);
}
function sqrt5(x21) {
  return x21 > 0 ? Math.sqrt(x21) : 0;
}
function tanh2(x21) {
  x21 = exp2(2 * x21);
  return (x21 - 1) / (x21 + 1);
}
function sinh2(x21) {
  return (exp2(x21) - exp2(-x21)) / 2;
}
function cosh2(x21) {
  return (exp2(x21) + exp2(-x21)) / 2;
}
function arsinh(x21) {
  return log3(x21 + sqrt5(x21 * x21 + 1));
}
function arcosh(x21) {
  return log3(x21 + sqrt5(x21 * x21 - 1));
}

// node_modules/d3-geo-projection/src/aitoff.js
function aitoffRaw(x21, y25) {
  var cosy = cos3(y25), sincia = sinci(acos3(cosy * cos3(x21 /= 2)));
  return [2 * cosy * sin3(x21) * sincia, sin3(y25) * sincia];
}
aitoffRaw.invert = function(x21, y25) {
  if (x21 * x21 + 4 * y25 * y25 > pi5 * pi5 + epsilon6) return;
  var x110 = x21, y110 = y25, i8 = 25;
  do {
    var sinx = sin3(x110), sinx_2 = sin3(x110 / 2), cosx_2 = cos3(x110 / 2), siny = sin3(y110), cosy = cos3(y110), sin_2y = sin3(2 * y110), sin2y = siny * siny, cos2y = cosy * cosy, sin2x_2 = sinx_2 * sinx_2, c6 = 1 - cos2y * cosx_2 * cosx_2, e3 = c6 ? acos3(cosy * cosx_2) * sqrt5(f29 = 1 / c6) : f29 = 0, f29, fx = 2 * e3 * cosy * sinx_2 - x21, fy = e3 * siny - y25, dxdx = f29 * (cos2y * sin2x_2 + e3 * cosy * cosx_2 * sin2y), dxdy = f29 * (0.5 * sinx * sin_2y - e3 * 2 * siny * sinx_2), dydx = f29 * 0.25 * (sin_2y * sinx_2 - e3 * siny * cos2y * sinx), dydy = f29 * (sin2y * cosx_2 + e3 * sin2x_2 * cosy), z3 = dxdy * dydx - dydy * dxdx;
    if (!z3) break;
    var dx = (fy * dxdy - fx * dydy) / z3, dy = (fx * dydx - fy * dxdx) / z3;
    x110 -= dx, y110 -= dy;
  } while ((abs4(dx) > epsilon6 || abs4(dy) > epsilon6) && --i8 > 0);
  return [x110, y110];
};
function aitoff_default() {
  return projection(aitoffRaw).scale(152.63);
}

// node_modules/d3-geo-projection/src/armadillo.js
function armadilloRaw(phi02) {
  var sinPhi0 = sin3(phi02), cosPhi0 = cos3(phi02), sPhi0 = phi02 >= 0 ? 1 : -1, tanPhi0 = tan2(sPhi0 * phi02), k17 = (1 + sinPhi0 - cosPhi0) / 2;
  function forward(lambda, phi2) {
    var cosPhi = cos3(phi2), cosLambda = cos3(lambda /= 2);
    return [
      (1 + cosPhi) * sin3(lambda),
      (sPhi0 * phi2 > -atan23(cosLambda, tanPhi0) - 1e-3 ? 0 : -sPhi0 * 10) + k17 + sin3(phi2) * cosPhi0 - (1 + cosPhi) * sinPhi0 * cosLambda
      // TODO D3 core should allow null or [NaN, NaN] to be returned.
    ];
  }
  forward.invert = function(x21, y25) {
    var lambda = 0, phi2 = 0, i8 = 50;
    do {
      var cosLambda = cos3(lambda), sinLambda = sin3(lambda), cosPhi = cos3(phi2), sinPhi = sin3(phi2), A8 = 1 + cosPhi, fx = A8 * sinLambda - x21, fy = k17 + sinPhi * cosPhi0 - A8 * sinPhi0 * cosLambda - y25, dxdLambda = A8 * cosLambda / 2, dxdPhi = -sinLambda * sinPhi, dydLambda = sinPhi0 * A8 * sinLambda / 2, dydPhi = cosPhi0 * cosPhi + sinPhi0 * cosLambda * sinPhi, denominator = dxdPhi * dydLambda - dydPhi * dxdLambda, dLambda = (fy * dxdPhi - fx * dydPhi) / denominator / 2, dPhi = (fx * dydLambda - fy * dxdLambda) / denominator;
      if (abs4(dPhi) > 2) dPhi /= 2;
      lambda -= dLambda, phi2 -= dPhi;
    } while ((abs4(dLambda) > epsilon6 || abs4(dPhi) > epsilon6) && --i8 > 0);
    return sPhi0 * phi2 > -atan23(cos3(lambda), tanPhi0) - 1e-3 ? [lambda * 2, phi2] : null;
  };
  return forward;
}
function armadillo_default() {
  var phi02 = 20 * radians3, sPhi0 = phi02 >= 0 ? 1 : -1, tanPhi0 = tan2(sPhi0 * phi02), m30 = projectionMutator(armadilloRaw), p13 = m30(phi02), stream_ = p13.stream;
  p13.parallel = function(_17) {
    if (!arguments.length) return phi02 * degrees4;
    tanPhi0 = tan2((sPhi0 = (phi02 = _17 * radians3) >= 0 ? 1 : -1) * phi02);
    return m30(phi02);
  };
  p13.stream = function(stream) {
    var rotate = p13.rotate(), rotateStream = stream_(stream), sphereStream = (p13.rotate([0, 0]), stream_(stream)), precision = p13.precision();
    p13.rotate(rotate);
    rotateStream.sphere = function() {
      sphereStream.polygonStart(), sphereStream.lineStart();
      for (var lambda = sPhi0 * -180; sPhi0 * lambda < 180; lambda += sPhi0 * 90)
        sphereStream.point(lambda, sPhi0 * 90);
      if (phi02) while (sPhi0 * (lambda -= 3 * sPhi0 * precision) >= -180) {
        sphereStream.point(lambda, sPhi0 * -atan23(cos3(lambda * radians3 / 2), tanPhi0) * degrees4);
      }
      sphereStream.lineEnd(), sphereStream.polygonEnd();
    };
    return rotateStream;
  };
  return p13.scale(218.695).center([0, 28.0974]);
}

// node_modules/d3-geo-projection/src/august.js
function augustRaw(lambda, phi2) {
  var tanPhi = tan2(phi2 / 2), k17 = sqrt5(1 - tanPhi * tanPhi), c6 = 1 + k17 * cos3(lambda /= 2), x21 = sin3(lambda) * k17 / c6, y25 = tanPhi / c6, x22 = x21 * x21, y26 = y25 * y25;
  return [
    4 / 3 * x21 * (3 + x22 - 3 * y26),
    4 / 3 * y25 * (3 + 3 * x22 - y26)
  ];
}
augustRaw.invert = function(x21, y25) {
  x21 *= 3 / 8, y25 *= 3 / 8;
  if (!x21 && abs4(y25) > 1) return null;
  var x22 = x21 * x21, y26 = y25 * y25, s12 = 1 + x22 + y26, sin3Eta = sqrt5((s12 - sqrt5(s12 * s12 - 4 * y25 * y25)) / 2), eta = asin3(sin3Eta) / 3, xi = sin3Eta ? arcosh(abs4(y25 / sin3Eta)) / 3 : arsinh(abs4(x21)) / 3, cosEta = cos3(eta), coshXi = cosh2(xi), d18 = coshXi * coshXi - cosEta * cosEta;
  return [
    sign3(x21) * 2 * atan23(sinh2(xi) * cosEta, 0.25 - d18),
    sign3(y25) * 2 * atan23(coshXi * sin3(eta), 0.25 + d18)
  ];
};

// node_modules/d3-geo-projection/src/baker.js
var sqrt8 = sqrt5(8);
var phi0 = log3(1 + sqrt22);
function bakerRaw(lambda, phi2) {
  var phi02 = abs4(phi2);
  return phi02 < quarterPi2 ? [lambda, log3(tan2(quarterPi2 + phi2 / 2))] : [lambda * cos3(phi02) * (2 * sqrt22 - 1 / sin3(phi02)), sign3(phi2) * (2 * sqrt22 * (phi02 - quarterPi2) - log3(tan2(phi02 / 2)))];
}
bakerRaw.invert = function(x21, y25) {
  if ((y06 = abs4(y25)) < phi0) return [x21, 2 * atan3(exp2(y25)) - halfPi4];
  var phi2 = quarterPi2, i8 = 25, delta, y06;
  do {
    var cosPhi_2 = cos3(phi2 / 2), tanPhi_2 = tan2(phi2 / 2);
    phi2 -= delta = (sqrt8 * (phi2 - quarterPi2) - log3(tanPhi_2) - y06) / (sqrt8 - cosPhi_2 * cosPhi_2 / (2 * tanPhi_2));
  } while (abs4(delta) > epsilon23 && --i8 > 0);
  return [x21 / (cos3(phi2) * (sqrt8 - 1 / sin3(phi2))), sign3(y25) * phi2];
};
function baker_default() {
  return projection(bakerRaw).scale(112.314);
}

// node_modules/d3-geo-projection/src/hammer.js
function hammerQuarticAuthalicRaw(lambda, phi2) {
  return [
    lambda * cos3(phi2) / cos3(phi2 /= 2),
    2 * sin3(phi2)
  ];
}
hammerQuarticAuthalicRaw.invert = function(x21, y25) {
  var phi2 = 2 * asin3(y25 / 2);
  return [
    x21 * cos3(phi2 / 2) / cos3(phi2),
    phi2
  ];
};

// node_modules/d3-geo-projection/src/newton.js
function solve(f29, y25, x21) {
  var steps = 100, delta, f0, f1;
  x21 = x21 === void 0 ? 0 : +x21;
  y25 = +y25;
  do {
    f0 = f29(x21);
    f1 = f29(x21 + epsilon6);
    if (f0 === f1) f1 = f0 + epsilon6;
    x21 -= delta = -1 * epsilon6 * (f0 - y25) / (f0 - f1);
  } while (steps-- > 0 && abs4(delta) > epsilon6);
  return steps < 0 ? NaN : x21;
}

// node_modules/d3-geo-projection/src/mollweide.js
function mollweideBromleyTheta(cp, phi2) {
  var cpsinPhi = cp * sin3(phi2), i8 = 30, delta;
  do
    phi2 -= delta = (phi2 + sin3(phi2) - cpsinPhi) / (1 + cos3(phi2));
  while (abs4(delta) > epsilon6 && --i8 > 0);
  return phi2 / 2;
}
function mollweideBromleyRaw(cx, cy, cp) {
  function forward(lambda, phi2) {
    return [cx * lambda * cos3(phi2 = mollweideBromleyTheta(cp, phi2)), cy * sin3(phi2)];
  }
  forward.invert = function(x21, y25) {
    return y25 = asin3(y25 / cy), [x21 / (cx * cos3(y25)), asin3((2 * y25 + sin3(2 * y25)) / cp)];
  };
  return forward;
}
var mollweideRaw = mollweideBromleyRaw(sqrt22 / halfPi4, sqrt22, pi5);

// node_modules/d3-geo-projection/src/boggs.js
var k2 = 2.00276;
var w = 1.11072;
function boggsRaw(lambda, phi2) {
  var theta = mollweideBromleyTheta(pi5, phi2);
  return [k2 * lambda / (1 / cos3(phi2) + w / cos3(theta)), (phi2 + sqrt22 * sin3(theta)) / k2];
}
boggsRaw.invert = function(x21, y25) {
  var ky3 = k2 * y25, theta = y25 < 0 ? -quarterPi2 : quarterPi2, i8 = 25, delta, phi2;
  do {
    phi2 = ky3 - sqrt22 * sin3(theta);
    theta -= delta = (sin3(2 * theta) + 2 * theta - pi5 * sin3(phi2)) / (2 * cos3(2 * theta) + 2 + pi5 * cos3(phi2) * sqrt22 * cos3(theta));
  } while (abs4(delta) > epsilon6 && --i8 > 0);
  phi2 = ky3 - sqrt22 * sin3(theta);
  return [x21 * (1 / cos3(phi2) + w / cos3(theta)) / k2, phi2];
};
function boggs_default() {
  return projection(boggsRaw).scale(160.857);
}

// node_modules/d3-geo-projection/src/parallel1.js
function parallel1_default(projectAt) {
  var phi02 = 0, m30 = projectionMutator(projectAt), p13 = m30(phi02);
  p13.parallel = function(_17) {
    return arguments.length ? m30(phi02 = _17 * radians3) : phi02 * degrees4;
  };
  return p13;
}

// node_modules/d3-geo-projection/src/sinusoidal.js
function sinusoidalRaw(lambda, phi2) {
  return [lambda * cos3(phi2), phi2];
}
sinusoidalRaw.invert = function(x21, y25) {
  return [x21 / cos3(y25), y25];
};

// node_modules/d3-geo-projection/src/bromley.js
var bromleyRaw = mollweideBromleyRaw(1, 4 / pi5, pi5);
function bromley_default() {
  return projection(bromleyRaw).scale(152.63);
}

// node_modules/d3-geo-projection/src/collignon.js
function collignonRaw(lambda, phi2) {
  var alpha = sqrt5(1 - sin3(phi2));
  return [2 / sqrtPi * lambda * alpha, sqrtPi * (1 - alpha)];
}
collignonRaw.invert = function(x21, y25) {
  var lambda = (lambda = y25 / sqrtPi - 1) * lambda;
  return [lambda > 0 ? x21 * sqrt5(pi5 / lambda) / 2 : 0, asin3(1 - lambda)];
};

// node_modules/d3-geo-projection/src/craster.js
var sqrt34 = sqrt5(3);
function crasterRaw(lambda, phi2) {
  return [sqrt34 * lambda * (2 * cos3(2 * phi2 / 3) - 1) / sqrtPi, sqrt34 * sqrtPi * sin3(phi2 / 3)];
}
crasterRaw.invert = function(x21, y25) {
  var phi2 = 3 * asin3(y25 / (sqrt34 * sqrtPi));
  return [sqrtPi * x21 / (sqrt34 * (2 * cos3(2 * phi2 / 3) - 1)), phi2];
};
function craster_default() {
  return projection(crasterRaw).scale(156.19);
}

// node_modules/d3-geo-projection/src/cylindricalEqualArea.js
function cylindricalEqualAreaRaw2(phi02) {
  var cosPhi0 = cos3(phi02);
  function forward(lambda, phi2) {
    return [lambda * cosPhi0, sin3(phi2) / cosPhi0];
  }
  forward.invert = function(x21, y25) {
    return [x21 / cosPhi0, asin3(y25 * cosPhi0)];
  };
  return forward;
}

// node_modules/d3-geo-projection/src/cylindricalStereographic.js
function cylindricalStereographicRaw(phi02) {
  var cosPhi0 = cos3(phi02);
  function forward(lambda, phi2) {
    return [lambda * cosPhi0, (1 + cosPhi0) * tan2(phi2 / 2)];
  }
  forward.invert = function(x21, y25) {
    return [x21 / cosPhi0, atan3(y25 / (1 + cosPhi0)) * 2];
  };
  return forward;
}
function cylindricalStereographic_default() {
  return parallel1_default(cylindricalStereographicRaw).scale(124.75);
}

// node_modules/d3-geo-projection/src/eckert1.js
function eckert1Raw(lambda, phi2) {
  var alpha = sqrt5(8 / (3 * pi5));
  return [
    alpha * lambda * (1 - abs4(phi2) / pi5),
    alpha * phi2
  ];
}
eckert1Raw.invert = function(x21, y25) {
  var alpha = sqrt5(8 / (3 * pi5)), phi2 = y25 / alpha;
  return [
    x21 / (alpha * (1 - abs4(phi2) / pi5)),
    phi2
  ];
};
function eckert1_default() {
  return projection(eckert1Raw).scale(165.664);
}

// node_modules/d3-geo-projection/src/eckert2.js
function eckert2Raw(lambda, phi2) {
  var alpha = sqrt5(4 - 3 * sin3(abs4(phi2)));
  return [
    2 / sqrt5(6 * pi5) * lambda * alpha,
    sign3(phi2) * sqrt5(2 * pi5 / 3) * (2 - alpha)
  ];
}
eckert2Raw.invert = function(x21, y25) {
  var alpha = 2 - abs4(y25) / sqrt5(2 * pi5 / 3);
  return [
    x21 * sqrt5(6 * pi5) / (2 * alpha),
    sign3(y25) * asin3((4 - alpha * alpha) / 3)
  ];
};

// node_modules/d3-geo-projection/src/eckert3.js
function eckert3Raw(lambda, phi2) {
  var k17 = sqrt5(pi5 * (4 + pi5));
  return [
    2 / k17 * lambda * (1 + sqrt5(1 - 4 * phi2 * phi2 / (pi5 * pi5))),
    4 / k17 * phi2
  ];
}
eckert3Raw.invert = function(x21, y25) {
  var k17 = sqrt5(pi5 * (4 + pi5)) / 2;
  return [
    x21 * k17 / (1 + sqrt5(1 - y25 * y25 * (4 + pi5) / (4 * pi5))),
    y25 * k17 / 2
  ];
};
function eckert3_default() {
  return projection(eckert3Raw).scale(180.739);
}

// node_modules/d3-geo-projection/src/eckert4.js
function eckert4Raw(lambda, phi2) {
  var k17 = (2 + halfPi4) * sin3(phi2);
  phi2 /= 2;
  for (var i8 = 0, delta = Infinity; i8 < 10 && abs4(delta) > epsilon6; i8++) {
    var cosPhi = cos3(phi2);
    phi2 -= delta = (phi2 + sin3(phi2) * (cosPhi + 2) - k17) / (2 * cosPhi * (1 + cosPhi));
  }
  return [
    2 / sqrt5(pi5 * (4 + pi5)) * lambda * (1 + cos3(phi2)),
    2 * sqrt5(pi5 / (4 + pi5)) * sin3(phi2)
  ];
}
eckert4Raw.invert = function(x21, y25) {
  var A8 = y25 * sqrt5((4 + pi5) / pi5) / 2, k17 = asin3(A8), c6 = cos3(k17);
  return [
    x21 / (2 / sqrt5(pi5 * (4 + pi5)) * (1 + c6)),
    asin3((k17 + A8 * (c6 + 2)) / (2 + halfPi4))
  ];
};

// node_modules/d3-geo-projection/src/eckert5.js
function eckert5Raw(lambda, phi2) {
  return [
    lambda * (1 + cos3(phi2)) / sqrt5(2 + pi5),
    2 * phi2 / sqrt5(2 + pi5)
  ];
}
eckert5Raw.invert = function(x21, y25) {
  var k17 = sqrt5(2 + pi5), phi2 = y25 * k17 / 2;
  return [
    k17 * x21 / (1 + cos3(phi2)),
    phi2
  ];
};

// node_modules/d3-geo-projection/src/eckert6.js
function eckert6Raw(lambda, phi2) {
  var k17 = (1 + halfPi4) * sin3(phi2);
  for (var i8 = 0, delta = Infinity; i8 < 10 && abs4(delta) > epsilon6; i8++) {
    phi2 -= delta = (phi2 + sin3(phi2) - k17) / (1 + cos3(phi2));
  }
  k17 = sqrt5(2 + pi5);
  return [
    lambda * (1 + cos3(phi2)) / k17,
    2 * phi2 / k17
  ];
}
eckert6Raw.invert = function(x21, y25) {
  var j6 = 1 + halfPi4, k17 = sqrt5(j6 / 2);
  return [
    x21 * 2 * k17 / (1 + cos3(y25 *= k17)),
    asin3((y25 + sin3(y25)) / j6)
  ];
};

// node_modules/d3-geo-projection/src/eisenlohr.js
var eisenlohrK = 3 + 2 * sqrt22;
function eisenlohrRaw(lambda, phi2) {
  var s0 = sin3(lambda /= 2), c0 = cos3(lambda), k17 = sqrt5(cos3(phi2)), c1 = cos3(phi2 /= 2), t4 = sin3(phi2) / (c1 + sqrt22 * c0 * k17), c6 = sqrt5(2 / (1 + t4 * t4)), v28 = sqrt5((sqrt22 * c1 + (c0 + s0) * k17) / (sqrt22 * c1 + (c0 - s0) * k17));
  return [
    eisenlohrK * (c6 * (v28 - 1 / v28) - 2 * log3(v28)),
    eisenlohrK * (c6 * t4 * (v28 + 1 / v28) - 2 * atan3(t4))
  ];
}
eisenlohrRaw.invert = function(x21, y25) {
  if (!(p13 = augustRaw.invert(x21 / 1.2, y25 * 1.065))) return null;
  var lambda = p13[0], phi2 = p13[1], i8 = 20, p13;
  x21 /= eisenlohrK, y25 /= eisenlohrK;
  do {
    var _0 = lambda / 2, _1 = phi2 / 2, s0 = sin3(_0), c0 = cos3(_0), s1 = sin3(_1), c1 = cos3(_1), cos1 = cos3(phi2), k17 = sqrt5(cos1), t4 = s1 / (c1 + sqrt22 * c0 * k17), t22 = t4 * t4, c6 = sqrt5(2 / (1 + t22)), v0 = sqrt22 * c1 + (c0 + s0) * k17, v1 = sqrt22 * c1 + (c0 - s0) * k17, v28 = v0 / v1, v29 = sqrt5(v28), vm1v = v29 - 1 / v29, vp1v = v29 + 1 / v29, fx = c6 * vm1v - 2 * log3(v29) - x21, fy = c6 * t4 * vp1v - 2 * atan3(t4) - y25, deltatDeltaLambda = s1 && sqrt1_2 * k17 * s0 * t22 / s1, deltatDeltaPhi = (sqrt22 * c0 * c1 + k17) / (2 * (c1 + sqrt22 * c0 * k17) * (c1 + sqrt22 * c0 * k17) * k17), deltacDeltat = -0.5 * t4 * c6 * c6 * c6, deltacDeltaLambda = deltacDeltat * deltatDeltaLambda, deltacDeltaPhi = deltacDeltat * deltatDeltaPhi, A8 = (A8 = 2 * c1 + sqrt22 * k17 * (c0 - s0)) * A8 * v29, deltavDeltaLambda = (sqrt22 * c0 * c1 * k17 + cos1) / A8, deltavDeltaPhi = -(sqrt22 * s0 * s1) / (k17 * A8), deltaxDeltaLambda = vm1v * deltacDeltaLambda - 2 * deltavDeltaLambda / v29 + c6 * (deltavDeltaLambda + deltavDeltaLambda / v28), deltaxDeltaPhi = vm1v * deltacDeltaPhi - 2 * deltavDeltaPhi / v29 + c6 * (deltavDeltaPhi + deltavDeltaPhi / v28), deltayDeltaLambda = t4 * vp1v * deltacDeltaLambda - 2 * deltatDeltaLambda / (1 + t22) + c6 * vp1v * deltatDeltaLambda + c6 * t4 * (deltavDeltaLambda - deltavDeltaLambda / v28), deltayDeltaPhi = t4 * vp1v * deltacDeltaPhi - 2 * deltatDeltaPhi / (1 + t22) + c6 * vp1v * deltatDeltaPhi + c6 * t4 * (deltavDeltaPhi - deltavDeltaPhi / v28), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
    if (!denominator) break;
    var deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    lambda -= deltaLambda;
    phi2 = max4(-halfPi4, min4(halfPi4, phi2 - deltaPhi));
  } while ((abs4(deltaLambda) > epsilon6 || abs4(deltaPhi) > epsilon6) && --i8 > 0);
  return abs4(abs4(phi2) - halfPi4) < epsilon6 ? [0, phi2] : i8 && [lambda, phi2];
};

// node_modules/d3-geo-projection/src/fahey.js
var faheyK = cos3(35 * radians3);
function faheyRaw(lambda, phi2) {
  var t4 = tan2(phi2 / 2);
  return [lambda * faheyK * sqrt5(1 - t4 * t4), (1 + faheyK) * t4];
}
faheyRaw.invert = function(x21, y25) {
  var t4 = y25 / (1 + faheyK);
  return [x21 && x21 / (faheyK * sqrt5(1 - t4 * t4)), 2 * atan3(t4)];
};
function fahey_default() {
  return projection(faheyRaw).scale(137.152);
}

// node_modules/d3-geo-projection/src/foucaut.js
function foucautRaw(lambda, phi2) {
  var k17 = phi2 / 2, cosk = cos3(k17);
  return [2 * lambda / sqrtPi * cos3(phi2) * cosk * cosk, sqrtPi * tan2(k17)];
}
foucautRaw.invert = function(x21, y25) {
  var k17 = atan3(y25 / sqrtPi), cosk = cos3(k17), phi2 = 2 * k17;
  return [x21 * sqrtPi / 2 / (cos3(phi2) * cosk * cosk), phi2];
};

// node_modules/d3-geo-projection/src/foucautSinusoidal.js
function foucautSinusoidalRaw(alpha) {
  var beta = 1 - alpha, equatorial = raw(pi5, 0)[0] - raw(-pi5, 0)[0], polar = raw(0, halfPi4)[1] - raw(0, -halfPi4)[1], ratio = sqrt5(2 * polar / equatorial);
  function raw(lambda, phi2) {
    var cosphi = cos3(phi2), sinphi = sin3(phi2);
    return [
      cosphi / (beta + alpha * cosphi) * lambda,
      beta * phi2 + alpha * sinphi
    ];
  }
  function forward(lambda, phi2) {
    var p13 = raw(lambda, phi2);
    return [p13[0] * ratio, p13[1] / ratio];
  }
  function forwardMeridian(phi2) {
    return forward(0, phi2)[1];
  }
  forward.invert = function(x21, y25) {
    var phi2 = solve(forwardMeridian, y25), lambda = x21 / ratio * (alpha + beta / cos3(phi2));
    return [lambda, phi2];
  };
  return forward;
}
function foucautSinusoidal_default() {
  var alpha = 0.5, m30 = projectionMutator(foucautSinusoidalRaw), p13 = m30(alpha);
  p13.alpha = function(_17) {
    return arguments.length ? m30(alpha = +_17) : alpha;
  };
  return p13.scale(168.725);
}

// node_modules/d3-geo-projection/src/ginzburgPolyconic.js
function ginzburgPolyconic_default(a7, b25, c6, d18, e3, f29, g15, h17) {
  if (arguments.length < 8) h17 = 0;
  function forward(lambda, phi2) {
    if (!phi2) return [a7 * lambda / pi5, 0];
    var phi22 = phi2 * phi2, xB = a7 + phi22 * (b25 + phi22 * (c6 + phi22 * d18)), yB = phi2 * (e3 - 1 + phi22 * (f29 - h17 + phi22 * g15)), m30 = (xB * xB + yB * yB) / (2 * yB), alpha = lambda * asin3(xB / m30) / pi5;
    return [m30 * sin3(alpha), phi2 * (1 + phi22 * h17) + m30 * (1 - cos3(alpha))];
  }
  forward.invert = function(x21, y25) {
    var lambda = pi5 * x21 / a7, phi2 = y25, deltaLambda, deltaPhi, i8 = 50;
    do {
      var phi22 = phi2 * phi2, xB = a7 + phi22 * (b25 + phi22 * (c6 + phi22 * d18)), yB = phi2 * (e3 - 1 + phi22 * (f29 - h17 + phi22 * g15)), p13 = xB * xB + yB * yB, q3 = 2 * yB, m30 = p13 / q3, m210 = m30 * m30, dAlphadLambda = asin3(xB / m30) / pi5, alpha = lambda * dAlphadLambda, xB2 = xB * xB, dxBdPhi = (2 * b25 + phi22 * (4 * c6 + phi22 * 6 * d18)) * phi2, dyBdPhi = e3 + phi22 * (3 * f29 + phi22 * 5 * g15), dpdPhi = 2 * (xB * dxBdPhi + yB * (dyBdPhi - 1)), dqdPhi = 2 * (dyBdPhi - 1), dmdPhi = (dpdPhi * q3 - p13 * dqdPhi) / (q3 * q3), cosAlpha = cos3(alpha), sinAlpha = sin3(alpha), mcosAlpha = m30 * cosAlpha, msinAlpha = m30 * sinAlpha, dAlphadPhi = lambda / pi5 * (1 / sqrt5(1 - xB2 / m210)) * (dxBdPhi * m30 - xB * dmdPhi) / m210, fx = msinAlpha - x21, fy = phi2 * (1 + phi22 * h17) + m30 - mcosAlpha - y25, deltaxDeltaPhi = dmdPhi * sinAlpha + mcosAlpha * dAlphadPhi, deltaxDeltaLambda = mcosAlpha * dAlphadLambda, deltayDeltaPhi = 1 + dmdPhi - (dmdPhi * cosAlpha - msinAlpha * dAlphadPhi), deltayDeltaLambda = msinAlpha * dAlphadLambda, denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
      if (!denominator) break;
      lambda -= deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator;
      phi2 -= deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    } while ((abs4(deltaLambda) > epsilon6 || abs4(deltaPhi) > epsilon6) && --i8 > 0);
    return [lambda, phi2];
  };
  return forward;
}

// node_modules/d3-geo-projection/src/ginzburg4.js
var ginzburg4Raw = ginzburgPolyconic_default(2.8284, -1.6988, 0.75432, -0.18071, 1.76003, -0.38914, 0.042555);

// node_modules/d3-geo-projection/src/ginzburg5.js
var ginzburg5Raw = ginzburgPolyconic_default(2.583819, -0.835827, 0.170354, -0.038094, 1.543313, -0.411435, 0.082742);

// node_modules/d3-geo-projection/src/ginzburg6.js
var ginzburg6Raw = ginzburgPolyconic_default(5 / 6 * pi5, -0.62636, -0.0344, 0, 1.3493, -0.05524, 0, 0.045);

// node_modules/d3-geo-projection/src/ginzburg8.js
function ginzburg8Raw(lambda, phi2) {
  var lambda2 = lambda * lambda, phi22 = phi2 * phi2;
  return [
    lambda * (1 - 0.162388 * phi22) * (0.87 - 952426e-9 * lambda2 * lambda2),
    phi2 * (1 + phi22 / 12)
  ];
}
ginzburg8Raw.invert = function(x21, y25) {
  var lambda = x21, phi2 = y25, i8 = 50, delta;
  do {
    var phi22 = phi2 * phi2;
    phi2 -= delta = (phi2 * (1 + phi22 / 12) - y25) / (1 + phi22 / 4);
  } while (abs4(delta) > epsilon6 && --i8 > 0);
  i8 = 50;
  x21 /= 1 - 0.162388 * phi22;
  do {
    var lambda4 = (lambda4 = lambda * lambda) * lambda4;
    lambda -= delta = (lambda * (0.87 - 952426e-9 * lambda4) - x21) / (0.87 - 476213e-8 * lambda4);
  } while (abs4(delta) > epsilon6 && --i8 > 0);
  return [lambda, phi2];
};

// node_modules/d3-geo-projection/src/ginzburg9.js
var ginzburg9Raw = ginzburgPolyconic_default(2.6516, -0.76534, 0.19123, -0.047094, 1.36289, -0.13965, 0.031762);

// node_modules/d3-geo-projection/src/gringorten.js
function gringortenRaw(lambda, phi2) {
  var sLambda = sign3(lambda), sPhi = sign3(phi2), cosPhi = cos3(phi2), x21 = cos3(lambda) * cosPhi, y25 = sin3(lambda) * cosPhi, z3 = sin3(sPhi * phi2);
  lambda = abs4(atan23(y25, z3));
  phi2 = asin3(x21);
  if (abs4(lambda - halfPi4) > epsilon6) lambda %= halfPi4;
  var point13 = gringortenHexadecant(lambda > pi5 / 4 ? halfPi4 - lambda : lambda, phi2);
  if (lambda > pi5 / 4) z3 = point13[0], point13[0] = -point13[1], point13[1] = -z3;
  return point13[0] *= sLambda, point13[1] *= -sPhi, point13;
}
gringortenRaw.invert = function(x21, y25) {
  if (abs4(x21) > 1) x21 = sign3(x21) * 2 - x21;
  if (abs4(y25) > 1) y25 = sign3(y25) * 2 - y25;
  var sx = sign3(x21), sy = sign3(y25), x06 = -sx * x21, y06 = -sy * y25, t4 = y06 / x06 < 1, p13 = gringortenHexadecantInvert(t4 ? y06 : x06, t4 ? x06 : y06), lambda = p13[0], phi2 = p13[1], cosPhi = cos3(phi2);
  if (t4) lambda = -halfPi4 - lambda;
  return [sx * (atan23(sin3(lambda) * cosPhi, -sin3(phi2)) + pi5), sy * asin3(cos3(lambda) * cosPhi)];
};
function gringortenHexadecant(lambda, phi2) {
  if (phi2 === halfPi4) return [0, 0];
  var sinPhi = sin3(phi2), r4 = sinPhi * sinPhi, r22 = r4 * r4, j6 = 1 + r22, k17 = 1 + 3 * r22, q3 = 1 - r22, z3 = asin3(1 / sqrt5(j6)), v28 = q3 + r4 * j6 * z3, p22 = (1 - sinPhi) / v28, p13 = sqrt5(p22), a22 = p22 * j6, a7 = sqrt5(a22), h17 = p13 * q3, x21, i8;
  if (lambda === 0) return [0, -(h17 + r4 * a7)];
  var cosPhi = cos3(phi2), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r4 + z3 * k17) * drdPhi, dp2dPhi = (-v28 * cosPhi - (1 - sinPhi) * dvdPhi) / (v28 * v28), dpdPhi = 0.5 * dp2dPhi / p13, dhdPhi = q3 * dpdPhi - 2 * r4 * p13 * drdPhi, dra2dPhi = r4 * j6 * dp2dPhi + p22 * k17 * drdPhi, mu = -secPhi * drdPhi, nu = -secPhi * dra2dPhi, zeta = -2 * secPhi * dhdPhi, lambda1 = 4 * lambda / pi5, delta;
  if (lambda > 0.222 * pi5 || phi2 < pi5 / 4 && lambda > 0.175 * pi5) {
    x21 = (h17 + r4 * sqrt5(a22 * (1 + r22) - h17 * h17)) / (1 + r22);
    if (lambda > pi5 / 4) return [x21, x21];
    var x110 = x21, x06 = 0.5 * x21;
    x21 = 0.5 * (x06 + x110), i8 = 50;
    do {
      var g15 = sqrt5(a22 - x21 * x21), f29 = x21 * (zeta + mu * g15) + nu * asin3(x21 / a7) - lambda1;
      if (!f29) break;
      if (f29 < 0) x06 = x21;
      else x110 = x21;
      x21 = 0.5 * (x06 + x110);
    } while (abs4(x110 - x06) > epsilon6 && --i8 > 0);
  } else {
    x21 = epsilon6, i8 = 25;
    do {
      var x22 = x21 * x21, g22 = sqrt5(a22 - x22), zetaMug = zeta + mu * g22, f210 = x21 * zetaMug + nu * asin3(x21 / a7) - lambda1, df = zetaMug + (nu - mu * x22) / g22;
      x21 -= delta = g22 ? f210 / df : 0;
    } while (abs4(delta) > epsilon6 && --i8 > 0);
  }
  return [x21, -h17 - r4 * sqrt5(a22 - x21 * x21)];
}
function gringortenHexadecantInvert(x21, y25) {
  var x06 = 0, x110 = 1, r4 = 0.5, i8 = 50;
  while (true) {
    var r22 = r4 * r4, sinPhi = sqrt5(r4), z3 = asin3(1 / sqrt5(1 + r22)), v28 = 1 - r22 + r4 * (1 + r22) * z3, p22 = (1 - sinPhi) / v28, p13 = sqrt5(p22), a22 = p22 * (1 + r22), h17 = p13 * (1 - r22), g22 = a22 - x21 * x21, g15 = sqrt5(g22), y06 = y25 + h17 + r4 * g15;
    if (abs4(x110 - x06) < epsilon23 || --i8 === 0 || y06 === 0) break;
    if (y06 > 0) x06 = r4;
    else x110 = r4;
    r4 = 0.5 * (x06 + x110);
  }
  if (!i8) return null;
  var phi2 = asin3(sinPhi), cosPhi = cos3(phi2), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r4 + z3 * (1 + 3 * r22)) * drdPhi, dp2dPhi = (-v28 * cosPhi - (1 - sinPhi) * dvdPhi) / (v28 * v28), dpdPhi = 0.5 * dp2dPhi / p13, dhdPhi = (1 - r22) * dpdPhi - 2 * r4 * p13 * drdPhi, zeta = -2 * secPhi * dhdPhi, mu = -secPhi * drdPhi, nu = -secPhi * (r4 * (1 + r22) * dp2dPhi + p22 * (1 + 3 * r22) * drdPhi);
  return [pi5 / 4 * (x21 * (zeta + mu * g15) + nu * asin3(x21 / sqrt5(a22))), phi2];
}

// node_modules/d3-geo-projection/src/elliptic.js
function ellipticJi(u15, v28, m30) {
  var a7, b25, c6;
  if (!u15) {
    b25 = ellipticJ(v28, 1 - m30);
    return [
      [0, b25[0] / b25[1]],
      [1 / b25[1], 0],
      [b25[2] / b25[1], 0]
    ];
  }
  a7 = ellipticJ(u15, m30);
  if (!v28) return [[a7[0], 0], [a7[1], 0], [a7[2], 0]];
  b25 = ellipticJ(v28, 1 - m30);
  c6 = b25[1] * b25[1] + m30 * a7[0] * a7[0] * b25[0] * b25[0];
  return [
    [a7[0] * b25[2] / c6, a7[1] * a7[2] * b25[0] * b25[1] / c6],
    [a7[1] * b25[1] / c6, -a7[0] * a7[2] * b25[0] * b25[2] / c6],
    [a7[2] * b25[1] * b25[2] / c6, -m30 * a7[0] * a7[1] * b25[0] / c6]
  ];
}
function ellipticJ(u15, m30) {
  var ai, b25, phi2, t4, twon;
  if (m30 < epsilon6) {
    t4 = sin3(u15);
    b25 = cos3(u15);
    ai = m30 * (u15 - t4 * b25) / 4;
    return [
      t4 - ai * b25,
      b25 + ai * t4,
      1 - m30 * t4 * t4 / 2,
      u15 - ai
    ];
  }
  if (m30 >= 1 - epsilon6) {
    ai = (1 - m30) / 4;
    b25 = cosh2(u15);
    t4 = tanh2(u15);
    phi2 = 1 / b25;
    twon = b25 * sinh2(u15);
    return [
      t4 + ai * (twon - u15) / (b25 * b25),
      phi2 - ai * t4 * phi2 * (twon - u15),
      phi2 + ai * t4 * phi2 * (twon + u15),
      2 * atan3(exp2(u15)) - halfPi4 + ai * (twon - u15) / b25
    ];
  }
  var a7 = [1, 0, 0, 0, 0, 0, 0, 0, 0], c6 = [sqrt5(m30), 0, 0, 0, 0, 0, 0, 0, 0], i8 = 0;
  b25 = sqrt5(1 - m30);
  twon = 1;
  while (abs4(c6[i8] / a7[i8]) > epsilon6 && i8 < 8) {
    ai = a7[i8++];
    c6[i8] = (ai - b25) / 2;
    a7[i8] = (ai + b25) / 2;
    b25 = sqrt5(ai * b25);
    twon *= 2;
  }
  phi2 = twon * a7[i8] * u15;
  do {
    t4 = c6[i8] * sin3(b25 = phi2) / a7[i8];
    phi2 = (asin3(t4) + phi2) / 2;
  } while (--i8);
  return [sin3(phi2), t4 = cos3(phi2), t4 / cos3(phi2 - b25), phi2];
}
function ellipticFi(phi2, psi, m30) {
  var r4 = abs4(phi2), i8 = abs4(psi), sinhPsi = sinh2(i8);
  if (r4) {
    var cscPhi = 1 / sin3(r4), cotPhi2 = 1 / (tan2(r4) * tan2(r4)), b25 = -(cotPhi2 + m30 * (sinhPsi * sinhPsi * cscPhi * cscPhi) - 1 + m30), c6 = (m30 - 1) * cotPhi2, cotLambda2 = (-b25 + sqrt5(b25 * b25 - 4 * c6)) / 2;
    return [
      ellipticF(atan3(1 / sqrt5(cotLambda2)), m30) * sign3(phi2),
      ellipticF(atan3(sqrt5((cotLambda2 / cotPhi2 - 1) / m30)), 1 - m30) * sign3(psi)
    ];
  }
  return [
    0,
    ellipticF(atan3(sinhPsi), 1 - m30) * sign3(psi)
  ];
}
function ellipticF(phi2, m30) {
  if (!m30) return phi2;
  if (m30 === 1) return log3(tan2(phi2 / 2 + quarterPi2));
  var a7 = 1, b25 = sqrt5(1 - m30), c6 = sqrt5(m30);
  for (var i8 = 0; abs4(c6) > epsilon6; i8++) {
    if (phi2 % pi5) {
      var dPhi = atan3(b25 * tan2(phi2) / a7);
      if (dPhi < 0) dPhi += pi5;
      phi2 += dPhi + ~~(phi2 / pi5) * pi5;
    } else phi2 += phi2;
    c6 = (a7 + b25) / 2;
    b25 = sqrt5(a7 * b25);
    c6 = ((a7 = c6) - b25) / 2;
  }
  return phi2 / (pow3(2, i8) * a7);
}

// node_modules/d3-geo-projection/src/guyou.js
function guyouRaw(lambda, phi2) {
  var k_ = (sqrt22 - 1) / (sqrt22 + 1), k17 = sqrt5(1 - k_ * k_), K4 = ellipticF(halfPi4, k17 * k17), f29 = -1, psi = log3(tan2(pi5 / 4 + abs4(phi2) / 2)), r4 = exp2(f29 * psi) / sqrt5(k_), at = guyouComplexAtan(r4 * cos3(f29 * lambda), r4 * sin3(f29 * lambda)), t4 = ellipticFi(at[0], at[1], k17 * k17);
  return [-t4[1], (phi2 >= 0 ? 1 : -1) * (0.5 * K4 - t4[0])];
}
function guyouComplexAtan(x21, y25) {
  var x22 = x21 * x21, y_1 = y25 + 1, t4 = 1 - x22 - y25 * y25;
  return [
    0.5 * ((x21 >= 0 ? halfPi4 : -halfPi4) - atan23(t4, 2 * x21)),
    -0.25 * log3(t4 * t4 + 4 * x22) + 0.5 * log3(y_1 * y_1 + x22)
  ];
}
function guyouComplexDivide(a7, b25) {
  var denominator = b25[0] * b25[0] + b25[1] * b25[1];
  return [
    (a7[0] * b25[0] + a7[1] * b25[1]) / denominator,
    (a7[1] * b25[0] - a7[0] * b25[1]) / denominator
  ];
}
guyouRaw.invert = function(x21, y25) {
  var k_ = (sqrt22 - 1) / (sqrt22 + 1), k17 = sqrt5(1 - k_ * k_), K4 = ellipticF(halfPi4, k17 * k17), f29 = -1, j6 = ellipticJi(0.5 * K4 - y25, -x21, k17 * k17), tn = guyouComplexDivide(j6[0], j6[1]), lambda = atan23(tn[1], tn[0]) / f29;
  return [
    lambda,
    2 * atan3(exp2(0.5 / f29 * log3(k_ * tn[0] * tn[0] + k_ * tn[1] * tn[1]))) - halfPi4
  ];
};

// node_modules/d3-geo-projection/src/healpix.js
var K2 = 3;
var healpixParallel = asin3(1 - 1 / K2) * degrees4;
var healpixLambert = cylindricalEqualAreaRaw2(0);

// node_modules/d3-geo-projection/src/sinuMollweide.js
var sinuMollweidePhi = 0.7109889596207567;
var sinuMollweideY = 0.0528035274542;
function sinuMollweideRaw(lambda, phi2) {
  return phi2 > -sinuMollweidePhi ? (lambda = mollweideRaw(lambda, phi2), lambda[1] += sinuMollweideY, lambda) : sinusoidalRaw(lambda, phi2);
}
sinuMollweideRaw.invert = function(x21, y25) {
  return y25 > -sinuMollweidePhi ? mollweideRaw.invert(x21, y25 - sinuMollweideY) : sinusoidalRaw.invert(x21, y25);
};

// node_modules/d3-geo-projection/src/homolosine.js
function homolosineRaw(lambda, phi2) {
  return abs4(phi2) > sinuMollweidePhi ? (lambda = mollweideRaw(lambda, phi2), lambda[1] -= phi2 > 0 ? sinuMollweideY : -sinuMollweideY, lambda) : sinusoidalRaw(lambda, phi2);
}
homolosineRaw.invert = function(x21, y25) {
  return abs4(y25) > sinuMollweidePhi ? mollweideRaw.invert(x21, y25 + (y25 > 0 ? sinuMollweideY : -sinuMollweideY)) : sinusoidalRaw.invert(x21, y25);
};

// node_modules/d3-geo-projection/src/hufnagel.js
function hufnagelRaw(a7, b25, psiMax, ratio) {
  var k17 = sqrt5(
    4 * pi5 / (2 * psiMax + (1 + a7 - b25 / 2) * sin3(2 * psiMax) + (a7 + b25) / 2 * sin3(4 * psiMax) + b25 / 2 * sin3(6 * psiMax))
  ), c6 = sqrt5(
    ratio * sin3(psiMax) * sqrt5((1 + a7 * cos3(2 * psiMax) + b25 * cos3(4 * psiMax)) / (1 + a7 + b25))
  ), M5 = psiMax * mapping(1);
  function radius(psi) {
    return sqrt5(1 + a7 * cos3(2 * psi) + b25 * cos3(4 * psi));
  }
  function mapping(t4) {
    var psi = t4 * psiMax;
    return (2 * psi + (1 + a7 - b25 / 2) * sin3(2 * psi) + (a7 + b25) / 2 * sin3(4 * psi) + b25 / 2 * sin3(6 * psi)) / psiMax;
  }
  function inversemapping(psi) {
    return radius(psi) * sin3(psi);
  }
  var forward = function(lambda, phi2) {
    var psi = psiMax * solve(mapping, M5 * sin3(phi2) / psiMax, phi2 / pi5);
    if (isNaN(psi)) psi = psiMax * sign3(phi2);
    var kr3 = k17 * radius(psi);
    return [kr3 * c6 * lambda / pi5 * cos3(psi), kr3 / c6 * sin3(psi)];
  };
  forward.invert = function(x21, y25) {
    var psi = solve(inversemapping, y25 * c6 / k17);
    return [
      x21 * pi5 / (cos3(psi) * k17 * c6 * radius(psi)),
      asin3(psiMax * mapping(psi / psiMax) / M5)
    ];
  };
  if (psiMax === 0) {
    k17 = sqrt5(ratio / pi5);
    forward = function(lambda, phi2) {
      return [lambda * k17, sin3(phi2) / k17];
    };
    forward.invert = function(x21, y25) {
      return [x21 / k17, asin3(y25 * k17)];
    };
  }
  return forward;
}
function hufnagel_default() {
  var a7 = 1, b25 = 0, psiMax = 45 * radians3, ratio = 2, mutate = projectionMutator(hufnagelRaw), projection2 = mutate(a7, b25, psiMax, ratio);
  projection2.a = function(_17) {
    return arguments.length ? mutate(a7 = +_17, b25, psiMax, ratio) : a7;
  };
  projection2.b = function(_17) {
    return arguments.length ? mutate(a7, b25 = +_17, psiMax, ratio) : b25;
  };
  projection2.psiMax = function(_17) {
    return arguments.length ? mutate(a7, b25, psiMax = +_17 * radians3, ratio) : psiMax * degrees4;
  };
  projection2.ratio = function(_17) {
    return arguments.length ? mutate(a7, b25, psiMax, ratio = +_17) : ratio;
  };
  return projection2.scale(180.739);
}

// node_modules/d3-geo-projection/src/kavrayskiy7.js
function kavrayskiy7Raw(lambda, phi2) {
  return [3 / tau5 * lambda * sqrt5(pi5 * pi5 / 3 - phi2 * phi2), phi2];
}
kavrayskiy7Raw.invert = function(x21, y25) {
  return [tau5 / 3 * x21 / sqrt5(pi5 * pi5 / 3 - y25 * y25), y25];
};
function kavrayskiy7_default() {
  return projection(kavrayskiy7Raw).scale(158.837);
}

// node_modules/d3-geo-projection/src/larrivee.js
var pi_sqrt2 = pi5 / sqrt22;
function larriveeRaw(lambda, phi2) {
  return [
    lambda * (1 + sqrt5(cos3(phi2))) / 2,
    phi2 / (cos3(phi2 / 2) * cos3(lambda / 6))
  ];
}
larriveeRaw.invert = function(x21, y25) {
  var x06 = abs4(x21), y06 = abs4(y25), lambda = epsilon6, phi2 = halfPi4;
  if (y06 < pi_sqrt2) phi2 *= y06 / pi_sqrt2;
  else lambda += 6 * acos3(pi_sqrt2 / y06);
  for (var i8 = 0; i8 < 25; i8++) {
    var sinPhi = sin3(phi2), sqrtcosPhi = sqrt5(cos3(phi2)), sinPhi_2 = sin3(phi2 / 2), cosPhi_2 = cos3(phi2 / 2), sinLambda_6 = sin3(lambda / 6), cosLambda_6 = cos3(lambda / 6), f0 = 0.5 * lambda * (1 + sqrtcosPhi) - x06, f1 = phi2 / (cosPhi_2 * cosLambda_6) - y06, df0dPhi = sqrtcosPhi ? -0.25 * lambda * sinPhi / sqrtcosPhi : 0, df0dLambda = 0.5 * (1 + sqrtcosPhi), df1dPhi = (1 + 0.5 * phi2 * sinPhi_2 / cosPhi_2) / (cosPhi_2 * cosLambda_6), df1dLambda = phi2 / cosPhi_2 * (sinLambda_6 / 6) / (cosLambda_6 * cosLambda_6), denom = df0dPhi * df1dLambda - df1dPhi * df0dLambda, dPhi = (f0 * df1dLambda - f1 * df0dLambda) / denom, dLambda = (f1 * df0dPhi - f0 * df1dPhi) / denom;
    phi2 -= dPhi;
    lambda -= dLambda;
    if (abs4(dPhi) < epsilon6 && abs4(dLambda) < epsilon6) break;
  }
  return [x21 < 0 ? -lambda : lambda, y25 < 0 ? -phi2 : phi2];
};

// node_modules/d3-geo-projection/src/laskowski.js
function laskowskiRaw(lambda, phi2) {
  var lambda2 = lambda * lambda, phi22 = phi2 * phi2;
  return [
    lambda * (0.975534 + phi22 * (-0.119161 + lambda2 * -0.0143059 + phi22 * -0.0547009)),
    phi2 * (1.00384 + lambda2 * (0.0802894 + phi22 * -0.02855 + lambda2 * 199025e-9) + phi22 * (0.0998909 + phi22 * -0.0491032))
  ];
}
laskowskiRaw.invert = function(x21, y25) {
  var lambda = sign3(x21) * pi5, phi2 = y25 / 2, i8 = 50;
  do {
    var lambda2 = lambda * lambda, phi22 = phi2 * phi2, lambdaPhi = lambda * phi2, fx = lambda * (0.975534 + phi22 * (-0.119161 + lambda2 * -0.0143059 + phi22 * -0.0547009)) - x21, fy = phi2 * (1.00384 + lambda2 * (0.0802894 + phi22 * -0.02855 + lambda2 * 199025e-9) + phi22 * (0.0998909 + phi22 * -0.0491032)) - y25, deltaxDeltaLambda = 0.975534 - phi22 * (0.119161 + 3 * lambda2 * 0.0143059 + phi22 * 0.0547009), deltaxDeltaPhi = -lambdaPhi * (2 * 0.119161 + 4 * 0.0547009 * phi22 + 2 * 0.0143059 * lambda2), deltayDeltaLambda = lambdaPhi * (2 * 0.0802894 + 4 * 199025e-9 * lambda2 + 2 * -0.02855 * phi22), deltayDeltaPhi = 1.00384 + lambda2 * (0.0802894 + 199025e-9 * lambda2) + phi22 * (3 * (0.0998909 - 0.02855 * lambda2) - 5 * 0.0491032 * phi22), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda, deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    lambda -= deltaLambda, phi2 -= deltaPhi;
  } while ((abs4(deltaLambda) > epsilon6 || abs4(deltaPhi) > epsilon6) && --i8 > 0);
  return i8 && [lambda, phi2];
};

// node_modules/d3-geo-projection/src/littrow.js
function littrowRaw(lambda, phi2) {
  return [
    sin3(lambda) / cos3(phi2),
    tan2(phi2) * cos3(lambda)
  ];
}
littrowRaw.invert = function(x21, y25) {
  var x22 = x21 * x21, y26 = y25 * y25, y2_1 = y26 + 1, x2_y2_1 = x22 + y2_1, cosPhi = x21 ? sqrt1_2 * sqrt5((x2_y2_1 - sqrt5(x2_y2_1 * x2_y2_1 - 4 * x22)) / x22) : 1 / sqrt5(y2_1);
  return [
    asin3(x21 * cosPhi),
    sign3(y25) * acos3(cosPhi)
  ];
};

// node_modules/d3-geo-projection/src/miller.js
function millerRaw(lambda, phi2) {
  return [lambda, 1.25 * log3(tan2(quarterPi2 + 0.4 * phi2))];
}
millerRaw.invert = function(x21, y25) {
  return [x21, 2.5 * atan3(exp2(0.8 * y25)) - 0.625 * pi5];
};

// node_modules/d3-geo-projection/src/mtFlatPolarParabolic.js
var sqrt6 = sqrt5(6);
var sqrt7 = sqrt5(7);
function mtFlatPolarParabolicRaw(lambda, phi2) {
  var theta = asin3(7 * sin3(phi2) / (3 * sqrt6));
  return [
    sqrt6 * lambda * (2 * cos3(2 * theta / 3) - 1) / sqrt7,
    9 * sin3(theta / 3) / sqrt7
  ];
}
mtFlatPolarParabolicRaw.invert = function(x21, y25) {
  var theta = 3 * asin3(y25 * sqrt7 / 9);
  return [
    x21 * sqrt7 / (sqrt6 * (2 * cos3(2 * theta / 3) - 1)),
    asin3(sin3(theta) * 3 * sqrt6 / 7)
  ];
};

// node_modules/d3-geo-projection/src/mtFlatPolarQuartic.js
function mtFlatPolarQuarticRaw(lambda, phi2) {
  var k17 = (1 + sqrt1_2) * sin3(phi2), theta = phi2;
  for (var i8 = 0, delta; i8 < 25; i8++) {
    theta -= delta = (sin3(theta / 2) + sin3(theta) - k17) / (0.5 * cos3(theta / 2) + cos3(theta));
    if (abs4(delta) < epsilon6) break;
  }
  return [
    lambda * (1 + 2 * cos3(theta) / cos3(theta / 2)) / (3 * sqrt22),
    2 * sqrt5(3) * sin3(theta / 2) / sqrt5(2 + sqrt22)
  ];
}
mtFlatPolarQuarticRaw.invert = function(x21, y25) {
  var sinTheta_2 = y25 * sqrt5(2 + sqrt22) / (2 * sqrt5(3)), theta = 2 * asin3(sinTheta_2);
  return [
    3 * sqrt22 * x21 / (1 + 2 * cos3(theta) / cos3(theta / 2)),
    asin3((sinTheta_2 + sin3(theta)) / (1 + sqrt1_2))
  ];
};

// node_modules/d3-geo-projection/src/mtFlatPolarSinusoidal.js
function mtFlatPolarSinusoidalRaw(lambda, phi2) {
  var A8 = sqrt5(6 / (4 + pi5)), k17 = (1 + pi5 / 4) * sin3(phi2), theta = phi2 / 2;
  for (var i8 = 0, delta; i8 < 25; i8++) {
    theta -= delta = (theta / 2 + sin3(theta) - k17) / (0.5 + cos3(theta));
    if (abs4(delta) < epsilon6) break;
  }
  return [
    A8 * (0.5 + cos3(theta)) * lambda / 1.5,
    A8 * theta
  ];
}
mtFlatPolarSinusoidalRaw.invert = function(x21, y25) {
  var A8 = sqrt5(6 / (4 + pi5)), theta = y25 / A8;
  if (abs4(abs4(theta) - halfPi4) < epsilon6) theta = theta < 0 ? -halfPi4 : halfPi4;
  return [
    1.5 * x21 / (A8 * (0.5 + cos3(theta))),
    asin3((theta / 2 + sin3(theta)) / (1 + pi5 / 4))
  ];
};

// node_modules/d3-geo-projection/src/naturalEarth2.js
function naturalEarth2Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22, phi6 = phi22 * phi4;
  return [
    lambda * (0.84719 - 0.13063 * phi22 + phi6 * phi6 * (-0.04515 + 0.05494 * phi22 - 0.02326 * phi4 + 331e-5 * phi6)),
    phi2 * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi22 - 396e-5 * phi4))
  ];
}
naturalEarth2Raw.invert = function(x21, y25) {
  var phi2 = y25, i8 = 25, delta, phi22, phi4, phi6;
  do {
    phi22 = phi2 * phi2;
    phi4 = phi22 * phi22;
    phi2 -= delta = (phi2 * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi22 - 396e-5 * phi4)) - y25) / (1.01183 + phi4 * phi4 * (9 * -0.02625 + 11 * 0.01926 * phi22 + 13 * -396e-5 * phi4));
  } while (abs4(delta) > epsilon23 && --i8 > 0);
  phi22 = phi2 * phi2;
  phi4 = phi22 * phi22;
  phi6 = phi22 * phi4;
  return [
    x21 / (0.84719 - 0.13063 * phi22 + phi6 * phi6 * (-0.04515 + 0.05494 * phi22 - 0.02326 * phi4 + 331e-5 * phi6)),
    phi2
  ];
};
function naturalEarth2_default() {
  return projection(naturalEarth2Raw).scale(175.295);
}

// node_modules/d3-geo-projection/src/nellHammer.js
function nellHammerRaw(lambda, phi2) {
  return [
    lambda * (1 + cos3(phi2)) / 2,
    2 * (phi2 - tan2(phi2 / 2))
  ];
}
nellHammerRaw.invert = function(x21, y25) {
  var p13 = y25 / 2;
  for (var i8 = 0, delta = Infinity; i8 < 10 && abs4(delta) > epsilon6; ++i8) {
    var c6 = cos3(y25 / 2);
    y25 -= delta = (y25 - tan2(y25 / 2) - p13) / (1 - 0.5 / (c6 * c6));
  }
  return [
    2 * x21 / (1 + cos3(y25)),
    y25
  ];
};

// node_modules/d3-geo-projection/src/nicolosi.js
function nicolosiRaw(lambda, phi2) {
  var sinPhi = sin3(phi2), q3 = cos3(phi2), s12 = sign3(lambda);
  if (lambda === 0 || abs4(phi2) === halfPi4) return [0, phi2];
  else if (phi2 === 0) return [lambda, 0];
  else if (abs4(lambda) === halfPi4) return [lambda * q3, halfPi4 * sinPhi];
  var b25 = pi5 / (2 * lambda) - 2 * lambda / pi5, c6 = 2 * phi2 / pi5, d18 = (1 - c6 * c6) / (sinPhi - c6);
  var b26 = b25 * b25, d22 = d18 * d18, b2d2 = 1 + b26 / d22, d2b2 = 1 + d22 / b26;
  var M5 = (b25 * sinPhi / d18 - b25 / 2) / b2d2, N = (d22 * sinPhi / b26 + d18 / 2) / d2b2, m30 = M5 * M5 + q3 * q3 / b2d2, n = N * N - (d22 * sinPhi * sinPhi / b26 + d18 * sinPhi - 1) / d2b2;
  return [
    halfPi4 * (M5 + sqrt5(m30) * s12),
    halfPi4 * (N + sqrt5(n < 0 ? 0 : n) * sign3(-phi2 * b25) * s12)
  ];
}
nicolosiRaw.invert = function(x21, y25) {
  x21 /= halfPi4;
  y25 /= halfPi4;
  var x22 = x21 * x21, y26 = y25 * y25, x2y2 = x22 + y26, pi22 = pi5 * pi5;
  return [
    x21 ? (x2y2 - 1 + sqrt5((1 - x2y2) * (1 - x2y2) + 4 * x22)) / (2 * x21) * halfPi4 : 0,
    solve(function(phi2) {
      return x2y2 * (pi5 * sin3(phi2) - 2 * phi2) * pi5 + 4 * phi2 * phi2 * (y25 - sin3(phi2)) + 2 * pi5 * phi2 - pi22 * y25;
    }, 0)
  ];
};

// node_modules/d3-geo-projection/src/patterson.js
var pattersonK1 = 1.0148;
var pattersonK2 = 0.23185;
var pattersonK3 = -0.14499;
var pattersonK4 = 0.02406;
var pattersonC1 = pattersonK1;
var pattersonC2 = 5 * pattersonK2;
var pattersonC3 = 7 * pattersonK3;
var pattersonC4 = 9 * pattersonK4;
var pattersonYmax = 1.790857183;
function pattersonRaw(lambda, phi2) {
  var phi22 = phi2 * phi2;
  return [
    lambda,
    phi2 * (pattersonK1 + phi22 * phi22 * (pattersonK2 + phi22 * (pattersonK3 + pattersonK4 * phi22)))
  ];
}
pattersonRaw.invert = function(x21, y25) {
  if (y25 > pattersonYmax) y25 = pattersonYmax;
  else if (y25 < -pattersonYmax) y25 = -pattersonYmax;
  var yc = y25, delta;
  do {
    var y26 = yc * yc;
    yc -= delta = (yc * (pattersonK1 + y26 * y26 * (pattersonK2 + y26 * (pattersonK3 + pattersonK4 * y26))) - y25) / (pattersonC1 + y26 * y26 * (pattersonC2 + y26 * (pattersonC3 + pattersonC4 * y26)));
  } while (abs4(delta) > epsilon6);
  return [x21, yc];
};

// node_modules/d3-geo-projection/src/polyconic.js
function polyconicRaw(lambda, phi2) {
  if (abs4(phi2) < epsilon6) return [lambda, 0];
  var tanPhi = tan2(phi2), k17 = lambda * sin3(phi2);
  return [
    sin3(k17) / tanPhi,
    phi2 + (1 - cos3(k17)) / tanPhi
  ];
}
polyconicRaw.invert = function(x21, y25) {
  if (abs4(y25) < epsilon6) return [x21, 0];
  var k17 = x21 * x21 + y25 * y25, phi2 = y25 * 0.5, i8 = 10, delta;
  do {
    var tanPhi = tan2(phi2), secPhi = 1 / cos3(phi2), j6 = k17 - 2 * y25 * phi2 + phi2 * phi2;
    phi2 -= delta = (tanPhi * j6 + 2 * (phi2 - y25)) / (2 + j6 * secPhi * secPhi + 2 * (phi2 - y25) * tanPhi);
  } while (abs4(delta) > epsilon6 && --i8 > 0);
  tanPhi = tan2(phi2);
  return [
    (abs4(y25) < abs4(phi2 + 1 / tanPhi) ? asin3(x21 * tanPhi) : sign3(y25) * sign3(x21) * (acos3(abs4(x21 * tanPhi)) + halfPi4)) / sin3(phi2),
    phi2
  ];
};

// node_modules/d3-geo-projection/src/polyhedral/octahedron.js
var octahedron = [
  [0, 90],
  [-90, 0],
  [0, 0],
  [90, 0],
  [180, 0],
  [0, -90]
];
var octahedron_default = [
  [0, 2, 1],
  [0, 3, 2],
  [5, 1, 2],
  [5, 2, 3],
  [0, 1, 4],
  [0, 4, 3],
  [5, 4, 1],
  [5, 3, 4]
].map(function(face) {
  return face.map(function(i8) {
    return octahedron[i8];
  });
});

// node_modules/d3-geo-projection/src/polyhedral/collignon.js
var kx2 = 2 / sqrt5(3);
function collignonK(a7, b25) {
  var p13 = collignonRaw(a7, b25);
  return [p13[0] * kx2, p13[1]];
}
collignonK.invert = function(x21, y25) {
  return collignonRaw.invert(x21 / kx2, y25);
};

// node_modules/d3-geo-projection/src/robinson.js
var K3 = [
  [0.9986, -0.062],
  [1, 0],
  [0.9986, 0.062],
  [0.9954, 0.124],
  [0.99, 0.186],
  [0.9822, 0.248],
  [0.973, 0.31],
  [0.96, 0.372],
  [0.9427, 0.434],
  [0.9216, 0.4958],
  [0.8962, 0.5571],
  [0.8679, 0.6176],
  [0.835, 0.6769],
  [0.7986, 0.7346],
  [0.7597, 0.7903],
  [0.7186, 0.8435],
  [0.6732, 0.8936],
  [0.6213, 0.9394],
  [0.5722, 0.9761],
  [0.5322, 1]
];
K3.forEach(function(d18) {
  d18[1] *= 1.593415793900743;
});
function robinsonRaw(lambda, phi2) {
  var i8 = min4(18, abs4(phi2) * 36 / pi5), i0 = floor(i8), di = i8 - i0, ax = (k17 = K3[i0])[0], ay = k17[1], bx = (k17 = K3[++i0])[0], by = k17[1], cx = (k17 = K3[min4(19, ++i0)])[0], cy = k17[1], k17;
  return [
    lambda * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    sign3(phi2) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)
  ];
}
robinsonRaw.invert = function(x21, y25) {
  var phi2 = y25 * 90, i8 = min4(18, abs4(phi2 / 5)), i0 = max4(0, floor(i8));
  do {
    var ay = K3[i0][1], by = K3[i0 + 1][1], cy = K3[min4(19, i0 + 2)][1], u15 = cy - ay, v28 = cy - 2 * by + ay, t4 = 2 * (abs4(y25) - by) / u15, c6 = v28 / u15, di = t4 * (1 - c6 * t4 * (1 - 2 * c6 * t4));
    if (di >= 0 || i0 === 1) {
      phi2 = (y25 >= 0 ? 5 : -5) * (di + i8);
      var j6 = 50, delta;
      do {
        i8 = min4(18, abs4(phi2) / 5);
        i0 = floor(i8);
        di = i8 - i0;
        ay = K3[i0][1];
        by = K3[i0 + 1][1];
        cy = K3[min4(19, i0 + 2)][1];
        phi2 -= (delta = sign3(y25) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y25) * degrees4;
      } while (abs4(delta) > epsilon23 && --j6 > 0);
      break;
    }
  } while (--i0 >= 0);
  var ax = K3[i0][0], bx = K3[i0 + 1][0], cx = K3[min4(19, i0 + 2)][0];
  return [
    x21 / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    phi2 * radians3
  ];
};
function robinson_default() {
  return projection(robinsonRaw).scale(152.63);
}

// node_modules/d3-geo-projection/src/stitch.js
var epsilon7 = 1e-4;
var x05 = -180;
var x0e = x05 + epsilon7;
var x12 = 180;
var x1e = x12 - epsilon7;
var y05 = -90;
var y0e = y05 + epsilon7;
var y12 = 90;
var y1e = y12 - epsilon7;

// node_modules/d3-geo-projection/src/times.js
function timesRaw(lambda, phi2) {
  var t4 = tan2(phi2 / 2), s12 = sin3(quarterPi2 * t4);
  return [
    lambda * (0.74482 - 0.34588 * s12 * s12),
    1.70711 * t4
  ];
}
timesRaw.invert = function(x21, y25) {
  var t4 = y25 / 1.70711, s12 = sin3(quarterPi2 * t4);
  return [
    x21 / (0.74482 - 0.34588 * s12 * s12),
    2 * atan3(t4)
  ];
};

// node_modules/d3-geo-projection/src/vanDerGrinten.js
function vanDerGrintenRaw(lambda, phi2) {
  if (abs4(phi2) < epsilon6) return [lambda, 0];
  var sinTheta = abs4(phi2 / halfPi4), theta = asin3(sinTheta);
  if (abs4(lambda) < epsilon6 || abs4(abs4(phi2) - halfPi4) < epsilon6) return [0, sign3(phi2) * pi5 * tan2(theta / 2)];
  var cosTheta = cos3(theta), A8 = abs4(pi5 / lambda - lambda / pi5) / 2, A22 = A8 * A8, G = cosTheta / (sinTheta + cosTheta - 1), P5 = G * (2 / sinTheta - 1), P22 = P5 * P5, P2_A2 = P22 + A22, G_P2 = G - P22, Q = A22 + G;
  return [
    sign3(lambda) * pi5 * (A8 * G_P2 + sqrt5(A22 * G_P2 * G_P2 - P2_A2 * (G * G - P22))) / P2_A2,
    sign3(phi2) * pi5 * (P5 * Q - A8 * sqrt5((A22 + 1) * P2_A2 - Q * Q)) / P2_A2
  ];
}
vanDerGrintenRaw.invert = function(x21, y25) {
  if (abs4(y25) < epsilon6) return [x21, 0];
  if (abs4(x21) < epsilon6) return [0, halfPi4 * sin3(2 * atan3(y25 / pi5))];
  var x22 = (x21 /= pi5) * x21, y26 = (y25 /= pi5) * y25, x2_y2 = x22 + y26, z3 = x2_y2 * x2_y2, c1 = -abs4(y25) * (1 + x2_y2), c22 = c1 - 2 * y26 + x22, c32 = -2 * c1 + 1 + 2 * y26 + z3, d18 = y26 / c32 + (2 * c22 * c22 * c22 / (c32 * c32 * c32) - 9 * c1 * c22 / (c32 * c32)) / 27, a1 = (c1 - c22 * c22 / (3 * c32)) / c32, m1 = 2 * sqrt5(-a1 / 3), theta1 = acos3(3 * d18 / (a1 * m1)) / 3;
  return [
    pi5 * (x2_y2 - 1 + sqrt5(1 + 2 * (x22 - y26) + z3)) / (2 * x21),
    sign3(y25) * pi5 * (-m1 * cos3(theta1 + pi5 / 3) - c22 / (3 * c32))
  ];
};

// node_modules/d3-geo-projection/src/vanDerGrinten2.js
function vanDerGrinten2Raw(lambda, phi2) {
  if (abs4(phi2) < epsilon6) return [lambda, 0];
  var sinTheta = abs4(phi2 / halfPi4), theta = asin3(sinTheta);
  if (abs4(lambda) < epsilon6 || abs4(abs4(phi2) - halfPi4) < epsilon6) return [0, sign3(phi2) * pi5 * tan2(theta / 2)];
  var cosTheta = cos3(theta), A8 = abs4(pi5 / lambda - lambda / pi5) / 2, A22 = A8 * A8, x110 = cosTheta * (sqrt5(1 + A22) - A8 * cosTheta) / (1 + A22 * sinTheta * sinTheta);
  return [
    sign3(lambda) * pi5 * x110,
    sign3(phi2) * pi5 * sqrt5(1 - x110 * (2 * A8 + x110))
  ];
}
vanDerGrinten2Raw.invert = function(x21, y25) {
  if (!x21) return [0, halfPi4 * sin3(2 * atan3(y25 / pi5))];
  var x110 = abs4(x21 / pi5), A8 = (1 - x110 * x110 - (y25 /= pi5) * y25) / (2 * x110), A22 = A8 * A8, B12 = sqrt5(A22 + 1);
  return [
    sign3(x21) * pi5 * (B12 - A8),
    sign3(y25) * halfPi4 * sin3(2 * atan23(sqrt5((1 - 2 * A8 * x110) * (A8 + B12) - x110), sqrt5(B12 + A8 + x110)))
  ];
};

// node_modules/d3-geo-projection/src/vanDerGrinten3.js
function vanDerGrinten3Raw(lambda, phi2) {
  if (abs4(phi2) < epsilon6) return [lambda, 0];
  var sinTheta = phi2 / halfPi4, theta = asin3(sinTheta);
  if (abs4(lambda) < epsilon6 || abs4(abs4(phi2) - halfPi4) < epsilon6) return [0, pi5 * tan2(theta / 2)];
  var A8 = (pi5 / lambda - lambda / pi5) / 2, y110 = sinTheta / (1 + cos3(theta));
  return [
    pi5 * (sign3(lambda) * sqrt5(A8 * A8 + 1 - y110 * y110) - A8),
    pi5 * y110
  ];
}
vanDerGrinten3Raw.invert = function(x21, y25) {
  if (!y25) return [x21, 0];
  var y110 = y25 / pi5, A8 = (pi5 * pi5 * (1 - y110 * y110) - x21 * x21) / (2 * pi5 * x21);
  return [
    x21 ? pi5 * (sign3(x21) * sqrt5(A8 * A8 + 1) - A8) : 0,
    halfPi4 * sin3(2 * atan3(y110))
  ];
};

// node_modules/d3-geo-projection/src/vanDerGrinten4.js
function vanDerGrinten4Raw(lambda, phi2) {
  if (!phi2) return [lambda, 0];
  var phi02 = abs4(phi2);
  if (!lambda || phi02 === halfPi4) return [0, phi2];
  var B12 = phi02 / halfPi4, B22 = B12 * B12, C10 = (8 * B12 - B22 * (B22 + 2) - 5) / (2 * B22 * (B12 - 1)), C22 = C10 * C10, BC = B12 * C10, B_C2 = B22 + C22 + 2 * BC, B_3C = B12 + 3 * C10, lambda0 = lambda / halfPi4, lambda1 = lambda0 + 1 / lambda0, D10 = sign3(abs4(lambda) - halfPi4) * sqrt5(lambda1 * lambda1 - 4), D22 = D10 * D10, F12 = B_C2 * (B22 + C22 * D22 - 1) + (1 - B22) * (B22 * (B_3C * B_3C + 4 * C22) + 12 * BC * C22 + 4 * C22 * C22), x110 = (D10 * (B_C2 + C22 - 1) + 2 * sqrt5(F12)) / (4 * B_C2 + D22);
  return [
    sign3(lambda) * halfPi4 * x110,
    sign3(phi2) * halfPi4 * sqrt5(1 + D10 * abs4(x110) - x110 * x110)
  ];
}
vanDerGrinten4Raw.invert = function(x21, y25) {
  var delta;
  if (!x21 || !y25) return [x21, y25];
  var sy = sign3(y25);
  y25 = abs4(y25) / pi5;
  var x110 = sign3(x21) * x21 / halfPi4, D10 = (x110 * x110 - 1 + 4 * y25 * y25) / abs4(x110), D22 = D10 * D10, B12 = y25 * (2 - (y25 > 0.5 ? min4(y25, abs4(x21)) : 0)), r4 = x21 * x21 + y25 * y25, i8 = 50;
  do {
    var B22 = B12 * B12, C10 = (8 * B12 - B22 * (B22 + 2) - 5) / (2 * B22 * (B12 - 1)), C_ = (3 * B12 - B22 * B12 - 10) / (2 * B22 * B12), C22 = C10 * C10, BC = B12 * C10, B_C = B12 + C10, B_C2 = B_C * B_C, B_3C = B12 + 3 * C10, F12 = B_C2 * (B22 + C22 * D22 - 1) + (1 - B22) * (B22 * (B_3C * B_3C + 4 * C22) + C22 * (12 * BC + 4 * C22)), F_ = -2 * B_C * (4 * BC * C22 + (1 - 4 * B22 + 3 * B22 * B22) * (1 + C_) + C22 * (-6 + 14 * B22 - D22 + (-8 + 8 * B22 - 2 * D22) * C_) + BC * (-8 + 12 * B22 + (-10 + 10 * B22 - D22) * C_)), sqrtF = sqrt5(F12), f29 = D10 * (B_C2 + C22 - 1) + 2 * sqrtF - x110 * (4 * B_C2 + D22), f_ = D10 * (2 * C10 * C_ + 2 * B_C * (1 + C_)) + F_ / sqrtF - 8 * B_C * (D10 * (-1 + C22 + B_C2) + 2 * sqrtF) * (1 + C_) / (D22 + 4 * B_C2);
    B12 -= delta = f29 / f_;
  } while (delta * r4 * r4 > epsilon6 && --i8 > 0);
  return [
    sign3(x21) * (sqrt5(D10 * D10 + 4) + D10) * pi5 / 4,
    sy * halfPi4 * B12
  ];
};

// node_modules/d3-geo-projection/src/wagner4.js
var A5 = 4 * pi5 + 3 * sqrt5(3);
var B2 = 2 * sqrt5(2 * pi5 * sqrt5(3) / A5);
var wagner4Raw = mollweideBromleyRaw(B2 * sqrt5(3) / pi5, B2, A5 / 6);

// node_modules/d3-geo-projection/src/wagner6.js
function wagner6Raw(lambda, phi2) {
  return [lambda * sqrt5(1 - 3 * phi2 * phi2 / (pi5 * pi5)), phi2];
}
wagner6Raw.invert = function(x21, y25) {
  return [x21 / sqrt5(1 - 3 * y25 * y25 / (pi5 * pi5)), y25];
};

// node_modules/d3-geo-projection/src/wiechel.js
function wiechelRaw(lambda, phi2) {
  var cosPhi = cos3(phi2), sinPhi = cos3(lambda) * cosPhi, sin1_Phi = 1 - sinPhi, cosLambda = cos3(lambda = atan23(sin3(lambda) * cosPhi, -sin3(phi2))), sinLambda = sin3(lambda);
  cosPhi = sqrt5(1 - sinPhi * sinPhi);
  return [
    sinLambda * cosPhi - cosLambda * sin1_Phi,
    -cosLambda * cosPhi - sinLambda * sin1_Phi
  ];
}
wiechelRaw.invert = function(x21, y25) {
  var w14 = (x21 * x21 + y25 * y25) / -2, k17 = sqrt5(-w14 * (2 + w14)), b25 = y25 * w14 + x21 * k17, a7 = x21 * w14 - y25 * k17, D10 = sqrt5(a7 * a7 + b25 * b25);
  return [
    atan23(k17 * b25, D10 * (1 + w14)),
    D10 ? -asin3(k17 * a7 / D10) : 0
  ];
};

// node_modules/d3-geo-projection/src/winkel3.js
function winkel3Raw(lambda, phi2) {
  var coordinates = aitoffRaw(lambda, phi2);
  return [
    (coordinates[0] + lambda / halfPi4) / 2,
    (coordinates[1] + phi2) / 2
  ];
}
winkel3Raw.invert = function(x21, y25) {
  var lambda = x21, phi2 = y25, i8 = 25;
  do {
    var cosphi = cos3(phi2), sinphi = sin3(phi2), sin_2phi = sin3(2 * phi2), sin2phi = sinphi * sinphi, cos2phi = cosphi * cosphi, sinlambda = sin3(lambda), coslambda_2 = cos3(lambda / 2), sinlambda_2 = sin3(lambda / 2), sin2lambda_2 = sinlambda_2 * sinlambda_2, C10 = 1 - cos2phi * coslambda_2 * coslambda_2, E6 = C10 ? acos3(cosphi * coslambda_2) * sqrt5(F12 = 1 / C10) : F12 = 0, F12, fx = 0.5 * (2 * E6 * cosphi * sinlambda_2 + lambda / halfPi4) - x21, fy = 0.5 * (E6 * sinphi + phi2) - y25, dxdlambda = 0.5 * F12 * (cos2phi * sin2lambda_2 + E6 * cosphi * coslambda_2 * sin2phi) + 0.5 / halfPi4, dxdphi = F12 * (sinlambda * sin_2phi / 4 - E6 * sinphi * sinlambda_2), dydlambda = 0.125 * F12 * (sin_2phi * sinlambda_2 - E6 * sinphi * cos2phi * sinlambda), dydphi = 0.5 * F12 * (sin2phi * coslambda_2 + E6 * sin2lambda_2 * cosphi) + 0.5, denominator = dxdphi * dydlambda - dydphi * dxdlambda, dlambda = (fy * dxdphi - fx * dydphi) / denominator, dphi = (fx * dydlambda - fy * dxdlambda) / denominator;
    lambda -= dlambda, phi2 -= dphi;
  } while ((abs4(dlambda) > epsilon6 || abs4(dphi) > epsilon6) && --i8 > 0);
  return [lambda, phi2];
};

// node_modules/@unovis/ts/components/topojson-map/types.js
var MapPointLabelPosition;
(function(MapPointLabelPosition2) {
  MapPointLabelPosition2["Center"] = "center";
  MapPointLabelPosition2["Bottom"] = "bottom";
})(MapPointLabelPosition || (MapPointLabelPosition = {}));
var MapProjectionKind;
(function(MapProjectionKind2) {
  MapProjectionKind2["Mercator"] = "Mercator";
  MapProjectionKind2["Equirectangular"] = "Equirectangular";
  MapProjectionKind2["AzimuthalEqualArea"] = "AzimuthalEqualArea";
  MapProjectionKind2["AzimuthalEquidistant"] = "AzimuthalEquidistant";
  MapProjectionKind2["Gnomonic"] = "Gnomonic";
  MapProjectionKind2["Orthographic"] = "Orthographic";
  MapProjectionKind2["Stereographic"] = "Stereographic";
  MapProjectionKind2["EqualEarth"] = "EqualEarth";
  MapProjectionKind2["AlbersUsa"] = "AlbersUsa";
  MapProjectionKind2["Albers"] = "Albers";
  MapProjectionKind2["ConicConformal"] = "ConicConformal";
  MapProjectionKind2["ConicEqualArea"] = "ConicEqualArea";
  MapProjectionKind2["ConicEquidistant"] = "ConicEquidistant";
  MapProjectionKind2["TransverseMercator"] = "TransverseMercator";
  MapProjectionKind2["NaturalEarth1"] = "NaturalEarth1";
  MapProjectionKind2["Bromley"] = "Bromley";
  MapProjectionKind2["NaturalEarth2"] = "NaturalEarth2";
  MapProjectionKind2["Kavrayskiy7"] = "Kavrayskiy7";
  MapProjectionKind2["Hufnagel"] = "Hufnagel";
  MapProjectionKind2["FoucautSinusoidal"] = "FoucautSinusoidal";
  MapProjectionKind2["Eckert1"] = "Eckert1";
  MapProjectionKind2["Eckert3"] = "Eckert3";
  MapProjectionKind2["Boggs"] = "Boggs";
  MapProjectionKind2["CylindricalStereographic"] = "CylindricalStereographic";
  MapProjectionKind2["Craster"] = "Craster";
  MapProjectionKind2["Baker"] = "Baker";
  MapProjectionKind2["Armadillo"] = "Armadillo";
  MapProjectionKind2["Aitoff"] = "Aitoff";
  MapProjectionKind2["Fahey"] = "Fahey";
  MapProjectionKind2["Robinson"] = "Robinson";
})(MapProjectionKind || (MapProjectionKind = {}));
var MapProjection = {
  // Projections form `d3-geo`
  [MapProjectionKind.Mercator]: mercator_default,
  [MapProjectionKind.Equirectangular]: equirectangular_default,
  [MapProjectionKind.AzimuthalEqualArea]: azimuthalEqualArea_default,
  [MapProjectionKind.AzimuthalEquidistant]: azimuthalEquidistant_default,
  [MapProjectionKind.Gnomonic]: gnomonic_default,
  [MapProjectionKind.Orthographic]: orthographic_default,
  [MapProjectionKind.Stereographic]: stereographic_default,
  [MapProjectionKind.EqualEarth]: equalEarth_default,
  [MapProjectionKind.AlbersUsa]: albersUsa_default,
  [MapProjectionKind.Albers]: albers_default,
  [MapProjectionKind.ConicConformal]: conicConformal_default,
  [MapProjectionKind.ConicEqualArea]: conicEqualArea_default,
  [MapProjectionKind.ConicEquidistant]: conicEquidistant_default,
  [MapProjectionKind.TransverseMercator]: transverseMercator_default,
  [MapProjectionKind.NaturalEarth1]: naturalEarth1_default,
  // Projections form `d3-geo-projection`
  [MapProjectionKind.Bromley]: bromley_default,
  [MapProjectionKind.NaturalEarth2]: naturalEarth2_default,
  [MapProjectionKind.Kavrayskiy7]: kavrayskiy7_default,
  [MapProjectionKind.Hufnagel]: hufnagel_default,
  [MapProjectionKind.FoucautSinusoidal]: foucautSinusoidal_default,
  [MapProjectionKind.Eckert1]: eckert1_default,
  [MapProjectionKind.Eckert3]: eckert3_default,
  [MapProjectionKind.Boggs]: boggs_default,
  [MapProjectionKind.CylindricalStereographic]: cylindricalStereographic_default,
  [MapProjectionKind.Craster]: craster_default,
  [MapProjectionKind.Baker]: baker_default,
  [MapProjectionKind.Armadillo]: armadillo_default,
  [MapProjectionKind.Aitoff]: aitoff_default,
  [MapProjectionKind.Fahey]: fahey_default,
  [MapProjectionKind.Robinson]: robinson_default
};

// node_modules/@unovis/ts/components/leaflet-map/types.js
var LeafletMapRenderer;
(function(LeafletMapRenderer2) {
  LeafletMapRenderer2["Raster"] = "raster";
  LeafletMapRenderer2["MapLibre"] = "maplibre";
})(LeafletMapRenderer || (LeafletMapRenderer = {}));
var LeafletMapPointShape;
(function(LeafletMapPointShape2) {
  LeafletMapPointShape2["Square"] = "square";
  LeafletMapPointShape2["Circle"] = "circle";
  LeafletMapPointShape2["Triangle"] = "triangle";
  LeafletMapPointShape2["Ring"] = "ring";
})(LeafletMapPointShape || (LeafletMapPointShape = {}));

// node_modules/@unovis/ts/components/leaflet-map/renderer/mapboxgl/mapboxgl-settings.json.js
var bearing = 0;
var name = "F5XC Map Light";
var owner = "F5, Inc.";
var glyphs = "https://api.maptiler.com/fonts/{fontstack}/{range}.pbf";
var sources = {
  openmaptiles: {
    url: "https://api.maptiler.com/tiles/v3/tiles.json",
    type: "vector"
  }
};
var layers = [
  {
    id: "park_outline",
    type: "line",
    source: "openmaptiles",
    "source-layer": "park",
    filter: [
      "all"
    ],
    layout: {},
    paint: {
      "line-color": "rgb(255, 255, 255)",
      "line-dasharray": [
        1,
        1.5
      ],
      "line-opacity": 1
    }
  },
  {
    id: "landuse_residential",
    type: "fill",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "landuse",
    maxzoom: 8,
    filter: [
      "all",
      [
        "in",
        "class",
        "residential",
        "suburbs",
        "neighbourhood"
      ]
    ],
    layout: {
      visibility: "visible"
    },
    paint: {
      "fill-color": {
        stops: [
          [
            9,
            "rgba(236, 236, 236, 0.8)"
          ],
          [
            12,
            "rgba(236, 236, 236, 0.8)"
          ]
        ]
      }
    }
  },
  {
    id: "landcover_wood",
    type: "fill",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "landcover",
    filter: [
      "all",
      [
        "==",
        "class",
        "wood"
      ]
    ],
    paint: {
      "fill-antialias": false,
      "fill-color": "rgba(255, 255, 255, 0.7)",
      "fill-opacity": 0.4
    }
  },
  {
    id: "landcover_grass",
    type: "fill",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "landcover",
    filter: [
      "all",
      [
        "==",
        "class",
        "grass"
      ]
    ],
    paint: {
      "fill-antialias": false,
      "fill-color": "rgb(255, 255, 255)",
      "fill-opacity": 0.3
    }
  },
  {
    id: "landuse_cemetery",
    type: "fill",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "landuse",
    filter: [
      "==",
      "class",
      "cemetery"
    ],
    layout: {
      visibility: "visible"
    },
    paint: {
      "fill-color": "rgb(221, 221, 221)"
    }
  },
  {
    id: "landuse_hospital",
    type: "fill",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "landuse",
    filter: [
      "==",
      "class",
      "hospital"
    ],
    paint: {
      "fill-color": "rgb(249, 249, 249)"
    }
  },
  {
    id: "landuse_school",
    type: "fill",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "landuse",
    filter: [
      "==",
      "class",
      "school"
    ],
    paint: {
      "fill-color": "rgb(236, 236, 236)"
    }
  },
  {
    id: "landuse_stadium",
    type: "fill",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "landuse",
    filter: [
      "all",
      [
        "in",
        "class",
        "stadium",
        "pitch",
        "track"
      ]
    ],
    paint: {
      "fill-color": "rgb(236, 236, 236)"
    }
  },
  {
    id: "waterway_tunnel",
    type: "line",
    source: "openmaptiles",
    "source-layer": "waterway",
    minzoom: 14,
    filter: [
      "all",
      [
        "==",
        "brunnel",
        "tunnel"
      ]
    ],
    layout: {
      "line-cap": "round"
    },
    paint: {
      "line-color": "rgb(236, 237, 238)",
      "line-dasharray": [
        2,
        4
      ],
      "line-width": {
        base: 1.3,
        stops: [
          [
            13,
            0.5
          ],
          [
            20,
            6
          ]
        ]
      }
    }
  },
  {
    id: "waterway_river",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "waterway",
    filter: [
      "all",
      [
        "==",
        "class",
        "river"
      ],
      [
        "!=",
        "brunnel",
        "tunnel"
      ],
      [
        "!=",
        "intermittent",
        1
      ]
    ],
    layout: {
      "line-cap": "round"
    },
    paint: {
      "line-color": "rgb(236, 237, 238)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            11,
            0.5
          ],
          [
            20,
            6
          ]
        ]
      }
    }
  },
  {
    id: "waterway_river_intermittent",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "waterway",
    filter: [
      "all",
      [
        "==",
        "class",
        "river"
      ],
      [
        "!=",
        "brunnel",
        "tunnel"
      ],
      [
        "==",
        "intermittent",
        1
      ]
    ],
    layout: {
      "line-cap": "round"
    },
    paint: {
      "line-color": "#a0c8f0",
      "line-dasharray": [
        3,
        2
      ],
      "line-width": {
        base: 1.2,
        stops: [
          [
            11,
            0.5
          ],
          [
            20,
            6
          ]
        ]
      }
    }
  },
  {
    id: "waterway_other",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "waterway",
    filter: [
      "all",
      [
        "!=",
        "class",
        "river"
      ],
      [
        "!=",
        "brunnel",
        "tunnel"
      ],
      [
        "!=",
        "intermittent",
        1
      ]
    ],
    layout: {
      "line-cap": "round"
    },
    paint: {
      "line-color": "rgb(236, 237, 238)",
      "line-width": {
        base: 1.3,
        stops: [
          [
            13,
            0.5
          ],
          [
            20,
            6
          ]
        ]
      }
    }
  },
  {
    id: "waterway_other_intermittent",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "waterway",
    filter: [
      "all",
      [
        "!=",
        "class",
        "river"
      ],
      [
        "!=",
        "brunnel",
        "tunnel"
      ],
      [
        "==",
        "intermittent",
        1
      ]
    ],
    layout: {
      "line-cap": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": "#a0c8f0",
      "line-dasharray": [
        4,
        3
      ],
      "line-width": {
        base: 1.3,
        stops: [
          [
            13,
            0.5
          ],
          [
            20,
            6
          ]
        ]
      }
    }
  },
  {
    id: "water_intermittent",
    type: "fill",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "water",
    filter: [
      "all",
      [
        "==",
        "intermittent",
        1
      ]
    ],
    layout: {
      visibility: "visible"
    },
    paint: {
      "fill-color": "rgba(172, 218, 251, 1)",
      "fill-opacity": 0.85
    }
  },
  {
    id: "landcover_sand",
    type: "fill",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "landcover",
    filter: [
      "all",
      [
        "in",
        "class",
        "sand"
      ]
    ],
    layout: {
      visibility: "visible"
    },
    paint: {
      "fill-antialias": false,
      "fill-color": "rgb(222, 222, 222)",
      "fill-opacity": 1
    }
  },
  {
    id: "landcover_sand_outline",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "landcover",
    filter: [
      "all",
      [
        "in",
        "class",
        "sand"
      ]
    ],
    layout: {
      visibility: "visible"
    },
    paint: {
      "line-color": "#f2e9ac",
      "line-width": 2
    }
  },
  {
    id: "aeroway_fill",
    type: "fill",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "aeroway",
    minzoom: 11,
    filter: [
      "==",
      "$type",
      "Polygon"
    ],
    paint: {
      "fill-color": "rgb(241, 241, 241)",
      "fill-opacity": 0.7
    }
  },
  {
    id: "aeroway_runway",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "aeroway",
    minzoom: 11,
    filter: [
      "all",
      [
        "==",
        "$type",
        "LineString"
      ],
      [
        "==",
        "class",
        "runway"
      ]
    ],
    paint: {
      "line-color": "rgb(255, 255, 255)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            11,
            3
          ],
          [
            20,
            16
          ]
        ]
      }
    }
  },
  {
    id: "aeroway_taxiway",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "aeroway",
    minzoom: 11,
    filter: [
      "all",
      [
        "==",
        "$type",
        "LineString"
      ],
      [
        "==",
        "class",
        "taxiway"
      ]
    ],
    paint: {
      "line-color": "rgb(255, 255, 255)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            11,
            0.5
          ],
          [
            20,
            6
          ]
        ]
      }
    }
  },
  {
    id: "ferry",
    type: "line",
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "in",
        "class",
        "ferry"
      ]
    ],
    layout: {
      "line-join": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": "rgb(182, 182, 182)",
      "line-dasharray": [
        2,
        2
      ],
      "line-width": 1.1
    }
  },
  {
    id: "tunnel_motorway_link_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "class",
        "motorway"
      ],
      [
        "==",
        "ramp",
        1
      ],
      [
        "==",
        "brunnel",
        "tunnel"
      ]
    ],
    layout: {
      "line-join": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": "rgb(233, 160, 182)",
      "line-dasharray": [
        0.5,
        0.25
      ],
      "line-opacity": 1,
      "line-width": {
        base: 1.2,
        stops: [
          [
            12,
            1
          ],
          [
            13,
            3
          ],
          [
            14,
            4
          ],
          [
            20,
            15
          ]
        ]
      }
    }
  },
  {
    id: "tunnel_service_track_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "brunnel",
        "tunnel"
      ],
      [
        "in",
        "class",
        "service",
        "track"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgb(225, 225, 225)",
      "line-dasharray": [
        0.5,
        0.25
      ],
      "line-width": {
        base: 1.2,
        stops: [
          [
            15,
            1
          ],
          [
            16,
            4
          ],
          [
            20,
            11
          ]
        ]
      }
    }
  },
  {
    id: "tunnel_link_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "ramp",
        "1"
      ],
      [
        "==",
        "brunnel",
        "tunnel"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgb(233, 160, 182)",
      "line-opacity": 1,
      "line-width": {
        base: 1.2,
        stops: [
          [
            12,
            1
          ],
          [
            13,
            3
          ],
          [
            14,
            4
          ],
          [
            20,
            15
          ]
        ]
      }
    }
  },
  {
    id: "tunnel_street_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "brunnel",
        "tunnel"
      ],
      [
        "in",
        "class",
        "street",
        "street_limited"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgb(225, 225, 225)",
      "line-opacity": {
        stops: [
          [
            12,
            0
          ],
          [
            12.5,
            1
          ]
        ]
      },
      "line-width": {
        base: 1.2,
        stops: [
          [
            12,
            0.5
          ],
          [
            13,
            1
          ],
          [
            14,
            4
          ],
          [
            20,
            15
          ]
        ]
      }
    }
  },
  {
    id: "tunnel_secondary_tertiary_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "brunnel",
        "tunnel"
      ],
      [
        "in",
        "class",
        "secondary",
        "tertiary"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgb(212, 212, 212)",
      "line-dasharray": [
        0.5,
        0.25
      ],
      "line-opacity": 1,
      "line-width": {
        base: 1.2,
        stops: [
          [
            8,
            1.5
          ],
          [
            20,
            17
          ]
        ]
      }
    }
  },
  {
    id: "tunnel_trunk_primary_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "brunnel",
        "tunnel"
      ],
      [
        "in",
        "class",
        "primary",
        "trunk"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgb(233, 160, 182)",
      "line-dasharray": [
        0.5,
        0.25
      ],
      "line-width": {
        base: 1.2,
        stops: [
          [
            5,
            0.4
          ],
          [
            6,
            0.7
          ],
          [
            7,
            1.75
          ],
          [
            20,
            22
          ]
        ]
      }
    }
  },
  {
    id: "tunnel_motorway_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "class",
        "motorway"
      ],
      [
        "==",
        "brunnel",
        "tunnel"
      ]
    ],
    layout: {
      "line-join": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": "rgb(233, 160, 182)",
      "line-dasharray": [
        0.5,
        0.25
      ],
      "line-width": {
        base: 1.2,
        stops: [
          [
            5,
            0.4
          ],
          [
            6,
            0.7
          ],
          [
            7,
            1.75
          ],
          [
            20,
            22
          ]
        ]
      }
    }
  },
  {
    id: "tunnel_path_pedestrian",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "$type",
        "LineString"
      ],
      [
        "==",
        "brunnel",
        "tunnel"
      ],
      [
        "in",
        "class",
        "path",
        "pedestrian"
      ]
    ],
    layout: {
      visibility: "visible"
    },
    paint: {
      "line-color": "rgba(216, 205, 206, 0.45)",
      "line-dasharray": [
        1,
        0.75
      ],
      "line-width": {
        base: 1.2,
        stops: [
          [
            14,
            0.5
          ],
          [
            20,
            6
          ]
        ]
      }
    }
  },
  {
    id: "tunnel_motorway_link",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "class",
        "motorway_link"
      ],
      [
        "==",
        "ramp",
        1
      ],
      [
        "==",
        "brunnel",
        "tunnel"
      ]
    ],
    layout: {
      "line-join": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": "rgb(251, 181, 195)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            12.5,
            0
          ],
          [
            13,
            1.5
          ],
          [
            14,
            2.5
          ],
          [
            20,
            11.5
          ]
        ]
      }
    }
  },
  {
    id: "tunnel_service_track",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "brunnel",
        "tunnel"
      ],
      [
        "in",
        "class",
        "service",
        "track"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgb(255, 255, 255)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            15.5,
            0
          ],
          [
            16,
            2
          ],
          [
            20,
            7.5
          ]
        ]
      }
    }
  },
  {
    id: "tunnel_link",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "ramp",
        "1"
      ],
      [
        "==",
        "brunnel",
        "tunnel"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgb(254, 240, 240)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            12.5,
            0
          ],
          [
            13,
            1.5
          ],
          [
            14,
            2.5
          ],
          [
            20,
            11.5
          ]
        ]
      }
    }
  },
  {
    id: "tunnel_minor",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "brunnel",
        "tunnel"
      ],
      [
        "in",
        "class",
        "minor"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgb(255, 255, 255)",
      "line-opacity": 1,
      "line-width": {
        base: 1.2,
        stops: [
          [
            13.5,
            0
          ],
          [
            14,
            2.5
          ],
          [
            20,
            11.5
          ]
        ]
      }
    }
  },
  {
    id: "tunnel_secondary_tertiary",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "brunnel",
        "tunnel"
      ],
      [
        "in",
        "class",
        "secondary",
        "tertiary"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgb(255, 255, 255)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            6.5,
            0
          ],
          [
            8,
            0.5
          ],
          [
            20,
            13
          ]
        ]
      }
    }
  },
  {
    id: "tunnel_trunk_primary",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "brunnel",
        "tunnel"
      ],
      [
        "in",
        "class",
        "primary",
        "trunk"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgb(254, 240, 240)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            5,
            0
          ],
          [
            7,
            1
          ],
          [
            20,
            18
          ]
        ]
      }
    }
  },
  {
    id: "tunnel_motorway",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "class",
        "motorway"
      ],
      [
        "==",
        "brunnel",
        "tunnel"
      ]
    ],
    layout: {
      "line-join": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": "rgb(253, 209, 217)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            5,
            0
          ],
          [
            7,
            1
          ],
          [
            20,
            18
          ]
        ]
      }
    }
  },
  {
    id: "tunnel_major_rail",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "brunnel",
        "tunnel"
      ],
      [
        "in",
        "class",
        "rail"
      ]
    ],
    paint: {
      "line-color": "rgb(208, 208, 208)",
      "line-width": {
        base: 1.4,
        stops: [
          [
            14,
            0.4
          ],
          [
            15,
            0.75
          ],
          [
            20,
            2
          ]
        ]
      }
    }
  },
  {
    id: "tunnel_major_rail_hatching",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "brunnel",
        "tunnel"
      ],
      [
        "==",
        "class",
        "rail"
      ]
    ],
    paint: {
      "line-color": "rgb(208, 208, 208)",
      "line-dasharray": [
        0.2,
        8
      ],
      "line-width": {
        base: 1.4,
        stops: [
          [
            14.5,
            0
          ],
          [
            15,
            3
          ],
          [
            20,
            8
          ]
        ]
      }
    }
  },
  {
    id: "road_area_pier",
    type: "fill",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "$type",
        "Polygon"
      ],
      [
        "==",
        "class",
        "pier"
      ]
    ],
    layout: {
      visibility: "visible"
    },
    paint: {
      "fill-antialias": true,
      "fill-color": "rgb(252, 252, 252)"
    }
  },
  {
    id: "road_pier",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "$type",
        "LineString"
      ],
      [
        "in",
        "class",
        "pier"
      ]
    ],
    layout: {
      "line-cap": "round",
      "line-join": "round"
    },
    paint: {
      "line-color": "rgba(246, 241, 229, 1)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            15,
            1
          ],
          [
            17,
            4
          ]
        ]
      }
    }
  },
  {
    id: "road_area_bridge",
    type: "fill",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "$type",
        "Polygon"
      ],
      [
        "==",
        "brunnel",
        "bridge"
      ]
    ],
    layout: {
      visibility: "visible"
    },
    paint: {
      "fill-antialias": true,
      "fill-color": "rgba(255, 255, 255, 0.6)"
    }
  },
  {
    id: "road_area_pattern",
    type: "fill",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "$type",
        "Polygon"
      ],
      [
        "!has",
        "brunnel"
      ],
      [
        "!in",
        "class",
        "bridge",
        "pier"
      ]
    ],
    layout: {
      visibility: "visible"
    },
    paint: {
      "fill-color": "rgba(252, 252, 252, 1.0)"
    }
  },
  {
    id: "road_service_track_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "!in",
        "brunnel",
        "bridge",
        "tunnel"
      ],
      [
        "in",
        "class",
        "service",
        "track"
      ]
    ],
    layout: {
      "line-cap": "round",
      "line-join": "round"
    },
    paint: {
      "line-color": "rgb(225, 225, 225)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            15,
            1
          ],
          [
            16,
            4
          ],
          [
            20,
            11
          ]
        ]
      }
    }
  },
  {
    id: "road_link_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    minzoom: 13,
    filter: [
      "all",
      [
        "!in",
        "brunnel",
        "bridge",
        "tunnel"
      ],
      [
        "!in",
        "class",
        "motorway",
        "trunk",
        "primary",
        "pedestrian",
        "path",
        "track",
        "service"
      ],
      [
        "==",
        "ramp",
        1
      ]
    ],
    layout: {
      "line-cap": "round",
      "line-join": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": "rgb(233, 160, 182)",
      "line-opacity": 1,
      "line-width": {
        base: 1.2,
        stops: [
          [
            12,
            1
          ],
          [
            13,
            3
          ],
          [
            14,
            4
          ],
          [
            20,
            15
          ]
        ]
      }
    }
  },
  {
    id: "road_trunk_primary_link_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "!in",
        "brunnel",
        "bridge",
        "tunnel"
      ],
      [
        "==",
        "ramp",
        1
      ],
      [
        "in",
        "class",
        "primary",
        "trunk"
      ]
    ],
    layout: {
      "line-cap": "butt",
      "line-join": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": "rgba(246, 241, 232, 1)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            5,
            0
          ],
          [
            7,
            0.7
          ],
          [
            20,
            14
          ]
        ]
      }
    }
  },
  {
    id: "road_motorway_link_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    minzoom: 12,
    filter: [
      "all",
      [
        "!in",
        "brunnel",
        "bridge",
        "tunnel"
      ],
      [
        "==",
        "class",
        "motorway"
      ],
      [
        "==",
        "ramp",
        1
      ]
    ],
    layout: {
      "line-cap": "butt",
      "line-join": "round"
    },
    paint: {
      "line-color": "rgba(246, 241, 232, 1)",
      "line-opacity": 1,
      "line-width": {
        base: 1.2,
        stops: [
          [
            12,
            1
          ],
          [
            13,
            3
          ],
          [
            14,
            4
          ],
          [
            20,
            15
          ]
        ]
      }
    }
  },
  {
    id: "road_minor_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "$type",
        "LineString"
      ],
      [
        "!in",
        "brunnel",
        "bridge",
        "tunnel"
      ],
      [
        "in",
        "class",
        "minor"
      ],
      [
        "!=",
        "ramp",
        "1"
      ]
    ],
    layout: {
      "line-cap": "round",
      "line-join": "round"
    },
    paint: {
      "line-color": "rgb(225, 225, 225)",
      "line-opacity": {
        stops: [
          [
            12,
            0
          ],
          [
            12.5,
            1
          ]
        ]
      },
      "line-width": {
        base: 1.2,
        stops: [
          [
            12,
            0.5
          ],
          [
            13,
            1
          ],
          [
            14,
            4
          ],
          [
            20,
            20
          ]
        ]
      }
    }
  },
  {
    id: "road_secondary_tertiary_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "!in",
        "brunnel",
        "bridge",
        "tunnel"
      ],
      [
        "in",
        "class",
        "secondary",
        "tertiary"
      ],
      [
        "!=",
        "ramp",
        1
      ]
    ],
    layout: {
      "line-cap": "round",
      "line-join": "round",
      visibility: "none"
    },
    paint: {
      "line-color": "rgb(212, 212, 212)",
      "line-opacity": 1,
      "line-width": {
        base: 1.2,
        stops: [
          [
            8,
            1.5
          ],
          [
            20,
            17
          ]
        ]
      }
    }
  },
  {
    id: "road_trunk_primary_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "!in",
        "brunnel",
        "bridge",
        "tunnel"
      ],
      [
        "!=",
        "ramp",
        1
      ],
      [
        "in",
        "class",
        "primary",
        "trunk"
      ],
      [
        "!=",
        "ramp",
        1
      ]
    ],
    layout: {
      "line-cap": "butt",
      "line-join": "round",
      visibility: "none"
    },
    paint: {
      "line-color": "rgba(246, 241, 232, 1)",
      "line-opacity": 1,
      "line-width": {
        base: 1.2,
        stops: [
          [
            5,
            0.4
          ],
          [
            6,
            0.7
          ],
          [
            7,
            1.75
          ],
          [
            20,
            22
          ]
        ]
      }
    }
  },
  {
    id: "road_motorway_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    minzoom: 5,
    filter: [
      "all",
      [
        "!in",
        "brunnel",
        "bridge",
        "tunnel"
      ],
      [
        "==",
        "class",
        "motorway"
      ],
      [
        "!=",
        "ramp",
        1
      ]
    ],
    layout: {
      "line-cap": "butt",
      "line-join": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": "rgba(163, 213, 217, .)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            5,
            0.4
          ],
          [
            6,
            0.7
          ],
          [
            7,
            1.75
          ],
          [
            20,
            22
          ]
        ]
      }
    }
  },
  {
    id: "road_path_pedestrian",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    minzoom: 14,
    filter: [
      "all",
      [
        "==",
        "$type",
        "LineString"
      ],
      [
        "!in",
        "brunnel",
        "bridge",
        "tunnel"
      ],
      [
        "in",
        "class",
        "path",
        "pedestrian"
      ]
    ],
    layout: {
      "line-join": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": "rgba(216, 205, 206, 0.45)",
      "line-dasharray": [
        1,
        1
      ],
      "line-width": {
        base: 1.2,
        stops: [
          [
            14,
            1
          ],
          [
            20,
            6
          ]
        ]
      }
    }
  },
  {
    id: "road_link",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    minzoom: 13,
    filter: [
      "all",
      [
        "!in",
        "brunnel",
        "bridge",
        "tunnel"
      ],
      [
        "==",
        "ramp",
        1
      ],
      [
        "!in",
        "class",
        "motorway",
        "trunk",
        "primary",
        "pedestrian",
        "path",
        "track",
        "service"
      ]
    ],
    layout: {
      "line-cap": "round",
      "line-join": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": "rgba(246, 241, 232, 1)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            12.5,
            0
          ],
          [
            13,
            1.5
          ],
          [
            14,
            2.5
          ],
          [
            20,
            11.5
          ]
        ]
      }
    }
  },
  {
    id: "road_trunk_primary_link",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "!in",
        "brunnel",
        "bridge",
        "tunnel"
      ],
      [
        "==",
        "ramp",
        1
      ],
      [
        "in",
        "class",
        "primary",
        "trunk"
      ]
    ],
    layout: {
      "line-cap": "round",
      "line-join": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": "rgba(246, 241, 232, 1)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            5,
            0
          ],
          [
            7,
            0.5
          ],
          [
            20,
            10
          ]
        ]
      }
    }
  },
  {
    id: "road_motorway_link",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    minzoom: 12,
    filter: [
      "all",
      [
        "!in",
        "brunnel",
        "bridge",
        "tunnel"
      ],
      [
        "==",
        "class",
        "motorway"
      ],
      [
        "==",
        "ramp",
        1
      ]
    ],
    layout: {
      "line-cap": "round",
      "line-join": "round"
    },
    paint: {
      "line-color": "rgba(246, 241, 232, 1)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            12.5,
            0
          ],
          [
            13,
            1.5
          ],
          [
            14,
            2.5
          ],
          [
            20,
            11.5
          ]
        ]
      }
    }
  },
  {
    id: "road_service_track",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "!in",
        "brunnel",
        "bridge",
        "tunnel"
      ],
      [
        "in",
        "class",
        "service",
        "track"
      ]
    ],
    layout: {
      "line-cap": "round",
      "line-join": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": "rgb(255, 255, 255)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            15.5,
            0
          ],
          [
            16,
            2
          ],
          [
            20,
            7.5
          ]
        ]
      }
    }
  },
  {
    id: "road_minor",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "$type",
        "LineString"
      ],
      [
        "all",
        [
          "!in",
          "brunnel",
          "bridge",
          "tunnel"
        ],
        [
          "in",
          "class",
          "minor"
        ]
      ]
    ],
    layout: {
      "line-cap": "round",
      "line-join": "round",
      visibility: "none"
    },
    paint: {
      "line-color": "rgb(255, 255, 255)",
      "line-opacity": 1,
      "line-width": {
        base: 1.2,
        stops: [
          [
            13.5,
            0
          ],
          [
            14,
            2.5
          ],
          [
            20,
            18
          ]
        ]
      }
    }
  },
  {
    id: "road_secondary_tertiary",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "!in",
        "brunnel",
        "bridge",
        "tunnel"
      ],
      [
        "in",
        "class",
        "secondary",
        "tertiary"
      ]
    ],
    layout: {
      "line-cap": "round",
      "line-join": "round",
      visibility: "none"
    },
    paint: {
      "line-color": "rgb(255, 255, 255)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            6.5,
            0
          ],
          [
            8,
            0.5
          ],
          [
            20,
            13
          ]
        ]
      }
    }
  },
  {
    id: "road_trunk_primary",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "!in",
        "brunnel",
        "bridge",
        "tunnel"
      ],
      [
        "!=",
        "ramp",
        1
      ],
      [
        "in",
        "class",
        "primary",
        "trunk"
      ]
    ],
    layout: {
      "line-cap": "round",
      "line-join": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": "rgba(246, 241, 232, 1)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            5,
            0
          ],
          [
            7,
            1
          ],
          [
            20,
            18
          ]
        ]
      }
    }
  },
  {
    id: "road_motorway",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    minzoom: 5,
    filter: [
      "all",
      [
        "!in",
        "brunnel",
        "bridge",
        "tunnel"
      ],
      [
        "==",
        "class",
        "motorway"
      ],
      [
        "!=",
        "ramp",
        1
      ]
    ],
    layout: {
      "line-cap": "round",
      "line-join": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": {
        stops: [
          [
            5,
            "rgba(246, 241, 232, 1)"
          ],
          [
            6,
            "rgba(246, 241, 232, 1)"
          ]
        ]
      },
      "line-width": {
        base: 1.2,
        stops: [
          [
            5,
            0
          ],
          [
            7,
            1
          ],
          [
            20,
            18
          ]
        ]
      }
    }
  },
  {
    id: "road_major_rail",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "!in",
        "brunnel",
        "bridge",
        "tunnel"
      ],
      [
        "==",
        "class",
        "rail"
      ]
    ],
    paint: {
      "line-color": "rgb(208, 208, 208)",
      "line-width": {
        base: 1.4,
        stops: [
          [
            14,
            0.4
          ],
          [
            15,
            0.75
          ],
          [
            20,
            2
          ]
        ]
      }
    }
  },
  {
    id: "road_major_rail_hatching",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "!in",
        "brunnel",
        "bridge",
        "tunnel"
      ],
      [
        "==",
        "class",
        "rail"
      ]
    ],
    paint: {
      "line-color": "rgb(208, 208, 208)",
      "line-dasharray": [
        0.2,
        8
      ],
      "line-width": {
        base: 1.4,
        stops: [
          [
            14.5,
            0
          ],
          [
            15,
            3
          ],
          [
            20,
            8
          ]
        ]
      }
    }
  },
  {
    id: "building",
    type: "fill",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "building",
    minzoom: 13,
    maxzoom: 14,
    layout: {
      visibility: "visible"
    },
    paint: {
      "fill-color": "rgba(181, 181, 181, 0.3)",
      "fill-outline-color": {
        stops: [
          [
            13,
            "rgba(198, 197, 197, 0.32)"
          ],
          [
            14,
            "rgb(198, 197, 197)"
          ]
        ]
      }
    }
  },
  {
    id: "building-3d",
    type: "fill-extrusion",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "building",
    minzoom: 14,
    filter: [
      "all",
      [
        "!has",
        "hide_3d"
      ]
    ],
    layout: {
      visibility: "visible"
    },
    paint: {
      "fill-extrusion-base": {
        property: "render_min_height",
        type: "identity"
      },
      "fill-extrusion-color": "rgb(181, 181, 181)",
      "fill-extrusion-height": {
        property: "render_height",
        type: "identity"
      },
      "fill-extrusion-opacity": 0.3
    }
  },
  {
    id: "waterway-bridge-case",
    type: "line",
    source: "openmaptiles",
    "source-layer": "waterway",
    filter: [
      "all",
      [
        "==",
        "$type",
        "LineString"
      ],
      [
        "==",
        "brunnel",
        "bridge"
      ]
    ],
    layout: {
      "line-cap": "butt",
      "line-join": "miter"
    },
    paint: {
      "line-color": "rgb(224, 224, 224)",
      "line-gap-width": {
        base: 1.3,
        stops: [
          [
            13,
            0.5
          ],
          [
            20,
            6
          ]
        ]
      },
      "line-width": {
        base: 1.6,
        stops: [
          [
            12,
            0.5
          ],
          [
            20,
            5
          ]
        ]
      }
    }
  },
  {
    id: "waterway-bridge",
    type: "line",
    source: "openmaptiles",
    "source-layer": "waterway",
    filter: [
      "all",
      [
        "==",
        "$type",
        "LineString"
      ],
      [
        "==",
        "brunnel",
        "bridge"
      ]
    ],
    layout: {
      "line-cap": "round",
      "line-join": "round"
    },
    paint: {
      "line-color": "rgb(223, 229, 235)",
      "line-width": {
        base: 1.3,
        stops: [
          [
            13,
            0.5
          ],
          [
            20,
            6
          ]
        ]
      }
    }
  },
  {
    id: "bridge_motorway_link_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "class",
        "motorway"
      ],
      [
        "==",
        "ramp",
        1
      ],
      [
        "==",
        "brunnel",
        "bridge"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgba(223, 219, 202, 1)",
      "line-opacity": 1,
      "line-width": {
        base: 1.2,
        stops: [
          [
            12,
            1
          ],
          [
            13,
            3
          ],
          [
            14,
            4
          ],
          [
            20,
            15
          ]
        ]
      }
    }
  },
  {
    id: "bridge_service_track_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "brunnel",
        "bridge"
      ],
      [
        "in",
        "class",
        "service",
        "track"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgb(225, 225, 225)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            15,
            1
          ],
          [
            16,
            4
          ],
          [
            20,
            11
          ]
        ]
      }
    }
  },
  {
    id: "bridge_link_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "class",
        "link"
      ],
      [
        "==",
        "brunnel",
        "bridge"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgba(223, 219, 202, 1)",
      "line-opacity": 1,
      "line-width": {
        base: 1.2,
        stops: [
          [
            12,
            1
          ],
          [
            13,
            3
          ],
          [
            14,
            4
          ],
          [
            20,
            15
          ]
        ]
      }
    }
  },
  {
    id: "bridge_street_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "brunnel",
        "bridge"
      ],
      [
        "in",
        "class",
        "street",
        "street_limited"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgb(209, 209, 209)",
      "line-opacity": {
        stops: [
          [
            12,
            0
          ],
          [
            12.5,
            1
          ]
        ]
      },
      "line-width": {
        base: 1.2,
        stops: [
          [
            12,
            0.5
          ],
          [
            13,
            1
          ],
          [
            14,
            4
          ],
          [
            20,
            25
          ]
        ]
      }
    }
  },
  {
    id: "bridge_path_pedestrian_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "$type",
        "LineString"
      ],
      [
        "==",
        "brunnel",
        "bridge"
      ],
      [
        "in",
        "class",
        "path",
        "pedestrian"
      ]
    ],
    layout: {
      "line-join": "miter",
      visibility: "visible"
    },
    paint: {
      "line-color": "rgb(225, 225, 225)",
      "line-dasharray": [
        1,
        0
      ],
      "line-width": {
        base: 1.2,
        stops: [
          [
            14,
            1.5
          ],
          [
            20,
            18
          ]
        ]
      }
    }
  },
  {
    id: "bridge_secondary_tertiary_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "brunnel",
        "bridge"
      ],
      [
        "in",
        "class",
        "secondary",
        "tertiary"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgb(212, 212, 212)",
      "line-opacity": 1,
      "line-width": {
        base: 1.2,
        stops: [
          [
            8,
            1.5
          ],
          [
            20,
            17
          ]
        ]
      }
    }
  },
  {
    id: "bridge_trunk_primary_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "brunnel",
        "bridge"
      ],
      [
        "in",
        "class",
        "primary",
        "trunk"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgba(223, 219, 202, 1)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            5,
            0.4
          ],
          [
            6,
            0.7
          ],
          [
            7,
            1.75
          ],
          [
            20,
            22
          ]
        ]
      }
    }
  },
  {
    id: "bridge_motorway_casing",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "class",
        "motorway"
      ],
      [
        "==",
        "brunnel",
        "bridge"
      ],
      [
        "!=",
        "ramp",
        1
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgba(223, 219, 202, 1)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            5,
            0.4
          ],
          [
            6,
            0.7
          ],
          [
            7,
            1.75
          ],
          [
            20,
            22
          ]
        ]
      }
    }
  },
  {
    id: "bridge_path_pedestrian",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "$type",
        "LineString"
      ],
      [
        "==",
        "brunnel",
        "bridge"
      ],
      [
        "in",
        "class",
        "path",
        "pedestrian"
      ]
    ],
    paint: {
      "line-color": "rgb(255, 255, 255)",
      "line-dasharray": [
        1,
        0.3
      ],
      "line-width": {
        base: 1.2,
        stops: [
          [
            14,
            0.5
          ],
          [
            20,
            10
          ]
        ]
      }
    }
  },
  {
    id: "bridge_motorway_link",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "class",
        "motorway"
      ],
      [
        "==",
        "ramp",
        1
      ],
      [
        "==",
        "brunnel",
        "bridge"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgba(223, 219, 202, 1)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            12.5,
            0
          ],
          [
            13,
            1.5
          ],
          [
            14,
            2.5
          ],
          [
            20,
            11.5
          ]
        ]
      }
    }
  },
  {
    id: "bridge_service_track",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "brunnel",
        "bridge"
      ],
      [
        "in",
        "class",
        "service",
        "track"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgb(255, 255, 255)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            15.5,
            0
          ],
          [
            16,
            2
          ],
          [
            20,
            7.5
          ]
        ]
      }
    }
  },
  {
    id: "bridge_link",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "class",
        "link"
      ],
      [
        "==",
        "brunnel",
        "bridge"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgba(223, 219, 202, 1)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            12.5,
            0
          ],
          [
            13,
            1.5
          ],
          [
            14,
            2.5
          ],
          [
            20,
            11.5
          ]
        ]
      }
    }
  },
  {
    id: "bridge_street",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "brunnel",
        "bridge"
      ],
      [
        "in",
        "class",
        "minor"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgb(255, 255, 255)",
      "line-opacity": 1,
      "line-width": {
        base: 1.2,
        stops: [
          [
            13.5,
            0
          ],
          [
            14,
            2.5
          ],
          [
            20,
            18
          ]
        ]
      }
    }
  },
  {
    id: "bridge_secondary_tertiary",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "brunnel",
        "bridge"
      ],
      [
        "in",
        "class",
        "secondary",
        "tertiary"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgb(255, 255, 255)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            6.5,
            0
          ],
          [
            8,
            0.5
          ],
          [
            20,
            13
          ]
        ]
      }
    }
  },
  {
    id: "bridge_trunk_primary",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "brunnel",
        "bridge"
      ],
      [
        "in",
        "class",
        "primary",
        "trunk"
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgba(223, 219, 202, 1)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            5,
            0
          ],
          [
            7,
            1
          ],
          [
            20,
            18
          ]
        ]
      }
    }
  },
  {
    id: "bridge_motorway",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "class",
        "motorway"
      ],
      [
        "==",
        "brunnel",
        "bridge"
      ],
      [
        "!=",
        "ramp",
        1
      ]
    ],
    layout: {
      "line-join": "round"
    },
    paint: {
      "line-color": "rgba(223, 219, 202, 1)",
      "line-width": {
        base: 1.2,
        stops: [
          [
            5,
            0
          ],
          [
            7,
            1
          ],
          [
            20,
            18
          ]
        ]
      }
    }
  },
  {
    id: "bridge_major_rail",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "class",
        "rail"
      ],
      [
        "==",
        "brunnel",
        "bridge"
      ]
    ],
    paint: {
      "line-color": "rgb(208, 208, 208)",
      "line-width": {
        base: 1.4,
        stops: [
          [
            14,
            0.4
          ],
          [
            15,
            0.75
          ],
          [
            20,
            2
          ]
        ]
      }
    }
  },
  {
    id: "bridge_major_rail_hatching",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation",
    filter: [
      "all",
      [
        "==",
        "class",
        "rail"
      ],
      [
        "==",
        "brunnel",
        "bridge"
      ]
    ],
    paint: {
      "line-color": "rgb(208, 208, 208)",
      "line-dasharray": [
        0.2,
        8
      ],
      "line-width": {
        base: 1.4,
        stops: [
          [
            14.5,
            0
          ],
          [
            15,
            3
          ],
          [
            20,
            8
          ]
        ]
      }
    }
  },
  {
    id: "cablecar",
    type: "line",
    source: "openmaptiles",
    "source-layer": "transportation",
    minzoom: 13,
    filter: [
      "==",
      "class",
      "cable_car"
    ],
    layout: {
      "line-cap": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": "rgb(199, 199, 199)",
      "line-width": {
        base: 1,
        stops: [
          [
            11,
            1
          ],
          [
            19,
            2.5
          ]
        ]
      }
    }
  },
  {
    id: "cablecar-dash",
    type: "line",
    source: "openmaptiles",
    "source-layer": "transportation",
    minzoom: 13,
    filter: [
      "==",
      "class",
      "cable_car"
    ],
    layout: {
      "line-cap": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": "rgb(199, 199, 199)",
      "line-dasharray": [
        2,
        3
      ],
      "line-width": {
        base: 1,
        stops: [
          [
            11,
            3
          ],
          [
            19,
            5.5
          ]
        ]
      }
    }
  },
  {
    id: "boundary_3",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "boundary",
    filter: [
      "match",
      [
        "get",
        "admin_level"
      ],
      [
        3,
        4
      ],
      true,
      false
    ],
    layout: {
      "line-join": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": "rgb(197, 208, 216)",
      "line-dasharray": [
        1,
        1
      ],
      "line-width": {
        base: 1,
        stops: [
          [
            4,
            0.4
          ],
          [
            5,
            1
          ],
          [
            12,
            1.8
          ]
        ]
      },
      "line-opacity": 0.5
    }
  },
  {
    id: "boundary_2",
    type: "line",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "boundary",
    filter: [
      "all",
      [
        "==",
        "admin_level",
        2
      ],
      [
        "!=",
        "disputed",
        1
      ]
    ],
    layout: {
      "line-cap": "round",
      "line-join": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": "rgb(197, 208, 216)",
      "line-opacity": {
        base: 1,
        stops: [
          [
            0,
            0.4
          ],
          [
            4,
            0.8
          ]
        ]
      },
      "line-width": {
        base: 1,
        stops: [
          [
            3,
            1
          ],
          [
            5,
            1.2
          ],
          [
            12,
            3
          ]
        ]
      }
    }
  },
  {
    id: "boundary_disputed_level_2",
    type: "line",
    source: "openmaptiles",
    "source-layer": "boundary",
    minzoom: 0,
    filter: [
      "all",
      [
        "<=",
        "admin_level",
        2
      ],
      [
        "==",
        "disputed",
        1
      ]
    ],
    layout: {
      "line-cap": "round",
      "line-join": "round",
      visibility: "visible"
    },
    paint: {
      "line-color": "rgb(197, 208, 216)",
      "line-width": 1,
      "line-opacity": 0.7,
      "line-dasharray": [
        6,
        6
      ]
    }
  },
  {
    id: "water_name_line",
    type: "symbol",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "water_name",
    minzoom: 0,
    filter: [
      "all",
      [
        "==",
        "$type",
        "LineString"
      ]
    ],
    layout: {
      "symbol-placement": "line",
      "text-field": "{name_en}",
      "text-font": [
        "Open Sans Regular"
      ],
      "text-max-width": 5,
      "text-size": 12
    },
    paint: {
      "text-color": "rgb(178, 178, 178)",
      "text-halo-color": "rgba(255, 255, 255, 0.7)",
      "text-halo-width": 1
    }
  },
  {
    id: "water_name_point",
    type: "symbol",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "water_name",
    minzoom: 2,
    maxzoom: 24,
    filter: [
      "all",
      [
        "==",
        "$type",
        "Point"
      ],
      [
        "!=",
        "class",
        "ocean"
      ]
    ],
    layout: {
      "text-field": "{name_en}",
      "text-font": [
        "Open Sans Regular"
      ],
      "text-max-width": 5,
      "text-size": 12
    },
    paint: {
      "text-color": "rgba(159, 178, 195, 0.8)",
      "text-halo-color": "rgba(255, 255, 255, 0)",
      "text-halo-width": 1
    }
  },
  {
    id: "water_ocean_name_point",
    type: "symbol",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "water_name",
    minzoom: 0,
    filter: [
      "all",
      [
        "==",
        "$type",
        "Point"
      ],
      [
        "==",
        "class",
        "ocean"
      ]
    ],
    layout: {
      "text-field": "{name_en}",
      "text-font": [
        "Open Sans Regular"
      ],
      "text-max-width": 5,
      "text-size": 12
    },
    paint: {
      "text-color": "rgba(159, 178, 195, 0.6)",
      "text-halo-color": "rgba(255, 255, 255, 0)",
      "text-halo-width": 1
    }
  },
  {
    id: "poi_z16_subclass",
    type: "symbol",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "poi",
    minzoom: 16,
    filter: [
      "all",
      [
        "==",
        "$type",
        "Point"
      ],
      [
        ">=",
        "rank",
        20
      ],
      [
        "any",
        [
          "all",
          [
            "in",
            "class",
            "pitch"
          ],
          [
            "in",
            "subclass",
            "soccer",
            "tennis",
            "baseball",
            "basketball",
            "swimming",
            "golf"
          ]
        ]
      ],
      [
        "any",
        [
          "!has",
          "level"
        ],
        [
          "==",
          "level",
          0
        ]
      ]
    ],
    layout: {
      "text-anchor": "top",
      "text-field": "{name_en}",
      "text-font": [
        "Open Sans Italic"
      ],
      "text-max-width": 9,
      "text-offset": [
        0,
        0.6
      ],
      "text-padding": 2,
      "text-size": 12,
      visibility: "none"
    },
    paint: {
      "text-color": "#666",
      "text-halo-blur": 0.5,
      "text-halo-color": "#ffffff",
      "text-halo-width": 1
    }
  },
  {
    id: "poi_z16",
    type: "symbol",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "poi",
    minzoom: 16,
    filter: [
      "all",
      [
        "==",
        "$type",
        "Point"
      ],
      [
        ">=",
        "rank",
        20
      ],
      [
        "none",
        [
          "all",
          [
            "in",
            "class",
            "pitch"
          ],
          [
            "in",
            "subclass",
            "soccer",
            "tennis",
            "baseball",
            "basketball",
            "swimming",
            "golf"
          ]
        ]
      ],
      [
        "any",
        [
          "!has",
          "level"
        ],
        [
          "==",
          "level",
          0
        ]
      ]
    ],
    layout: {
      "text-anchor": "top",
      "text-field": "{name_en}",
      "text-font": [
        "Open Sans Italic"
      ],
      "text-max-width": 9,
      "text-offset": [
        0,
        0.6
      ],
      "text-padding": 2,
      "text-size": 12,
      visibility: "none"
    },
    paint: {
      "text-color": "rgb(216, 220, 223)",
      "text-halo-blur": 0.5,
      "text-halo-color": "rgb(255, 255, 255)",
      "text-halo-width": 1
    }
  },
  {
    id: "poi_z15",
    type: "symbol",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "poi",
    minzoom: 15,
    filter: [
      "all",
      [
        "==",
        "$type",
        "Point"
      ],
      [
        ">=",
        "rank",
        7
      ],
      [
        "<",
        "rank",
        20
      ],
      [
        "any",
        [
          "!has",
          "level"
        ],
        [
          "==",
          "level",
          0
        ]
      ]
    ],
    layout: {
      "text-anchor": "top",
      "text-field": "{name_en}",
      "text-font": [
        "Open Sans Italic"
      ],
      "text-max-width": 9,
      "text-offset": [
        0,
        0.6
      ],
      "text-padding": 2,
      "text-size": 12,
      visibility: "none"
    },
    paint: {
      "text-color": "rgb(216, 220, 223)",
      "text-halo-blur": 0.5,
      "text-halo-color": "rgb(255, 255, 255)",
      "text-halo-width": 1
    }
  },
  {
    id: "poi_z14",
    type: "symbol",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "poi",
    minzoom: 14.2,
    filter: [
      "all",
      [
        "==",
        "$type",
        "Point"
      ],
      [
        "any",
        [
          "<",
          "rank",
          7
        ]
      ],
      [
        "any",
        [
          "!has",
          "level"
        ],
        [
          "==",
          "level",
          0
        ]
      ]
    ],
    layout: {
      "icon-size": 0.9,
      "text-anchor": "top",
      "text-field": "{name_en}",
      "text-font": [
        "Open Sans Italic"
      ],
      "text-max-width": 9,
      "text-offset": [
        0,
        0.6
      ],
      "text-padding": 2,
      "text-size": 12,
      visibility: "none"
    },
    paint: {
      "text-color": "rgb(216, 220, 223)",
      "text-halo-blur": 0.5,
      "text-halo-color": "rgb(255, 255, 255)",
      "text-halo-width": 1
    }
  },
  {
    id: "poi_transit",
    type: "symbol",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "poi",
    minzoom: 15,
    filter: [
      "all",
      [
        "in",
        "class",
        "bus",
        "railway",
        "airport"
      ],
      [
        "==",
        "subclass",
        "station"
      ]
    ],
    layout: {
      "icon-size": 0.9,
      "text-anchor": "left",
      "text-field": "{name_en}",
      "text-font": [
        "Open Sans Italic"
      ],
      "text-max-width": 9,
      "text-offset": [
        0.9,
        0
      ],
      "text-padding": 2,
      "text-size": 12,
      visibility: "visible"
    },
    paint: {
      "text-color": "rgb(216, 220, 223)",
      "text-halo-blur": 0.5,
      "text-halo-color": "rgb(255, 255, 255)",
      "text-halo-width": 1
    }
  },
  {
    id: "road_oneway",
    type: "symbol",
    source: "openmaptiles",
    "source-layer": "transportation",
    minzoom: 15,
    filter: [
      "all",
      [
        "==",
        "oneway",
        1
      ],
      [
        "in",
        "class",
        "motorway",
        "trunk",
        "primary",
        "secondary",
        "tertiary",
        "minor",
        "service"
      ]
    ],
    layout: {
      "icon-padding": 2,
      "icon-rotate": 90,
      "icon-rotation-alignment": "map",
      "icon-size": {
        stops: [
          [
            15,
            0.5
          ],
          [
            19,
            1
          ]
        ]
      },
      "symbol-placement": "line",
      "symbol-spacing": 75
    },
    paint: {
      "icon-opacity": 0.5
    }
  },
  {
    id: "road_oneway_opposite",
    type: "symbol",
    source: "openmaptiles",
    "source-layer": "transportation",
    minzoom: 15,
    filter: [
      "all",
      [
        "==",
        "oneway",
        -1
      ],
      [
        "in",
        "class",
        "motorway",
        "trunk",
        "primary",
        "secondary",
        "tertiary",
        "minor",
        "service"
      ]
    ],
    layout: {
      "icon-padding": 2,
      "icon-rotate": -90,
      "icon-rotation-alignment": "map",
      "icon-size": {
        stops: [
          [
            15,
            0.5
          ],
          [
            19,
            1
          ]
        ]
      },
      "symbol-placement": "line",
      "symbol-spacing": 75
    },
    paint: {
      "icon-opacity": 0.5
    }
  },
  {
    id: "road_label",
    type: "symbol",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "transportation_name",
    filter: [
      "all"
    ],
    layout: {
      "symbol-placement": "line",
      "text-anchor": "center",
      "text-field": "{name_en} ",
      "text-font": [
        "Open Sans Regular"
      ],
      "text-offset": [
        0,
        0.15
      ],
      "text-size": {
        base: 1,
        stops: [
          [
            13,
            12
          ],
          [
            14,
            13
          ]
        ]
      }
    },
    paint: {
      "text-color": "rgba(161, 169, 176, 1)",
      "text-halo-blur": 0.5,
      "text-halo-width": 1
    }
  },
  {
    id: "highway-shield",
    type: "symbol",
    source: "openmaptiles",
    "source-layer": "transportation_name",
    minzoom: 8,
    filter: [
      "all",
      [
        "<=",
        "ref_length",
        6
      ],
      [
        "==",
        "$type",
        "LineString"
      ],
      [
        "!in",
        "network",
        "us-interstate",
        "us-highway",
        "us-state"
      ]
    ],
    layout: {
      "icon-rotation-alignment": "viewport",
      "icon-size": 1,
      "symbol-avoid-edges": true,
      "symbol-placement": {
        base: 1,
        stops: [
          [
            10,
            "point"
          ],
          [
            11,
            "line"
          ]
        ]
      },
      "symbol-spacing": 200,
      "text-field": "{ref}",
      "text-font": [
        "Open Sans Regular"
      ],
      "text-rotation-alignment": "viewport",
      "text-size": 10,
      visibility: "none"
    },
    paint: {
      "icon-color": "rgba(161, 169, 176, 1)",
      "text-color": "rgba(161, 169, 176, 1)"
    }
  },
  {
    id: "highway-shield-us-interstate",
    type: "symbol",
    source: "openmaptiles",
    "source-layer": "transportation_name",
    minzoom: 7,
    filter: [
      "all",
      [
        "<=",
        "ref_length",
        6
      ],
      [
        "==",
        "$type",
        "LineString"
      ],
      [
        "in",
        "network",
        "us-interstate"
      ]
    ],
    layout: {
      "icon-rotation-alignment": "viewport",
      "icon-size": 1,
      "symbol-avoid-edges": true,
      "symbol-placement": {
        base: 1,
        stops: [
          [
            7,
            "point"
          ],
          [
            7,
            "line"
          ],
          [
            8,
            "line"
          ]
        ]
      },
      "symbol-spacing": 200,
      "text-field": "{ref}",
      "text-font": [
        "Open Sans Regular"
      ],
      "text-rotation-alignment": "viewport",
      "text-size": 9,
      visibility: "none"
    },
    paint: {
      "text-color": "rgb(255, 255, 255)"
    }
  },
  {
    id: "highway-shield-us-other",
    type: "symbol",
    source: "openmaptiles",
    "source-layer": "transportation_name",
    minzoom: 9,
    filter: [
      "all",
      [
        "<=",
        "ref_length",
        6
      ],
      [
        "==",
        "$type",
        "LineString"
      ],
      [
        "in",
        "network",
        "us-highway",
        "us-state"
      ]
    ],
    layout: {
      "icon-rotation-alignment": "viewport",
      "icon-size": 1,
      "symbol-avoid-edges": true,
      "symbol-placement": {
        base: 1,
        stops: [
          [
            10,
            "point"
          ],
          [
            11,
            "line"
          ]
        ]
      },
      "symbol-spacing": 200,
      "text-field": "{ref}",
      "text-font": [
        "Open Sans Regular"
      ],
      "text-rotation-alignment": "viewport",
      "text-size": 9,
      visibility: "none"
    },
    paint: {
      "text-color": "rgb(57, 57, 57)"
    }
  },
  {
    id: "place_other",
    type: "symbol",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "place",
    filter: [
      "all",
      [
        "in",
        "class",
        "hamlet",
        "island",
        "islet",
        "neighbourhood",
        "suburb"
      ]
    ],
    layout: {
      "text-field": "{name_en}",
      "text-font": [
        "Open Sans Italic"
      ],
      "text-letter-spacing": 0.1,
      "text-max-width": 9,
      "text-size": {
        base: 1.2,
        stops: [
          [
            12,
            10
          ],
          [
            15,
            14
          ]
        ]
      },
      "text-transform": "uppercase",
      visibility: "visible"
    },
    paint: {
      "text-color": "rgb(173, 182, 190)",
      "text-halo-color": "rgba(255, 255, 255, 0.6)",
      "text-halo-width": 1.2
    }
  },
  {
    id: "place_village",
    type: "symbol",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "place",
    filter: [
      "all",
      [
        "==",
        "class",
        "village"
      ]
    ],
    layout: {
      "text-field": "{name_en}",
      "text-font": [
        "Open Sans Regular"
      ],
      "text-max-width": 8,
      "text-size": {
        base: 1.2,
        stops: [
          [
            10,
            12
          ],
          [
            15,
            22
          ]
        ]
      },
      visibility: "none"
    },
    paint: {
      "text-color": "rgb(161, 169, 176)",
      "text-halo-color": "rgba(255, 255, 255, 0.6)",
      "text-halo-width": 1.2
    }
  },
  {
    id: "place_town",
    type: "symbol",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "place",
    filter: [
      "all",
      [
        "==",
        "class",
        "town"
      ]
    ],
    layout: {
      "text-anchor": "bottom",
      "text-field": "{name_en}",
      "text-font": [
        "Open Sans Regular"
      ],
      "text-max-width": 8,
      "text-offset": [
        0,
        0
      ],
      "text-size": {
        base: 1.2,
        stops: [
          [
            7,
            12
          ],
          [
            11,
            16
          ]
        ]
      }
    },
    paint: {
      "text-color": "rgba(161, 169, 176, 0.8)",
      "text-halo-color": "rgba(255, 255, 255, 0.6)",
      "text-halo-width": 1.2
    }
  },
  {
    id: "place_city",
    type: "symbol",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "place",
    minzoom: 5,
    filter: [
      "all",
      [
        "==",
        "class",
        "city"
      ]
    ],
    layout: {
      "icon-allow-overlap": true,
      "icon-optional": false,
      "text-anchor": "bottom",
      "text-field": "{name_en}",
      "text-font": [
        "Open Sans Semibold"
      ],
      "text-max-width": 8,
      "text-offset": [
        0,
        0
      ],
      "text-size": {
        base: 1.2,
        stops: [
          [
            7,
            14
          ],
          [
            11,
            24
          ]
        ]
      }
    },
    paint: {
      "text-color": "rgba(161, 169, 176, 0.8)",
      "text-halo-color": "rgba(255, 255, 255, 0.6)",
      "text-halo-width": 1.2
    }
  },
  {
    id: "country_other",
    type: "symbol",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "place",
    filter: [
      "all",
      [
        "==",
        "class",
        "country"
      ],
      [
        "!has",
        "iso_a2"
      ]
    ],
    layout: {
      "text-field": "{name_en}",
      "text-font": [
        "Open Sans Italic"
      ],
      "text-max-width": 6.25,
      "text-size": {
        stops: [
          [
            3,
            9
          ],
          [
            7,
            15
          ]
        ]
      },
      "text-transform": "none"
    },
    paint: {
      "text-color": "rgba(159, 178, 195, 0.55)",
      "text-halo-blur": 1,
      "text-halo-color": "rgba(255, 255, 255, 0.6)",
      "text-halo-width": 0.8
    }
  },
  {
    id: "country_3",
    type: "symbol",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "place",
    minzoom: 2,
    filter: [
      "all",
      [
        ">=",
        "rank",
        3
      ],
      [
        "==",
        "class",
        "country"
      ]
    ],
    layout: {
      "text-field": "{name_en}",
      "text-font": [
        "Open Sans Italic"
      ],
      "text-max-width": 6.25,
      "text-size": {
        stops: [
          [
            3,
            11
          ],
          [
            7,
            17
          ]
        ]
      },
      "text-transform": "none",
      visibility: "visible"
    },
    paint: {
      "text-color": "rgba(159, 178, 195, 0.55)",
      "text-halo-blur": 1,
      "text-halo-color": "rgba(255, 255, 255, 0.6)",
      "text-halo-width": 0.8
    }
  },
  {
    id: "country_2",
    type: "symbol",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "place",
    minzoom: 2,
    filter: [
      "all",
      [
        "==",
        "rank",
        2
      ],
      [
        "==",
        "class",
        "country"
      ]
    ],
    layout: {
      "text-field": "{name_en}",
      "text-font": [
        "Open Sans Italic"
      ],
      "text-max-width": 6.25,
      "text-size": {
        stops: [
          [
            2,
            11
          ],
          [
            5,
            17
          ]
        ]
      },
      "text-transform": "none",
      visibility: "visible"
    },
    paint: {
      "text-color": "rgba(159, 178, 195, 0.55)",
      "text-halo-blur": 1,
      "text-halo-color": "rgba(255, 255, 255, 0.6)",
      "text-halo-width": 0.8
    }
  },
  {
    id: "country_1",
    type: "symbol",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "place",
    minzoom: 2,
    filter: [
      "all",
      [
        "==",
        "rank",
        1
      ],
      [
        "==",
        "class",
        "country"
      ]
    ],
    layout: {
      "text-field": "{name_en}",
      "text-font": [
        "Open Sans Italic"
      ],
      "text-max-width": 6.25,
      "text-size": {
        stops: [
          [
            1,
            11
          ],
          [
            4,
            17
          ]
        ]
      },
      "text-transform": "none",
      visibility: "visible"
    },
    paint: {
      "text-color": "rgba(159, 178, 195, 0.55)",
      "text-halo-blur": 1,
      "text-halo-color": "rgba(255, 255, 255, 0.6)",
      "text-halo-width": 0.8
    }
  },
  {
    id: "continent",
    type: "symbol",
    metadata: {},
    source: "openmaptiles",
    "source-layer": "place",
    maxzoom: 1,
    filter: [
      "all",
      [
        "==",
        "class",
        "continent"
      ]
    ],
    layout: {
      "text-field": "{name_en}",
      "text-font": [
        "Open Sans Italic"
      ],
      "text-justify": "center",
      "text-size": 13,
      "text-transform": "uppercase"
    },
    paint: {
      "text-color": "rgb(168, 196, 220)",
      "text-halo-color": "rgba(255, 255, 255, 0.6)",
      "text-halo-width": 1
    }
  }
];
var version = 8;
var mapLibreBaseSettings = {
  bearing,
  name,
  owner,
  glyphs,
  sources,
  layers,
  version
};

// node_modules/@unovis/ts/components/leaflet-map/renderer/mapboxgl/mapboxgl-dark-theme.json.js
var layers2 = [
  {
    id: "background",
    layout: {
      visibility: "visible"
    },
    paint: {
      "background-color": "#5C627A"
    },
    type: "background"
  },
  {
    filter: [
      "all",
      [
        "!=",
        "intermittent",
        1
      ]
    ],
    id: "water",
    layout: {
      visibility: "visible"
    },
    metadata: {},
    paint: {
      "fill-color": "#2A2D39"
    },
    source: "openmaptiles",
    "source-layer": "water",
    type: "fill"
  }
];
var mapLibreDarkTheme = {
  layers: layers2
};

// node_modules/@unovis/ts/components/leaflet-map/renderer/mapboxgl/mapboxgl-light-theme.json.js
var layers3 = [
  {
    id: "background",
    layout: {
      visibility: "visible"
    },
    paint: {
      "background-color": "rgba(255, 255, 255, 1)"
    },
    type: "background"
  },
  {
    filter: [
      "all",
      [
        "!=",
        "intermittent",
        1
      ]
    ],
    id: "water",
    layout: {
      visibility: "visible"
    },
    metadata: {},
    paint: {
      "fill-color": "rgb(223, 229, 235)"
    },
    source: "openmaptiles",
    "source-layer": "water",
    type: "fill"
  }
];
var mapLibreLightTheme = {
  layers: layers3
};

// node_modules/@unovis/ts/components/leaflet-map/renderer/map-style.js
var MapLibreArcticDark = Object.assign(Object.assign({}, mapLibreBaseSettings), { layers: [
  ...mapLibreDarkTheme.layers,
  ...mapLibreBaseSettings.layers
] });
var MapLibreArcticLight = Object.assign(Object.assign({}, mapLibreBaseSettings), { layers: [
  ...mapLibreLightTheme.layers,
  ...mapLibreBaseSettings.layers
] });

// node_modules/@unovis/ts/components/graph/types.js
var GraphLayoutType;
(function(GraphLayoutType2) {
  GraphLayoutType2["Circular"] = "circular";
  GraphLayoutType2["Concentric"] = "concentric";
  GraphLayoutType2["Parallel"] = "parallel";
  GraphLayoutType2["ParallelHorizontal"] = "parallel horizontal";
  GraphLayoutType2["Dagre"] = "dagre";
  GraphLayoutType2["Force"] = "force";
  GraphLayoutType2["Elk"] = "elk";
  GraphLayoutType2["Precalculated"] = "precalculated";
})(GraphLayoutType || (GraphLayoutType = {}));
var GraphLinkStyle;
(function(GraphLinkStyle2) {
  GraphLinkStyle2["Dashed"] = "dashed";
  GraphLinkStyle2["Solid"] = "solid";
})(GraphLinkStyle || (GraphLinkStyle = {}));
var GraphLinkArrowStyle;
(function(GraphLinkArrowStyle2) {
  GraphLinkArrowStyle2["Single"] = "single";
  GraphLinkArrowStyle2["Double"] = "double";
})(GraphLinkArrowStyle || (GraphLinkArrowStyle = {}));
var GraphNodeShape;
(function(GraphNodeShape2) {
  GraphNodeShape2["Circle"] = "circle";
  GraphNodeShape2["Square"] = "square";
  GraphNodeShape2["Hexagon"] = "hexagon";
  GraphNodeShape2["Triangle"] = "triangle";
})(GraphNodeShape || (GraphNodeShape = {}));
var GraphNodeSelectionHighlightMode;
(function(GraphNodeSelectionHighlightMode2) {
  GraphNodeSelectionHighlightMode2["None"] = "none";
  GraphNodeSelectionHighlightMode2["Greyout"] = "greyout";
  GraphNodeSelectionHighlightMode2["GreyoutNonConnected"] = "greyout-non-connected";
})(GraphNodeSelectionHighlightMode || (GraphNodeSelectionHighlightMode = {}));
var GraphFitViewAlignment;
(function(GraphFitViewAlignment2) {
  GraphFitViewAlignment2["Center"] = "center";
  GraphFitViewAlignment2["Top"] = "top";
  GraphFitViewAlignment2["Bottom"] = "bottom";
  GraphFitViewAlignment2["Left"] = "left";
  GraphFitViewAlignment2["Right"] = "right";
})(GraphFitViewAlignment || (GraphFitViewAlignment = {}));

// node_modules/d3-sankey/node_modules/d3-array/src/ascending.js
function ascending_default2(a7, b25) {
  return a7 < b25 ? -1 : a7 > b25 ? 1 : a7 >= b25 ? 0 : NaN;
}

// node_modules/d3-sankey/node_modules/d3-array/src/bisector.js
function bisector_default(f29) {
  let delta = f29;
  let compare = f29;
  if (f29.length === 1) {
    delta = (d18, x21) => f29(d18) - x21;
    compare = ascendingComparator(f29);
  }
  function left3(a7, x21, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a7.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a7[mid], x21) < 0) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }
  function right3(a7, x21, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a7.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a7[mid], x21) > 0) hi = mid;
      else lo = mid + 1;
    }
    return lo;
  }
  function center3(a7, x21, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a7.length;
    const i8 = left3(a7, x21, lo, hi - 1);
    return i8 > lo && delta(a7[i8 - 1], x21) > -delta(a7[i8], x21) ? i8 - 1 : i8;
  }
  return { left: left3, center: center3, right: right3 };
}
function ascendingComparator(f29) {
  return (d18, x21) => ascending_default2(f29(d18), x21);
}

// node_modules/d3-sankey/node_modules/d3-array/src/number.js
function number_default2(x21) {
  return x21 === null ? NaN : +x21;
}

// node_modules/d3-sankey/node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector_default(ascending_default2);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector_default(number_default2).center;

// node_modules/d3-sankey/node_modules/d3-array/src/array.js
var array2 = Array.prototype;
var slice2 = array2.slice;
var map2 = array2.map;

// node_modules/d3-sankey/node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);

// node_modules/d3-sankey/node_modules/d3-array/src/max.js
function max5(values, valueof) {
  let max8;
  if (valueof === void 0) {
    for (const value2 of values) {
      if (value2 != null && (max8 < value2 || max8 === void 0 && value2 >= value2)) {
        max8 = value2;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index3, values)) != null && (max8 < value2 || max8 === void 0 && value2 >= value2)) {
        max8 = value2;
      }
    }
  }
  return max8;
}

// node_modules/d3-sankey/node_modules/d3-array/src/min.js
function min5(values, valueof) {
  let min7;
  if (valueof === void 0) {
    for (const value2 of values) {
      if (value2 != null && (min7 > value2 || min7 === void 0 && value2 >= value2)) {
        min7 = value2;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index3, values)) != null && (min7 > value2 || min7 === void 0 && value2 >= value2)) {
        min7 = value2;
      }
    }
  }
  return min7;
}

// node_modules/d3-sankey/node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random) {
  return function shuffle2(array3, i0 = 0, i1 = array3.length) {
    let m30 = i1 - (i0 = +i0);
    while (m30) {
      const i8 = random() * m30-- | 0, t4 = array3[m30 + i0];
      array3[m30 + i0] = array3[i8 + i0];
      array3[i8 + i0] = t4;
    }
    return array3;
  };
}

// node_modules/d3-sankey/node_modules/d3-array/src/sum.js
function sum3(values, valueof) {
  let sum5 = 0;
  if (valueof === void 0) {
    for (let value2 of values) {
      if (value2 = +value2) {
        sum5 += value2;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values) {
      if (value2 = +valueof(value2, ++index3, values)) {
        sum5 += value2;
      }
    }
  }
  return sum5;
}

// node_modules/d3-sankey/src/align.js
function targetDepth(d18) {
  return d18.target.depth;
}
function left2(node4) {
  return node4.depth;
}
function right2(node4, n) {
  return n - 1 - node4.height;
}
function justify(node4, n) {
  return node4.sourceLinks.length ? node4.depth : n - 1;
}
function center2(node4) {
  return node4.targetLinks.length ? node4.depth : node4.sourceLinks.length ? min5(node4.sourceLinks, targetDepth) - 1 : 0;
}

// node_modules/d3-sankey/src/constant.js
function constant(x21) {
  return function() {
    return x21;
  };
}

// node_modules/d3-sankey/src/sankey.js
function ascendingSourceBreadth(a7, b25) {
  return ascendingBreadth(a7.source, b25.source) || a7.index - b25.index;
}
function ascendingTargetBreadth(a7, b25) {
  return ascendingBreadth(a7.target, b25.target) || a7.index - b25.index;
}
function ascendingBreadth(a7, b25) {
  return a7.y0 - b25.y0;
}
function value(d18) {
  return d18.value;
}
function defaultId(d18) {
  return d18.index;
}
function defaultNodes(graph) {
  return graph.nodes;
}
function defaultLinks(graph) {
  return graph.links;
}
function find2(nodeById, id2) {
  const node4 = nodeById.get(id2);
  if (!node4) throw new Error("missing: " + id2);
  return node4;
}
function computeLinkBreadths({ nodes: nodes4 }) {
  for (const node4 of nodes4) {
    let y06 = node4.y0;
    let y110 = y06;
    for (const link7 of node4.sourceLinks) {
      link7.y0 = y06 + link7.width / 2;
      y06 += link7.width;
    }
    for (const link7 of node4.targetLinks) {
      link7.y1 = y110 + link7.width / 2;
      y110 += link7.width;
    }
  }
}
function Sankey() {
  let x06 = 0, y06 = 0, x110 = 1, y110 = 1;
  let dx = 24;
  let dy = 8, py;
  let id2 = defaultId;
  let align = justify;
  let sort2;
  let linkSort;
  let nodes4 = defaultNodes;
  let links5 = defaultLinks;
  let iterations2 = 6;
  function sankey() {
    const graph = { nodes: nodes4.apply(null, arguments), links: links5.apply(null, arguments) };
    computeNodeLinks(graph);
    computeNodeValues(graph);
    computeNodeDepths(graph);
    computeNodeHeights(graph);
    computeNodeBreadths(graph);
    computeLinkBreadths(graph);
    return graph;
  }
  sankey.update = function(graph) {
    computeLinkBreadths(graph);
    return graph;
  };
  sankey.nodeId = function(_17) {
    return arguments.length ? (id2 = typeof _17 === "function" ? _17 : constant(_17), sankey) : id2;
  };
  sankey.nodeAlign = function(_17) {
    return arguments.length ? (align = typeof _17 === "function" ? _17 : constant(_17), sankey) : align;
  };
  sankey.nodeSort = function(_17) {
    return arguments.length ? (sort2 = _17, sankey) : sort2;
  };
  sankey.nodeWidth = function(_17) {
    return arguments.length ? (dx = +_17, sankey) : dx;
  };
  sankey.nodePadding = function(_17) {
    return arguments.length ? (dy = py = +_17, sankey) : dy;
  };
  sankey.nodes = function(_17) {
    return arguments.length ? (nodes4 = typeof _17 === "function" ? _17 : constant(_17), sankey) : nodes4;
  };
  sankey.links = function(_17) {
    return arguments.length ? (links5 = typeof _17 === "function" ? _17 : constant(_17), sankey) : links5;
  };
  sankey.linkSort = function(_17) {
    return arguments.length ? (linkSort = _17, sankey) : linkSort;
  };
  sankey.size = function(_17) {
    return arguments.length ? (x06 = y06 = 0, x110 = +_17[0], y110 = +_17[1], sankey) : [x110 - x06, y110 - y06];
  };
  sankey.extent = function(_17) {
    return arguments.length ? (x06 = +_17[0][0], x110 = +_17[1][0], y06 = +_17[0][1], y110 = +_17[1][1], sankey) : [[x06, y06], [x110, y110]];
  };
  sankey.iterations = function(_17) {
    return arguments.length ? (iterations2 = +_17, sankey) : iterations2;
  };
  function computeNodeLinks({ nodes: nodes5, links: links6 }) {
    for (const [i8, node4] of nodes5.entries()) {
      node4.index = i8;
      node4.sourceLinks = [];
      node4.targetLinks = [];
    }
    const nodeById = new Map(nodes5.map((d18, i8) => [id2(d18, i8, nodes5), d18]));
    for (const [i8, link7] of links6.entries()) {
      link7.index = i8;
      let { source, target } = link7;
      if (typeof source !== "object") source = link7.source = find2(nodeById, source);
      if (typeof target !== "object") target = link7.target = find2(nodeById, target);
      source.sourceLinks.push(link7);
      target.targetLinks.push(link7);
    }
    if (linkSort != null) {
      for (const { sourceLinks, targetLinks } of nodes5) {
        sourceLinks.sort(linkSort);
        targetLinks.sort(linkSort);
      }
    }
  }
  function computeNodeValues({ nodes: nodes5 }) {
    for (const node4 of nodes5) {
      node4.value = node4.fixedValue === void 0 ? Math.max(sum3(node4.sourceLinks, value), sum3(node4.targetLinks, value)) : node4.fixedValue;
    }
  }
  function computeNodeDepths({ nodes: nodes5 }) {
    const n = nodes5.length;
    let current = new Set(nodes5);
    let next = /* @__PURE__ */ new Set();
    let x21 = 0;
    while (current.size) {
      for (const node4 of current) {
        node4.depth = x21;
        for (const { target } of node4.sourceLinks) {
          next.add(target);
        }
      }
      if (++x21 > n) throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeHeights({ nodes: nodes5 }) {
    const n = nodes5.length;
    let current = new Set(nodes5);
    let next = /* @__PURE__ */ new Set();
    let x21 = 0;
    while (current.size) {
      for (const node4 of current) {
        node4.height = x21;
        for (const { source } of node4.targetLinks) {
          next.add(source);
        }
      }
      if (++x21 > n) throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeLayers({ nodes: nodes5 }) {
    const x21 = max5(nodes5, (d18) => d18.depth) + 1;
    const kx4 = (x110 - x06 - dx) / (x21 - 1);
    const columns = new Array(x21);
    for (const node4 of nodes5) {
      const i8 = Math.max(0, Math.min(x21 - 1, Math.floor(align.call(null, node4, x21))));
      node4.layer = i8;
      node4.x0 = x06 + i8 * kx4;
      node4.x1 = node4.x0 + dx;
      if (columns[i8]) columns[i8].push(node4);
      else columns[i8] = [node4];
    }
    if (sort2) for (const column of columns) {
      column.sort(sort2);
    }
    return columns;
  }
  function initializeNodeBreadths(columns) {
    const ky3 = min5(columns, (c6) => (y110 - y06 - (c6.length - 1) * py) / sum3(c6, value));
    for (const nodes5 of columns) {
      let y25 = y06;
      for (const node4 of nodes5) {
        node4.y0 = y25;
        node4.y1 = y25 + node4.value * ky3;
        y25 = node4.y1 + py;
        for (const link7 of node4.sourceLinks) {
          link7.width = link7.value * ky3;
        }
      }
      y25 = (y110 - y25 + py) / (nodes5.length + 1);
      for (let i8 = 0; i8 < nodes5.length; ++i8) {
        const node4 = nodes5[i8];
        node4.y0 += y25 * (i8 + 1);
        node4.y1 += y25 * (i8 + 1);
      }
      reorderLinks(nodes5);
    }
  }
  function computeNodeBreadths(graph) {
    const columns = computeNodeLayers(graph);
    py = Math.min(dy, (y110 - y06) / (max5(columns, (c6) => c6.length) - 1));
    initializeNodeBreadths(columns);
    for (let i8 = 0; i8 < iterations2; ++i8) {
      const alpha = Math.pow(0.99, i8);
      const beta = Math.max(1 - alpha, (i8 + 1) / iterations2);
      relaxRightToLeft(columns, alpha, beta);
      relaxLeftToRight(columns, alpha, beta);
    }
  }
  function relaxLeftToRight(columns, alpha, beta) {
    for (let i8 = 1, n = columns.length; i8 < n; ++i8) {
      const column = columns[i8];
      for (const target of column) {
        let y25 = 0;
        let w14 = 0;
        for (const { source, value: value2 } of target.targetLinks) {
          let v28 = value2 * (target.layer - source.layer);
          y25 += targetTop(source, target) * v28;
          w14 += v28;
        }
        if (!(w14 > 0)) continue;
        let dy2 = (y25 / w14 - target.y0) * alpha;
        target.y0 += dy2;
        target.y1 += dy2;
        reorderNodeLinks(target);
      }
      if (sort2 === void 0) column.sort(ascendingBreadth);
      resolveCollisions(column, beta);
    }
  }
  function relaxRightToLeft(columns, alpha, beta) {
    for (let n = columns.length, i8 = n - 2; i8 >= 0; --i8) {
      const column = columns[i8];
      for (const source of column) {
        let y25 = 0;
        let w14 = 0;
        for (const { target, value: value2 } of source.sourceLinks) {
          let v28 = value2 * (target.layer - source.layer);
          y25 += sourceTop(source, target) * v28;
          w14 += v28;
        }
        if (!(w14 > 0)) continue;
        let dy2 = (y25 / w14 - source.y0) * alpha;
        source.y0 += dy2;
        source.y1 += dy2;
        reorderNodeLinks(source);
      }
      if (sort2 === void 0) column.sort(ascendingBreadth);
      resolveCollisions(column, beta);
    }
  }
  function resolveCollisions(nodes5, alpha) {
    const i8 = nodes5.length >> 1;
    const subject = nodes5[i8];
    resolveCollisionsBottomToTop(nodes5, subject.y0 - py, i8 - 1, alpha);
    resolveCollisionsTopToBottom(nodes5, subject.y1 + py, i8 + 1, alpha);
    resolveCollisionsBottomToTop(nodes5, y110, nodes5.length - 1, alpha);
    resolveCollisionsTopToBottom(nodes5, y06, 0, alpha);
  }
  function resolveCollisionsTopToBottom(nodes5, y25, i8, alpha) {
    for (; i8 < nodes5.length; ++i8) {
      const node4 = nodes5[i8];
      const dy2 = (y25 - node4.y0) * alpha;
      if (dy2 > 1e-6) node4.y0 += dy2, node4.y1 += dy2;
      y25 = node4.y1 + py;
    }
  }
  function resolveCollisionsBottomToTop(nodes5, y25, i8, alpha) {
    for (; i8 >= 0; --i8) {
      const node4 = nodes5[i8];
      const dy2 = (node4.y1 - y25) * alpha;
      if (dy2 > 1e-6) node4.y0 -= dy2, node4.y1 -= dy2;
      y25 = node4.y0 - py;
    }
  }
  function reorderNodeLinks({ sourceLinks, targetLinks }) {
    if (linkSort === void 0) {
      for (const { source: { sourceLinks: sourceLinks2 } } of targetLinks) {
        sourceLinks2.sort(ascendingTargetBreadth);
      }
      for (const { target: { targetLinks: targetLinks2 } } of sourceLinks) {
        targetLinks2.sort(ascendingSourceBreadth);
      }
    }
  }
  function reorderLinks(nodes5) {
    if (linkSort === void 0) {
      for (const { sourceLinks, targetLinks } of nodes5) {
        sourceLinks.sort(ascendingTargetBreadth);
        targetLinks.sort(ascendingSourceBreadth);
      }
    }
  }
  function targetTop(source, target) {
    let y25 = source.y0 - (source.sourceLinks.length - 1) * py / 2;
    for (const { target: node4, width } of source.sourceLinks) {
      if (node4 === target) break;
      y25 += width + py;
    }
    for (const { source: node4, width } of target.targetLinks) {
      if (node4 === source) break;
      y25 -= width;
    }
    return y25;
  }
  function sourceTop(source, target) {
    let y25 = target.y0 - (target.targetLinks.length - 1) * py / 2;
    for (const { source: node4, width } of target.targetLinks) {
      if (node4 === source) break;
      y25 += width + py;
    }
    for (const { target: node4, width } of source.sourceLinks) {
      if (node4 === target) break;
      y25 -= width;
    }
    return y25;
  }
  return sankey;
}

// node_modules/d3-sankey/node_modules/d3-path/src/path.js
var pi6 = Math.PI;
var tau6 = 2 * pi6;
var epsilon8 = 1e-6;
var tauEpsilon2 = tau6 - epsilon8;
function Path2() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null;
  this._ = "";
}
function path2() {
  return new Path2();
}
Path2.prototype = path2.prototype = {
  constructor: Path2,
  moveTo: function(x21, y25) {
    this._ += "M" + (this._x0 = this._x1 = +x21) + "," + (this._y0 = this._y1 = +y25);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x21, y25) {
    this._ += "L" + (this._x1 = +x21) + "," + (this._y1 = +y25);
  },
  quadraticCurveTo: function(x110, y110, x21, y25) {
    this._ += "Q" + +x110 + "," + +y110 + "," + (this._x1 = +x21) + "," + (this._y1 = +y25);
  },
  bezierCurveTo: function(x110, y110, x22, y25, x21, y26) {
    this._ += "C" + +x110 + "," + +y110 + "," + +x22 + "," + +y25 + "," + (this._x1 = +x21) + "," + (this._y1 = +y26);
  },
  arcTo: function(x110, y110, x22, y25, r4) {
    x110 = +x110, y110 = +y110, x22 = +x22, y25 = +y25, r4 = +r4;
    var x06 = this._x1, y06 = this._y1, x21 = x22 - x110, y212 = y25 - y110, x01 = x06 - x110, y01 = y06 - y110, l01_2 = x01 * x01 + y01 * y01;
    if (r4 < 0) throw new Error("negative radius: " + r4);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x110) + "," + (this._y1 = y110);
    } else if (!(l01_2 > epsilon8)) ;
    else if (!(Math.abs(y01 * x21 - y212 * x01) > epsilon8) || !r4) {
      this._ += "L" + (this._x1 = x110) + "," + (this._y1 = y110);
    } else {
      var x202 = x22 - x06, y202 = y25 - y06, l21_2 = x21 * x21 + y212 * y212, l20_2 = x202 * x202 + y202 * y202, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l7 = r4 * Math.tan((pi6 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l7 / l01, t21 = l7 / l21;
      if (Math.abs(t01 - 1) > epsilon8) {
        this._ += "L" + (x110 + t01 * x01) + "," + (y110 + t01 * y01);
      }
      this._ += "A" + r4 + "," + r4 + ",0,0," + +(y01 * x202 > x01 * y202) + "," + (this._x1 = x110 + t21 * x21) + "," + (this._y1 = y110 + t21 * y212);
    }
  },
  arc: function(x21, y25, r4, a0, a1, ccw) {
    x21 = +x21, y25 = +y25, r4 = +r4, ccw = !!ccw;
    var dx = r4 * Math.cos(a0), dy = r4 * Math.sin(a0), x06 = x21 + dx, y06 = y25 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (r4 < 0) throw new Error("negative radius: " + r4);
    if (this._x1 === null) {
      this._ += "M" + x06 + "," + y06;
    } else if (Math.abs(this._x1 - x06) > epsilon8 || Math.abs(this._y1 - y06) > epsilon8) {
      this._ += "L" + x06 + "," + y06;
    }
    if (!r4) return;
    if (da < 0) da = da % tau6 + tau6;
    if (da > tauEpsilon2) {
      this._ += "A" + r4 + "," + r4 + ",0,1," + cw + "," + (x21 - dx) + "," + (y25 - dy) + "A" + r4 + "," + r4 + ",0,1," + cw + "," + (this._x1 = x06) + "," + (this._y1 = y06);
    } else if (da > epsilon8) {
      this._ += "A" + r4 + "," + r4 + ",0," + +(da >= pi6) + "," + cw + "," + (this._x1 = x21 + r4 * Math.cos(a1)) + "," + (this._y1 = y25 + r4 * Math.sin(a1));
    }
  },
  rect: function(x21, y25, w14, h17) {
    this._ += "M" + (this._x0 = this._x1 = +x21) + "," + (this._y0 = this._y1 = +y25) + "h" + +w14 + "v" + +h17 + "h" + -w14 + "Z";
  },
  toString: function() {
    return this._;
  }
};

// node_modules/d3-sankey/node_modules/d3-shape/src/math.js
var epsilon9 = 1e-12;
var pi7 = Math.PI;
var halfPi5 = pi7 / 2;
var tau7 = 2 * pi7;

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/linear.js
function Linear2(context) {
  this._context = context;
}
Linear2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x21, y25) : this._context.moveTo(x21, y25);
        break;
      case 1:
        this._point = 2;
      // proceed
      default:
        this._context.lineTo(x21, y25);
        break;
    }
  }
};
function linear_default2(context) {
  return new Linear2(context);
}

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear2 = curveRadial2(linear_default2);
function Radial2(curve) {
  this._curve = curve;
}
Radial2.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a7, r4) {
    this._curve.point(r4 * Math.sin(a7), r4 * -Math.cos(a7));
  }
};
function curveRadial2(curve) {
  function radial2(context) {
    return new Radial2(curve(context));
  }
  radial2._curve = curve;
  return radial2;
}

// node_modules/d3-sankey/node_modules/d3-shape/src/array.js
var slice3 = Array.prototype.slice;

// node_modules/d3-sankey/node_modules/d3-shape/src/symbol/diamond.js
var tan302 = Math.sqrt(1 / 3);
var tan30_22 = tan302 * 2;

// node_modules/d3-sankey/node_modules/d3-shape/src/symbol/star.js
var kr2 = Math.sin(pi7 / 10) / Math.sin(7 * pi7 / 10);
var kx3 = Math.sin(tau7 / 10) * kr2;
var ky2 = -Math.cos(tau7 / 10) * kr2;

// node_modules/d3-sankey/node_modules/d3-shape/src/symbol/triangle.js
var sqrt35 = Math.sqrt(3);

// node_modules/d3-sankey/node_modules/d3-shape/src/symbol/wye.js
var s2 = Math.sqrt(3) / 2;
var k3 = 1 / Math.sqrt(12);
var a2 = (k3 / 2 + 1) * 3;

// node_modules/d3-sankey/node_modules/d3-shape/src/noop.js
function noop_default3() {
}

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/basis.js
function point7(that, x21, y25) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x21) / 6,
    (that._y0 + 4 * that._y1 + y25) / 6
  );
}
function Basis2(context) {
  this._context = context;
}
Basis2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point7(this, this._x1, this._y1);
      // proceed
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x21, y25) : this._context.moveTo(x21, y25);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // proceed
      default:
        point7(this, x21, y25);
        break;
    }
    this._x0 = this._x1, this._x1 = x21;
    this._y0 = this._y1, this._y1 = y25;
  }
};

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed2(context) {
  this._context = context;
}
BasisClosed2.prototype = {
  areaStart: noop_default3,
  areaEnd: noop_default3,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x21, this._y2 = y25;
        break;
      case 1:
        this._point = 2;
        this._x3 = x21, this._y3 = y25;
        break;
      case 2:
        this._point = 3;
        this._x4 = x21, this._y4 = y25;
        this._context.moveTo((this._x0 + 4 * this._x1 + x21) / 6, (this._y0 + 4 * this._y1 + y25) / 6);
        break;
      default:
        point7(this, x21, y25);
        break;
    }
    this._x0 = this._x1, this._x1 = x21;
    this._y0 = this._y1, this._y1 = y25;
  }
};

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen2(context) {
  this._context = context;
}
BasisOpen2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x06 = (this._x0 + 4 * this._x1 + x21) / 6, y06 = (this._y0 + 4 * this._y1 + y25) / 6;
        this._line ? this._context.lineTo(x06, y06) : this._context.moveTo(x06, y06);
        break;
      case 3:
        this._point = 4;
      // proceed
      default:
        point7(this, x21, y25);
        break;
    }
    this._x0 = this._x1, this._x1 = x21;
    this._y0 = this._y1, this._y1 = y25;
  }
};

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/bundle.js
function Bundle2(context, beta) {
  this._basis = new Basis2(context);
  this._beta = beta;
}
Bundle2.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x21 = this._x, y25 = this._y, j6 = x21.length - 1;
    if (j6 > 0) {
      var x06 = x21[0], y06 = y25[0], dx = x21[j6] - x06, dy = y25[j6] - y06, i8 = -1, t4;
      while (++i8 <= j6) {
        t4 = i8 / j6;
        this._basis.point(
          this._beta * x21[i8] + (1 - this._beta) * (x06 + t4 * dx),
          this._beta * y25[i8] + (1 - this._beta) * (y06 + t4 * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x21, y25) {
    this._x.push(+x21);
    this._y.push(+y25);
  }
};
var bundle_default2 = (function custom17(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis2(context) : new Bundle2(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom17(+beta2);
  };
  return bundle;
})(0.85);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/cardinal.js
function point8(that, x21, y25) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x21),
    that._y2 + that._k * (that._y1 - y25),
    that._x2,
    that._y2
  );
}
function Cardinal2(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point8(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x21, y25) : this._context.moveTo(x21, y25);
        break;
      case 1:
        this._point = 2;
        this._x1 = x21, this._y1 = y25;
        break;
      case 2:
        this._point = 3;
      // proceed
      default:
        point8(this, x21, y25);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x21;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y25;
  }
};
var cardinal_default2 = (function custom18(tension) {
  function cardinal(context) {
    return new Cardinal2(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom18(+tension2);
  };
  return cardinal;
})(0);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed2(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed2.prototype = {
  areaStart: noop_default3,
  areaEnd: noop_default3,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x21, this._y3 = y25;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x21, this._y4 = y25);
        break;
      case 2:
        this._point = 3;
        this._x5 = x21, this._y5 = y25;
        break;
      default:
        point8(this, x21, y25);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x21;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y25;
  }
};
var cardinalClosed_default2 = (function custom19(tension) {
  function cardinal(context) {
    return new CardinalClosed2(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom19(+tension2);
  };
  return cardinal;
})(0);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen2(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // proceed
      default:
        point8(this, x21, y25);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x21;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y25;
  }
};
var cardinalOpen_default2 = (function custom20(tension) {
  function cardinal(context) {
    return new CardinalOpen2(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom20(+tension2);
  };
  return cardinal;
})(0);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/catmullRom.js
function point9(that, x21, y25) {
  var x110 = that._x1, y110 = that._y1, x22 = that._x2, y26 = that._y2;
  if (that._l01_a > epsilon9) {
    var a7 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x110 = (x110 * a7 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y110 = (y110 * a7 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon9) {
    var b25 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m30 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b25 + that._x1 * that._l23_2a - x21 * that._l12_2a) / m30;
    y26 = (y26 * b25 + that._y1 * that._l23_2a - y25 * that._l12_2a) / m30;
  }
  that._context.bezierCurveTo(x110, y110, x22, y26, that._x2, that._y2);
}
function CatmullRom2(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    if (this._point) {
      var x23 = this._x2 - x21, y232 = this._y2 - y25;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y232 * y232, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x21, y25) : this._context.moveTo(x21, y25);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      // proceed
      default:
        point9(this, x21, y25);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x21;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y25;
  }
};
var catmullRom_default2 = (function custom21(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom2(context, alpha) : new Cardinal2(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom21(+alpha2);
  };
  return catmullRom;
})(0.5);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed2(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed2.prototype = {
  areaStart: noop_default3,
  areaEnd: noop_default3,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    if (this._point) {
      var x23 = this._x2 - x21, y232 = this._y2 - y25;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y232 * y232, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x21, this._y3 = y25;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x21, this._y4 = y25);
        break;
      case 2:
        this._point = 3;
        this._x5 = x21, this._y5 = y25;
        break;
      default:
        point9(this, x21, y25);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x21;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y25;
  }
};
var catmullRomClosed_default2 = (function custom22(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed2(context, alpha) : new CardinalClosed2(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom22(+alpha2);
  };
  return catmullRom;
})(0.5);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen2(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    if (this._point) {
      var x23 = this._x2 - x21, y232 = this._y2 - y25;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y232 * y232, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // proceed
      default:
        point9(this, x21, y25);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x21;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y25;
  }
};
var catmullRomOpen_default2 = (function custom23(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen2(context, alpha) : new CardinalOpen2(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom23(+alpha2);
  };
  return catmullRom;
})(0.5);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed2(context) {
  this._context = context;
}
LinearClosed2.prototype = {
  areaStart: noop_default3,
  areaEnd: noop_default3,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    if (this._point) this._context.lineTo(x21, y25);
    else this._point = 1, this._context.moveTo(x21, y25);
  }
};

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/monotone.js
function sign4(x21) {
  return x21 < 0 ? -1 : 1;
}
function slope32(that, x22, y25) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y25 - that._y1) / (h1 || h0 < 0 && -0), p13 = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign4(s0) + sign4(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p13)) || 0;
}
function slope22(that, t4) {
  var h17 = that._x1 - that._x0;
  return h17 ? (3 * (that._y1 - that._y0) / h17 - t4) / 2 : t4;
}
function point10(that, t03, t13) {
  var x06 = that._x0, y06 = that._y0, x110 = that._x1, y110 = that._y1, dx = (x110 - x06) / 3;
  that._context.bezierCurveTo(x06 + dx, y06 + dx * t03, x110 - dx, y110 - dx * t13, x110, y110);
}
function MonotoneX2(context) {
  this._context = context;
}
MonotoneX2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point10(this, this._t0, slope22(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x21, y25) {
    var t13 = NaN;
    x21 = +x21, y25 = +y25;
    if (x21 === this._x1 && y25 === this._y1) return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x21, y25) : this._context.moveTo(x21, y25);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point10(this, slope22(this, t13 = slope32(this, x21, y25)), t13);
        break;
      default:
        point10(this, this._t0, t13 = slope32(this, x21, y25));
        break;
    }
    this._x0 = this._x1, this._x1 = x21;
    this._y0 = this._y1, this._y1 = y25;
    this._t0 = t13;
  }
};
function MonotoneY2(context) {
  this._context = new ReflectContext2(context);
}
(MonotoneY2.prototype = Object.create(MonotoneX2.prototype)).point = function(x21, y25) {
  MonotoneX2.prototype.point.call(this, y25, x21);
};
function ReflectContext2(context) {
  this._context = context;
}
ReflectContext2.prototype = {
  moveTo: function(x21, y25) {
    this._context.moveTo(y25, x21);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x21, y25) {
    this._context.lineTo(y25, x21);
  },
  bezierCurveTo: function(x110, y110, x22, y25, x21, y26) {
    this._context.bezierCurveTo(y110, x110, y25, x22, y26, x21);
  }
};

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/natural.js
function Natural2(context) {
  this._context = context;
}
Natural2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x21 = this._x, y25 = this._y, n = x21.length;
    if (n) {
      this._line ? this._context.lineTo(x21[0], y25[0]) : this._context.moveTo(x21[0], y25[0]);
      if (n === 2) {
        this._context.lineTo(x21[1], y25[1]);
      } else {
        var px = controlPoints2(x21), py = controlPoints2(y25);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x21[i1], y25[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x21, y25) {
    this._x.push(+x21);
    this._y.push(+y25);
  }
};
function controlPoints2(x21) {
  var i8, n = x21.length - 1, m30, a7 = new Array(n), b25 = new Array(n), r4 = new Array(n);
  a7[0] = 0, b25[0] = 2, r4[0] = x21[0] + 2 * x21[1];
  for (i8 = 1; i8 < n - 1; ++i8) a7[i8] = 1, b25[i8] = 4, r4[i8] = 4 * x21[i8] + 2 * x21[i8 + 1];
  a7[n - 1] = 2, b25[n - 1] = 7, r4[n - 1] = 8 * x21[n - 1] + x21[n];
  for (i8 = 1; i8 < n; ++i8) m30 = a7[i8] / b25[i8 - 1], b25[i8] -= m30, r4[i8] -= m30 * r4[i8 - 1];
  a7[n - 1] = r4[n - 1] / b25[n - 1];
  for (i8 = n - 2; i8 >= 0; --i8) a7[i8] = (r4[i8] - a7[i8 + 1]) / b25[i8];
  b25[n - 1] = (x21[n] + a7[n - 1]) / 2;
  for (i8 = 0; i8 < n - 1; ++i8) b25[i8] = 2 * x21[i8 + 1] - a7[i8 + 1];
  return [a7, b25];
}

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/step.js
function Step2(context, t4) {
  this._context = context;
  this._t = t4;
}
Step2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x21, y25) {
    x21 = +x21, y25 = +y25;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x21, y25) : this._context.moveTo(x21, y25);
        break;
      case 1:
        this._point = 2;
      // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y25);
          this._context.lineTo(x21, y25);
        } else {
          var x110 = this._x * (1 - this._t) + x21 * this._t;
          this._context.lineTo(x110, this._y);
          this._context.lineTo(x110, y25);
        }
        break;
      }
    }
    this._x = x21, this._y = y25;
  }
};

// node_modules/@unovis/ts/components/sankey/types.js
var SankeySubLabelPlacement;
(function(SankeySubLabelPlacement2) {
  SankeySubLabelPlacement2["Inline"] = "inline";
  SankeySubLabelPlacement2["Below"] = "below";
})(SankeySubLabelPlacement || (SankeySubLabelPlacement = {}));
var SankeyNodeAlign;
(function(SankeyNodeAlign2) {
  SankeyNodeAlign2["Left"] = "left";
  SankeyNodeAlign2["Right"] = "right";
  SankeyNodeAlign2["Center"] = "center";
  SankeyNodeAlign2["Justify"] = "justify";
})(SankeyNodeAlign || (SankeyNodeAlign = {}));
var SankeyLayout = {
  [SankeyNodeAlign.Left]: left2,
  [SankeyNodeAlign.Right]: right2,
  [SankeyNodeAlign.Center]: center2,
  [SankeyNodeAlign.Justify]: justify
};
var SankeyExitTransitionType;
(function(SankeyExitTransitionType2) {
  SankeyExitTransitionType2["Default"] = "default";
  SankeyExitTransitionType2["ToAncestor"] = "to ancestor";
})(SankeyExitTransitionType || (SankeyExitTransitionType = {}));
var SankeyEnterTransitionType;
(function(SankeyEnterTransitionType2) {
  SankeyEnterTransitionType2["Default"] = "default";
  SankeyEnterTransitionType2["FromAncestor"] = "from ancestor";
})(SankeyEnterTransitionType || (SankeyEnterTransitionType = {}));

// node_modules/@unovis/ts/components/vis-controls/types.js
var VisControlsOrientation;
(function(VisControlsOrientation2) {
  VisControlsOrientation2["Horizontal"] = "horizontal";
  VisControlsOrientation2["Vertical"] = "vertical";
})(VisControlsOrientation || (VisControlsOrientation = {}));

// node_modules/@unovis/ts/components/free-brush/types.js
var FreeBrushMode;
(function(FreeBrushMode2) {
  FreeBrushMode2["X"] = "x";
  FreeBrushMode2["Y"] = "y";
  FreeBrushMode2["XY"] = "xy";
})(FreeBrushMode || (FreeBrushMode = {}));

// node_modules/@unovis/ts/components/xy-labels/types.js
var XYLabelPositioning;
(function(XYLabelPositioning2) {
  XYLabelPositioning2["AbsolutePx"] = "absolute_px";
  XYLabelPositioning2["AbsolutePercentage"] = "absolute_percentage";
  XYLabelPositioning2["DataSpace"] = "data_space";
})(XYLabelPositioning || (XYLabelPositioning = {}));

// node_modules/@unovis/ts/components/nested-donut/types.js
var NestedDonutDirection;
(function(NestedDonutDirection2) {
  NestedDonutDirection2["Inwards"] = "inwards";
  NestedDonutDirection2["Outwards"] = "outwards";
})(NestedDonutDirection || (NestedDonutDirection = {}));
var NestedDonutSegmentLabelAlignment;
(function(NestedDonutSegmentLabelAlignment2) {
  NestedDonutSegmentLabelAlignment2["Along"] = "along";
  NestedDonutSegmentLabelAlignment2["Perpendicular"] = "perpendicular";
  NestedDonutSegmentLabelAlignment2["Straight"] = "straight";
})(NestedDonutSegmentLabelAlignment || (NestedDonutSegmentLabelAlignment = {}));

// node_modules/@unovis/ts/components/plotline/types.js
var PlotlineLineStylePresets;
(function(PlotlineLineStylePresets2) {
  PlotlineLineStylePresets2["Solid"] = "solid";
  PlotlineLineStylePresets2["Dash"] = "dash";
  PlotlineLineStylePresets2["DashDot"] = "dashDot";
  PlotlineLineStylePresets2["Dot"] = "dot";
  PlotlineLineStylePresets2["LongDash"] = "longDash";
  PlotlineLineStylePresets2["LongDashDot"] = "longDashDot";
  PlotlineLineStylePresets2["LongDashDotDot"] = "longDashDotDot";
  PlotlineLineStylePresets2["ShortDash"] = "shortDash";
  PlotlineLineStylePresets2["ShortDashDot"] = "shortDashDot";
  PlotlineLineStylePresets2["ShortDashDotDot"] = "shortDashDotDot";
  PlotlineLineStylePresets2["ShortDot"] = "shortDot";
})(PlotlineLineStylePresets || (PlotlineLineStylePresets = {}));
var PlotlineLabelPosition;
(function(PlotlineLabelPosition2) {
  PlotlineLabelPosition2["TopLeft"] = "top-left";
  PlotlineLabelPosition2["Top"] = "top";
  PlotlineLabelPosition2["TopRight"] = "top-right";
  PlotlineLabelPosition2["Right"] = "right";
  PlotlineLabelPosition2["BottomRight"] = "bottom-right";
  PlotlineLabelPosition2["Bottom"] = "bottom";
  PlotlineLabelPosition2["BottomLeft"] = "bottom-left";
  PlotlineLabelPosition2["Left"] = "left";
})(PlotlineLabelPosition || (PlotlineLabelPosition = {}));
var PlotlineLabelOrientation;
(function(PlotlineLabelOrientation2) {
  PlotlineLabelOrientation2["Horizontal"] = "horizontal";
  PlotlineLabelOrientation2["Vertical"] = "vertical";
})(PlotlineLabelOrientation || (PlotlineLabelOrientation = {}));

// node_modules/@unovis/ts/components/plotband/types.js
var PlotbandLabelPosition;
(function(PlotbandLabelPosition2) {
  PlotbandLabelPosition2["TopLeftInside"] = "top-left-inside";
  PlotbandLabelPosition2["TopLeftOutside"] = "top-left-outside";
  PlotbandLabelPosition2["TopInside"] = "top-inside";
  PlotbandLabelPosition2["TopOutside"] = "top-outside";
  PlotbandLabelPosition2["TopRightInside"] = "top-right-inside";
  PlotbandLabelPosition2["TopRightOutside"] = "top-right-outside";
  PlotbandLabelPosition2["RightInside"] = "right-inside";
  PlotbandLabelPosition2["RightOutside"] = "right-outside";
  PlotbandLabelPosition2["BottomRightInside"] = "bottom-right-inside";
  PlotbandLabelPosition2["BottomRightOutside"] = "bottom-right-outside";
  PlotbandLabelPosition2["BottomInside"] = "bottom-inside";
  PlotbandLabelPosition2["BottomOutside"] = "bottom-outside";
  PlotbandLabelPosition2["BottomLeftInside"] = "bottom-left-inside";
  PlotbandLabelPosition2["BottomLeftOutside"] = "bottom-left-outside";
  PlotbandLabelPosition2["LeftInside"] = "left-inside";
  PlotbandLabelPosition2["LeftOutside"] = "left-outside";
})(PlotbandLabelPosition || (PlotbandLabelPosition = {}));
var PlotbandLabelOrientation;
(function(PlotbandLabelOrientation2) {
  PlotbandLabelOrientation2["Horizontal"] = "horizontal";
  PlotbandLabelOrientation2["Vertical"] = "vertical";
})(PlotbandLabelOrientation || (PlotbandLabelOrientation = {}));

// node_modules/@unovis/ts/components/timeline/config.js
var TimelineDefaultConfig = Object.assign(Object.assign({}, XYComponentDefaultConfig), {
  id: void 0,
  // Items (Lines)
  cursor: void 0,
  type: (d18) => d18.type,
  length: (d18) => d18.length,
  color: (d18) => d18.color,
  lineRow: void 0,
  lineDuration: void 0,
  lineWidth: 8,
  lineCap: false,
  lineCursor: void 0,
  showEmptySegments: false,
  lineStartIcon: void 0,
  lineStartIconColor: void 0,
  lineStartIconSize: void 0,
  lineStartIconArrangement: Arrangement.Inside,
  lineEndIcon: void 0,
  lineEndIconColor: void 0,
  lineEndIconSize: void 0,
  lineEndIconArrangement: Arrangement.Inside,
  // Rows
  rowHeight: 22,
  alternatingRowColors: true,
  // Row Labels
  showLabels: false,
  labelWidth: void 0,
  maxLabelWidth: 120,
  showRowLabels: void 0,
  rowLabelFormatter: void 0,
  rowIcon: void 0,
  rowLabelStyle: void 0,
  rowLabelWidth: void 0,
  rowMaxLabelWidth: void 0,
  rowLabelTextAlign: TextAlign.Right,
  // Arrows
  arrows: void 0,
  // Animation
  animationLineEnterPosition: void 0,
  // Callbacks
  onScroll: void 0
});

// node_modules/@unovis/ts/components/timeline/style.js
var style_exports11 = {};
__export(style_exports11, {
  arrow: () => arrow2,
  arrows: () => arrows,
  background: () => background,
  globalStyles: () => globalStyles7,
  label: () => label5,
  labels: () => labels2,
  line: () => line4,
  lineEndIcon: () => lineEndIcon,
  lineGroup: () => lineGroup,
  lineStartIcon: () => lineStartIcon,
  lines: () => lines2,
  root: () => root13,
  row: () => row,
  rowIcon: () => rowIcon,
  rowIcons: () => rowIcons,
  rowOdd: () => rowOdd,
  rows: () => rows,
  scrollbar: () => scrollbar,
  scrollbarBackground: () => scrollbarBackground,
  scrollbarHandle: () => scrollbarHandle
});
var root13 = css`
  label: timeline-component;
`;
var globalStyles7 = injectGlobal`
  :root {
    --vis-timeline-row-even-fill-color: #FFFFFF;
    --vis-timeline-row-odd-fill-color: #F7FAFC;
    --vis-timeline-row-background-opacity: 1;
    --vis-timeline-scrollbar-background-color: #E6E9F3;
    --vis-timeline-scrollbar-color: #9EA7B8;

    --vis-timeline-label-font-size: 12px;
    --vis-timeline-label-color: #6C778C;

    --vis-timeline-arrow-color: #6C778C;
    --vis-timeline-arrow-stroke-width: 1.5;

    --vis-timeline-cursor: default;
    --vis-timeline-line-color: var(--vis-color-main);
    --vis-timeline-line-stroke-width: 0;
    --vis-timeline-line-hover-stroke-width: 0;
    --vis-timeline-line-hover-stroke-color: #6C778C;

    // The line stroke color variable is not defined by default
    // to allow it to fallback to the corresponding row background color
    /* --vis-timeline-line-stroke-color: none; */

    --vis-dark-timeline-row-even-fill-color: #292B34;
    --vis-dark-timeline-row-odd-fill-color: #333742;
    --vis-dark-timeline-scrollbar-background-color: #292B34;
    --vis-dark-timeline-scrollbar-color: #6C778C;
    --vis-dark-timeline-label-color: #EFF5F8;
    --vis-dark-timeline-arrow-color: #EFF5F8;
    --vis-dark-timeline-line-hover-stroke-color: #EFF5F8;
  }

  body.theme-dark ${`.${root13}`} {
    --vis-timeline-row-even-fill-color: var(--vis-dark-timeline-row-even-fill-color);
    --vis-timeline-row-odd-fill-color: var(--vis-dark-timeline-row-odd-fill-color);
    --vis-timeline-scrollbar-background-color: var(--vis-dark-timeline-scrollbar-background-color);
    --vis-timeline-scrollbar-color: var(--vis-dark-timeline-scrollbar-color);
    --vis-timeline-label-color: var(--vis-dark-timeline-label-color);
    --vis-timeline-arrow-color: var(--vis-dark-timeline-arrow-color);
    --vis-timeline-line-hover-stroke-color: var(--vis-dark-timeline-line-hover-stroke-color);
  }
`;
var background = css`
  label: background;
`;
var lines2 = css`
  label: lines;
`;
var lineGroup = css`
  label: line-group;
`;
var line4 = css`
  label: line;
  fill: var(--vis-timeline-line-color);
  cursor: var(--vis-timeline-cursor);

  stroke: var(--vis-timeline-line-stroke-color, var(--vis-timeline-row-even-fill-color));
  stroke-width: var(--vis-timeline-line-stroke-width);

  &.odd {
    stroke: var(--vis-timeline-line-stroke-color, var(--vis-timeline-row-odd-fill-color));
  }

  :hover {
    stroke-width: var(--vis-timeline-line-hover-stroke-width);
    stroke: var(--vis-timeline-line-hover-stroke-color);
  }
`;
var lineStartIcon = css`
  label: line-start-icon;
`;
var lineEndIcon = css`
  label: line-end-icon;
`;
var arrows = css`
  label: arrows;
`;
var arrow2 = css`
  label: arrow;
  fill: none;
  stroke: var(--vis-timeline-arrow-color);
  stroke-width: var(--vis-timeline-arrow-stroke-width);
`;
var rows = css`
  label: rows;
`;
var row = css`
  label: row;
  fill: var(--vis-timeline-row-even-fill-color);
  opacity: var(--vis-timeline-row-background-opacity);
`;
var rowOdd = css`
  label: row-odd;
  fill: var(--vis-timeline-row-odd-fill-color);
`;
var scrollbar = css`
  label: scroll-bar;
`;
var scrollbarHandle = css`
  label: scroll-bar-handle;
  fill: var(--vis-timeline-scrollbar-color);
`;
var scrollbarBackground = css`
  label: scroll-bar-background;
  fill: var(--vis-timeline-scrollbar-background-color);
`;
var labels2 = css`
  label: labels;
`;
var label5 = css`
  label: label;
  dominant-baseline: middle;
  font-size: var(--vis-timeline-label-font-size);
  fill: var(--vis-timeline-label-color);
  text-anchor: end;
  user-select: none;
`;
var rowIcons = css`
  label: row-icons;
`;
var rowIcon = css`
  label: row-icon;
`;

// node_modules/@unovis/ts/components/timeline/constants.js
var TIMELINE_DEFAULT_ARROW_HEAD_LENGTH = 8;
var TIMELINE_DEFAULT_ARROW_HEAD_WIDTH = 6;
var TIMELINE_DEFAULT_ARROW_MARGIN = 3;

// node_modules/@unovis/ts/components/timeline/utils.js
var getIconBleed = (datum2, idx, icon, iconSize, iconArrangement, rowHeight) => {
  const iconValue = getString(datum2, icon, idx);
  if (!iconValue)
    return 0;
  const size2 = getNumber(datum2, iconSize, idx) || rowHeight / 2;
  const arrangement = getValue(datum2, iconArrangement, idx);
  return arrangement === Arrangement.Outside ? size2 : arrangement === Arrangement.Center ? size2 / 2 : 0;
};

// node_modules/@unovis/ts/components/timeline/index.js
var Timeline = class _Timeline extends XYComponentCore {
  constructor(config) {
    super();
    this._defaultConfig = TimelineDefaultConfig;
    this.config = this._defaultConfig;
    this.events = {
      [_Timeline.selectors.background]: {
        wheel: this._onMouseWheel.bind(this)
      },
      [_Timeline.selectors.label]: {
        wheel: this._onMouseWheel.bind(this)
      },
      [_Timeline.selectors.rows]: {
        wheel: this._onMouseWheel.bind(this)
      },
      [_Timeline.selectors.line]: {
        wheel: this._onMouseWheel.bind(this)
      }
    };
    this._scrollBarWidth = 5;
    this._scrollDistance = 0;
    this._scrollBarMargin = 5;
    this._maxScroll = 0;
    this._scrollbarHeight = 0;
    this._labelMargin = 5;
    this._labelWidth = 0;
    this._rowIconBleed = [0, 0];
    this._lineBleed = [0, 0];
    this._clipPathId = guid();
    if (config)
      this.setConfig(config);
    this._background = this.g.append("rect").attr("class", background);
    this._clipPath = this.g.append("clipPath").attr("id", this._clipPathId);
    this._clipPath.append("rect");
    this._rowsGroup = this.g.append("g").attr("class", rows).style("clip-path", `url(#${this._clipPathId})`);
    this._arrowsGroup = this.g.append("g").attr("class", arrows).style("clip-path", `url(#${this._clipPathId})`);
    this._linesGroup = this.g.append("g").attr("class", lines2).style("clip-path", `url(#${this._clipPathId})`);
    this._labelsGroup = this.g.append("g").attr("class", labels2);
    this._rowIconsGroup = this.g.append("g").attr("class", rowIcons);
    this._scrollBarGroup = this.g.append("g").attr("class", scrollbar);
    this._scrollBarBackground = this._scrollBarGroup.append("rect").attr("class", scrollbarBackground);
    this._scrollBarHandle = this._scrollBarGroup.append("rect").attr("class", scrollbarHandle);
    const dragBehaviour = drag_default().on("drag", this._onScrollbarDrag.bind(this));
    this._scrollBarHandle.call(dragBehaviour);
  }
  setConfig(config) {
    super.setConfig(config);
  }
  setData(data) {
    super.setData(data);
  }
  get bleed() {
    var _a, _b, _c, _d;
    const { config, datamodel: { data } } = this;
    const rowLabels = this._getRowLabels(data);
    const rowHeight = config.rowHeight || this._height / (rowLabels.length || 1);
    const hasIcons = rowLabels.some((l7) => l7.iconHref);
    const maxIconSize = max(rowLabels.map((l7) => l7.iconSize || 0));
    if ((_a = config.showRowLabels) !== null && _a !== void 0 ? _a : config.showLabels) {
      if ((_b = config.rowLabelWidth) !== null && _b !== void 0 ? _b : config.labelWidth)
        this._labelWidth = ((_c = config.rowLabelWidth) !== null && _c !== void 0 ? _c : config.labelWidth) + this._labelMargin;
      else {
        const longestLabel = rowLabels.reduce((longestLabel2, l7) => longestLabel2.formattedLabel.length > l7.formattedLabel.length ? longestLabel2 : l7, rowLabels[0]);
        const label$1 = this._labelsGroup.append("text").attr("class", label5).text((longestLabel === null || longestLabel === void 0 ? void 0 : longestLabel.formattedLabel) || "").call(trimSVGText, (_d = config.rowMaxLabelWidth) !== null && _d !== void 0 ? _d : config.maxLabelWidth);
        const labelWidth = label$1.node().getBBox().width;
        label$1.remove();
        const tolerance = 1.15;
        this._labelWidth = labelWidth ? tolerance * labelWidth + this._labelMargin : 0;
      }
    }
    const minTimestamp = min(data, (d18, i8) => getNumber(d18, config.x, i8));
    const dataMin = data.filter((d18, i8) => getNumber(d18, config.x, i8) === minTimestamp);
    const dataMinShortestItemIdx = minIndex(dataMin, (d18, i8) => this._getLineDuration(d18, i8));
    const firstItemIdx = data.findIndex((d18) => d18 === dataMin[dataMinShortestItemIdx]);
    const firstItem = data[firstItemIdx];
    const maxTimestamp = max(data, (d18, i8) => getNumber(d18, config.x, i8) + this._getLineDuration(d18, i8));
    const dataMax = data.filter((d18, i8) => getNumber(d18, config.x, i8) + this._getLineDuration(d18, i8) === maxTimestamp);
    const dataMaxShortestItemIdx = minIndex(dataMax, (d18, i8) => this._getLineDuration(d18, i8));
    const lastItemIdx = data.findIndex((d18) => d18 === dataMax[dataMaxShortestItemIdx]);
    const lastItem = data[lastItemIdx];
    const lineBleed = [1, 1];
    if (config.showEmptySegments && config.lineCap && firstItem && lastItem) {
      const firstItemStart = getNumber(firstItem, config.x, firstItemIdx);
      const firstItemEnd = getNumber(firstItem, config.x, firstItemIdx) + this._getLineDuration(firstItem, firstItemIdx);
      const lastItemStart = getNumber(lastItem, config.x, lastItemIdx);
      const lastItemEnd = getNumber(lastItem, config.x, lastItemIdx) + this._getLineDuration(lastItem, lastItemIdx);
      const fullTimeRange = lastItemEnd - firstItemStart;
      const firstItemHeight = this._getLineWidth(firstItem, firstItemIdx, rowHeight);
      const lastItemHeight = this._getLineWidth(lastItem, lastItemIdx, rowHeight);
      if ((firstItemEnd - firstItemStart) / fullTimeRange * this._width < firstItemHeight)
        lineBleed[0] = firstItemHeight / 2;
      if ((lastItemEnd - lastItemStart) / fullTimeRange * this._width < lastItemHeight)
        lineBleed[1] = lastItemHeight / 2;
    }
    this._lineBleed = lineBleed;
    const iconBleed = [0, 0];
    if (config.lineStartIcon) {
      iconBleed[0] = max(data, (d18, i8) => getIconBleed(d18, i8, config.lineStartIcon, config.lineStartIconSize, config.lineStartIconArrangement, rowHeight)) || 0;
    }
    if (config.lineEndIcon) {
      iconBleed[1] = max(data, (d18, i8) => getIconBleed(d18, i8, config.lineEndIcon, config.lineEndIconSize, config.lineEndIconArrangement, rowHeight)) || 0;
    }
    this._rowIconBleed = iconBleed;
    return {
      top: 0,
      bottom: 0,
      left: this._labelWidth + iconBleed[0] + (hasIcons ? maxIconSize : 0) + lineBleed[0],
      right: this._scrollBarWidth + this._scrollBarMargin + iconBleed[1] + lineBleed[1]
    };
  }
  _render(customDuration) {
    var _a;
    super._render(customDuration);
    const { config, datamodel: { data } } = this;
    const duration = isNumber(customDuration) ? customDuration : config.duration;
    const xRange = this.xScale.range();
    const yRange = this.yScale.range();
    const yStart = Math.min(...yRange);
    const yHeight = Math.abs(yRange[1] - yRange[0]);
    const rowLabels = this._getRowLabels(data);
    const numRowLabels = rowLabels.length;
    const rowHeight = config.rowHeight || yHeight / (numRowLabels || 1);
    const yOrdinalScale = ordinal().range(arrayOfIndices(numRowLabels)).domain(rowLabels.map((l7) => l7.label));
    const lineDataPrepared = this._prepareLinesData(data, yOrdinalScale, rowHeight);
    this._background.attr("width", this._width).attr("height", this._height).attr("opacity", 0);
    const rowIcons2 = this._rowIconsGroup.selectAll(`.${rowIcon}`).data(rowLabels.filter((d18) => d18.iconSize), (l7) => l7 === null || l7 === void 0 ? void 0 : l7.label);
    const rowIconsEnter = rowIcons2.enter().append("use").attr("class", rowIcon).attr("x", 0).attr("width", (l7) => l7.iconSize).attr("height", (l7) => l7.iconSize).attr("y", (l7) => yStart + (yOrdinalScale(l7.label) + 0.5) * rowHeight - l7.iconSize / 2).style("opacity", 0);
    smartTransition(rowIconsEnter.merge(rowIcons2), duration).attr("href", (l7) => l7.iconHref).attr("x", 0).attr("y", (l7) => yStart + (yOrdinalScale(l7.label) + 0.5) * rowHeight - l7.iconSize / 2).attr("width", (l7) => l7.iconSize).attr("height", (l7) => l7.iconSize).style("color", (l7) => l7.iconColor).style("opacity", 1);
    smartTransition(rowIcons2.exit(), duration).style("opacity", 0).remove();
    const labels4 = this._labelsGroup.selectAll(`.${label5}`).data(((_a = config.showRowLabels) !== null && _a !== void 0 ? _a : config.showLabels) ? rowLabels : [], (l7) => l7 === null || l7 === void 0 ? void 0 : l7.label);
    const labelOffset = config.rowLabelTextAlign === TextAlign.Center ? this._labelWidth / 2 : config.rowLabelTextAlign === TextAlign.Left ? this._labelWidth : this._labelMargin;
    const xStart = xRange[0] - this._rowIconBleed[0] - this._lineBleed[0];
    const labelXStart = xStart - labelOffset;
    const labelsEnter = labels4.enter().append("text").attr("class", label5).attr("x", labelXStart).attr("y", (l7) => yStart + (yOrdinalScale(l7.label) + 0.5) * rowHeight).style("opacity", 0);
    const labelsMerged = labelsEnter.merge(labels4).text((l7) => l7.formattedLabel).each((label14, i8, els) => {
      var _a2, _b;
      const labelSelection = select_default2(els[i8]);
      trimSVGText(labelSelection, ((_a2 = config.rowLabelWidth) !== null && _a2 !== void 0 ? _a2 : config.labelWidth) || ((_b = config.rowMaxLabelWidth) !== null && _b !== void 0 ? _b : config.maxLabelWidth));
      const customStyle = getValue(label14, config.rowLabelStyle);
      if (!isPlainObject(customStyle))
        return;
      for (const [prop, value2] of Object.entries(customStyle)) {
        labelSelection.style(prop, value2);
      }
    }).style("text-anchor", textAlignToAnchor(config.rowLabelTextAlign));
    smartTransition(labelsMerged, duration).attr("x", labelXStart).attr("y", (l7) => yStart + (yOrdinalScale(l7.label) + 0.5) * rowHeight).style("opacity", 1);
    smartTransition(labels4.exit(), duration).style("opacity", 0).remove();
    const timelineWidth = xRange[1] - xRange[0] + this._rowIconBleed[0] + this._rowIconBleed[1] + this._lineBleed[0] + this._lineBleed[1];
    const numRows = Math.max(Math.floor(yHeight / rowHeight), numRowLabels);
    const recordTypes = Array(numRows).fill(null).map((_17, i8) => rowLabels[i8]);
    const rects = this._rowsGroup.selectAll(`.${row}`).data(recordTypes);
    const rectsEnter = rects.enter().append("rect").attr("class", row).attr("x", xStart).attr("width", timelineWidth).attr("y", (_17, i8) => yStart + i8 * rowHeight).attr("height", rowHeight).style("opacity", 0);
    const rectsMerged = rectsEnter.merge(rects).classed(rowOdd, config.alternatingRowColors ? (_17, i8) => !(i8 % 2) : null);
    smartTransition(rectsMerged, duration).attr("x", xStart).attr("width", timelineWidth).attr("y", (_17, i8) => yStart + i8 * rowHeight).attr("height", rowHeight).style("opacity", 1);
    smartTransition(rects.exit(), duration).style("opacity", 0).remove();
    const lines3 = this._linesGroup.selectAll(`.${lineGroup}`).data(lineDataPrepared, (d18) => d18._id);
    const linesEnter = lines3.enter().append("g").attr("class", lineGroup).style("opacity", 0).attr("transform", (d18, i8) => {
      var _a2, _b;
      const configuredPos = isFunction(config.animationLineEnterPosition) ? config.animationLineEnterPosition(d18, i8, lineDataPrepared) : config.animationLineEnterPosition;
      const [x21, y25] = [(_a2 = configuredPos === null || configuredPos === void 0 ? void 0 : configuredPos[0]) !== null && _a2 !== void 0 ? _a2 : d18._xPx, (_b = configuredPos === null || configuredPos === void 0 ? void 0 : configuredPos[1]) !== null && _b !== void 0 ? _b : d18._yPx];
      return `translate(${x21}, ${y25})`;
    });
    linesEnter.append("rect").attr("class", line4).style("fill", (d18, i8) => getColor(d18, config.color, yOrdinalScale(this._getRecordKey(d18, i8)))).call(this._renderLines.bind(this), rowHeight);
    linesEnter.append("use").attr("class", lineStartIcon);
    linesEnter.append("use").attr("class", lineEndIcon);
    const linesMerged = linesEnter.merge(lines3);
    smartTransition(linesMerged, duration).attr("transform", (d18) => `translate(${d18._xPx + d18._xOffsetPx}, ${d18._yPx})`).style("opacity", 1);
    const lineRectElementsSelection = linesMerged.selectAll(`.${line4}`).data((d18) => [d18]);
    smartTransition(lineRectElementsSelection, duration).style("fill", (d18, i8) => getColor(d18, config.color, yOrdinalScale(this._getRecordKey(d18, i8)))).style("cursor", (d18, i8) => {
      var _a2;
      return getString(d18, (_a2 = config.lineCursor) !== null && _a2 !== void 0 ? _a2 : config.cursor, i8);
    }).call(this._renderLines.bind(this), rowHeight);
    linesMerged.selectAll(`.${lineStartIcon}`).data((d18) => [d18]).attr("href", (d18, i8) => getString(d18, config.lineStartIcon, i8)).attr("x", (d18, i8) => {
      const iconSize = d18._startIconSize;
      const iconArrangement = d18._startIconArrangement;
      const offset = iconArrangement === Arrangement.Inside ? 0 : iconArrangement === Arrangement.Center ? -iconSize / 2 : -iconSize;
      return offset;
    }).attr("y", (d18) => -(d18._startIconSize - d18._height) / 2 || 0).attr("width", (d18) => d18._startIconSize).attr("height", (d18) => d18._startIconSize).style("color", (d18) => d18._startIconColor);
    linesMerged.selectAll(`.${lineEndIcon}`).data((d18) => [d18]).attr("href", (d18, i8) => getString(d18, config.lineEndIcon, i8)).attr("x", (d18, i8) => {
      const lineLength = d18._lengthCorrected;
      const iconSize = d18._endIconSize;
      const iconArrangement = d18._endIconArrangement;
      const offset = iconArrangement === Arrangement.Inside ? -iconSize : iconArrangement === Arrangement.Center ? -iconSize / 2 : 0;
      return lineLength + offset;
    }).attr("y", (d18) => -((d18._endIconSize - d18._height) / 2) || 0).attr("width", (d18) => d18._endIconSize).attr("height", (d18) => d18._endIconSize).style("color", (d18) => d18._endIconColor);
    const linesExit = lines3.exit();
    smartTransition(linesExit, duration).style("opacity", 0).attr("transform", (d18, i8) => {
      var _a2, _b;
      const configuredPos = isFunction(config.animationLineExitPosition) ? config.animationLineExitPosition(d18, i8, lineDataPrepared) : config.animationLineExitPosition;
      const [x21, y25] = [(_a2 = configuredPos === null || configuredPos === void 0 ? void 0 : configuredPos[0]) !== null && _a2 !== void 0 ? _a2 : d18._xPx, (_b = configuredPos === null || configuredPos === void 0 ? void 0 : configuredPos[1]) !== null && _b !== void 0 ? _b : d18._yPx];
      return `translate(${x21}, ${y25})`;
    }).remove();
    const arrowsData = this._prepareArrowsData(data, yOrdinalScale, rowHeight);
    const arrows2 = this._arrowsGroup.selectAll(`.${arrow2}`).data(arrowsData !== null && arrowsData !== void 0 ? arrowsData : [], (d18) => d18.id);
    const arrowsEnter = arrows2.enter().append("path").attr("class", arrow2).style("opacity", 0);
    smartTransition(arrowsEnter.merge(arrows2), duration).attr("d", (d18) => {
      var _a2, _b;
      return arrowPolylinePath(d18._points, (_a2 = d18.arrowHeadLength) !== null && _a2 !== void 0 ? _a2 : TIMELINE_DEFAULT_ARROW_HEAD_LENGTH, (_b = d18.arrowHeadWidth) !== null && _b !== void 0 ? _b : TIMELINE_DEFAULT_ARROW_HEAD_WIDTH);
    }).style("opacity", 1);
    smartTransition(arrows2.exit(), duration).style("opacity", 0).remove();
    const absoluteContentHeight = recordTypes.length * rowHeight;
    this._scrollbarHeight = yHeight * yHeight / absoluteContentHeight || 0;
    this._maxScroll = Math.max(absoluteContentHeight - yHeight, 0);
    this._scrollBarGroup.attr("transform", `translate(${this._width - this._scrollBarWidth}, ${yStart})`).attr("opacity", this._maxScroll ? 1 : 0);
    this._scrollBarBackground.attr("width", this._scrollBarWidth).attr("height", this._height).attr("rx", this._scrollBarWidth / 2).attr("ry", this._scrollBarWidth / 2);
    this._scrollBarHandle.attr("width", this._scrollBarWidth).attr("height", this._scrollbarHeight).attr("rx", this._scrollBarWidth / 2).attr("ry", this._scrollBarWidth / 2);
    this._updateScrollPosition(0);
    const clipPathRect = this._clipPath.select("rect");
    smartTransition(clipPathRect, clipPathRect.attr("width") ? duration : 0).attr("x", xStart).attr("width", timelineWidth).attr("height", this._height);
  }
  _getLineLength(d18, i8) {
    var _a, _b;
    const { config, xScale } = this;
    const x21 = getNumber(d18, config.x, i8);
    const length = (_b = getNumber(d18, (_a = config.lineDuration) !== null && _a !== void 0 ? _a : config.length, i8)) !== null && _b !== void 0 ? _b : 0;
    const lineLength = xScale(x21 + length) - xScale(x21);
    return lineLength;
  }
  _getLineWidth(d18, i8, rowHeight) {
    var _a;
    const { config } = this;
    return (_a = getNumber(d18, config.lineWidth, i8)) !== null && _a !== void 0 ? _a : Math.max(Math.floor(rowHeight / 2), 1);
  }
  _getLineDuration(d18, i8) {
    var _a, _b;
    const { config } = this;
    return (_b = getNumber(d18, (_a = config.lineDuration) !== null && _a !== void 0 ? _a : config.length, i8)) !== null && _b !== void 0 ? _b : 0;
  }
  _prepareLinesData(data, rowOrdinalScale, rowHeight) {
    const { config, xScale, yScale } = this;
    const yRange = yScale.range();
    const yStart = Math.min(...yRange);
    return data.map((d18, i8) => {
      var _a, _b, _c, _d, _e;
      const id2 = (_a = getString(d18, config.id, i8)) !== null && _a !== void 0 ? _a : [
        this._getRecordKey(d18, i8),
        getNumber(d18, config.x, i8)
      ].join("-");
      const lineWidth = this._getLineWidth(d18, i8, rowHeight);
      const lineLength = this._getLineLength(d18, i8);
      if (lineLength < 0) {
        console.warn("Unovis | Timeline: Line segments should not have negative lengths. Setting to 0.");
      }
      const isLineTooShort = config.showEmptySegments && config.lineCap && lineLength < lineWidth;
      const lineLengthCorrected = config.showEmptySegments ? Math.max(config.lineCap ? lineWidth : 1, lineLength) : Math.max(0, lineLength);
      const x21 = xScale(getNumber(d18, config.x, i8));
      const y25 = yStart + rowOrdinalScale(this._getRecordKey(d18, i8)) * rowHeight + (rowHeight - lineWidth) / 2;
      const xOffset = isLineTooShort ? -(lineLengthCorrected - lineLength) / 2 : 0;
      return Object.assign(Object.assign({}, d18), { _id: id2, _xPx: x21, _yPx: y25, _xOffsetPx: xOffset, _length: lineLength, _height: lineWidth, _lengthCorrected: lineLengthCorrected, _startIconSize: (_b = getNumber(d18, config.lineStartIconSize, i8)) !== null && _b !== void 0 ? _b : lineWidth, _endIconSize: (_c = getNumber(d18, config.lineEndIconSize, i8)) !== null && _c !== void 0 ? _c : lineWidth, _startIconColor: getString(d18, config.lineStartIconColor, i8), _endIconColor: getString(d18, config.lineEndIconColor, i8), _startIconArrangement: (_d = getValue(d18, config.lineStartIconArrangement, i8)) !== null && _d !== void 0 ? _d : Arrangement.Outside, _endIconArrangement: (_e = getValue(d18, config.lineEndIconArrangement, i8)) !== null && _e !== void 0 ? _e : Arrangement.Outside });
    });
  }
  _prepareArrowsData(data, rowOrdinalScale, rowHeight) {
    var _a;
    const { config } = this;
    const arrowsData = (_a = config.arrows) === null || _a === void 0 ? void 0 : _a.map((a7) => {
      var _a2, _b, _c, _d, _e;
      const sourceLineIndex = data.findIndex((d18, i8) => getString(d18, config.id, i8) === a7.lineSourceId);
      const targetLineIndex = data.findIndex((d18, i8) => getString(d18, config.id, i8) === a7.lineTargetId);
      const sourceLine = data[sourceLineIndex];
      const targetLine = data[targetLineIndex];
      if (!sourceLine || !targetLine) {
        console.warn("Unovis | Timeline: Arrow references a non-existent line. Skipping...", a7);
        return void 0;
      }
      const sourceLineY = rowOrdinalScale(this._getRecordKey(sourceLine, sourceLineIndex)) * rowHeight + rowHeight / 2;
      const targetLineY = rowOrdinalScale(this._getRecordKey(targetLine, targetLineIndex)) * rowHeight + rowHeight / 2;
      const sourceLineWidth = this._getLineWidth(sourceLine, sourceLineIndex, rowHeight);
      const targetLineWidth = this._getLineWidth(targetLine, targetLineIndex, rowHeight);
      const x110 = (a7.xSource ? this.xScale(a7.xSource) : this.xScale(getNumber(sourceLine, config.x, sourceLineIndex)) + this._getLineLength(sourceLine, sourceLineIndex)) + ((_a2 = a7.xSourceOffsetPx) !== null && _a2 !== void 0 ? _a2 : 0);
      const targetLineLength = this._getLineLength(targetLine, targetLineIndex);
      const isTargetLineTooShort = config.showEmptySegments && config.lineCap && targetLineLength < targetLineWidth;
      const targetLineStart = this.xScale(getNumber(targetLine, config.x, targetLineIndex)) + (isTargetLineTooShort ? -targetLineWidth / 2 : 0);
      const x22 = (a7.xTarget ? this.xScale(a7.xTarget) : targetLineStart) + ((_b = a7.xTargetOffsetPx) !== null && _b !== void 0 ? _b : 0);
      const isX2OutsideTargetLineStart = x22 < targetLineStart || x22 > targetLineStart;
      const sourceMargin = (_c = a7.lineSourceMarginPx) !== null && _c !== void 0 ? _c : TIMELINE_DEFAULT_ARROW_MARGIN;
      const targetMargin = (_d = a7.lineTargetMarginPx) !== null && _d !== void 0 ? _d : TIMELINE_DEFAULT_ARROW_MARGIN;
      const y110 = sourceLineY < targetLineY ? sourceLineY + sourceLineWidth / 2 + sourceMargin : sourceLineY - sourceLineWidth / 2 - sourceMargin;
      const y25 = sourceLineY < targetLineY ? targetLineY - targetLineWidth / 2 - targetMargin : targetLineY + targetLineWidth / 2 + targetMargin;
      const arrowHeadLength = (_e = a7.arrowHeadLength) !== null && _e !== void 0 ? _e : TIMELINE_DEFAULT_ARROW_HEAD_LENGTH;
      const isForwardArrow = x110 < x22 && !isX2OutsideTargetLineStart;
      const threshold2 = arrowHeadLength + (isForwardArrow ? targetMargin : 0);
      const points3 = [[x110, y110]];
      if (Math.abs(x22 - x110) > threshold2) {
        if (isForwardArrow) {
          points3.push([x110, (y110 + targetLineY) / 2]);
          points3.push([x110, targetLineY]);
          points3.push([x22 - targetMargin, targetLineY]);
        } else {
          const verticalOffset = Math.sign(targetLineY - sourceLineY) * (rowHeight / 4);
          points3.push([x110, y25 - verticalOffset]);
          points3.push([x22, y25 - verticalOffset]);
          points3.push([x22, y25]);
        }
      } else {
        const quarterOffset = (y25 - y110) / 4;
        points3.push([x110, y110 + quarterOffset]);
        points3.push([x110, y110 + 3 * quarterOffset]);
        points3.push([x110, y25]);
      }
      return Object.assign(Object.assign({}, a7), { _points: points3 });
    }).filter(Boolean);
    return arrowsData;
  }
  _renderLines(selection2) {
    const { config } = this;
    selection2.attr("width", (d18) => d18._lengthCorrected).attr("height", (d18) => d18._height).attr("rx", (d18) => config.lineCap ? d18._height / 2 : null);
  }
  _onScrollbarDrag(event) {
    const yRange = this.yScale.range();
    const yHeight = Math.abs(yRange[1] - yRange[0]);
    this._updateScrollPosition(event.dy * this._maxScroll / (yHeight - this._scrollbarHeight));
  }
  _onMouseWheel(d18, event) {
    var _a;
    const { config } = this;
    this._updateScrollPosition(event === null || event === void 0 ? void 0 : event.deltaY);
    if (this._scrollDistance > 0 && this._scrollDistance < this._maxScroll)
      event === null || event === void 0 ? void 0 : event.preventDefault();
    (_a = config.onScroll) === null || _a === void 0 ? void 0 : _a.call(config, this._scrollDistance);
    const e3 = new Event("mousemove");
    this.element.dispatchEvent(e3);
  }
  _updateScrollPosition(diff) {
    const yRange = this.yScale.range();
    const yHeight = Math.abs(yRange[1] - yRange[0]);
    this._scrollDistance += diff;
    this._scrollDistance = Math.max(0, this._scrollDistance);
    this._scrollDistance = Math.min(this._maxScroll, this._scrollDistance);
    this._clipPath.attr("transform", `translate(0,${this._scrollDistance})`);
    this._linesGroup.attr("transform", `translate(0,${-this._scrollDistance})`);
    this._rowsGroup.attr("transform", `translate(0,${-this._scrollDistance})`);
    this._labelsGroup.attr("transform", `translate(0,${-this._scrollDistance})`);
    this._rowIconsGroup.attr("transform", `translate(0,${-this._scrollDistance})`);
    this._arrowsGroup.attr("transform", `translate(0,${-this._scrollDistance})`);
    const scrollBarPosition = this._scrollDistance / this._maxScroll * (yHeight - this._scrollbarHeight) || 0;
    this._scrollBarHandle.attr("y", scrollBarPosition);
  }
  _getRecordKey(d18, i8) {
    var _a;
    return getString(d18, (_a = this.config.lineRow) !== null && _a !== void 0 ? _a : this.config.type) || `__${i8}`;
  }
  _getRowLabels(data) {
    const grouped = groupBy(data, (d18, i8) => {
      var _a;
      return getString(d18, (_a = this.config.lineRow) !== null && _a !== void 0 ? _a : this.config.type) || `${i8 + 1}`;
    });
    const rowLabels = Object.entries(grouped).map(([key, items2], i8) => {
      var _a, _b, _c, _d, _e;
      const icon = (_b = (_a = this.config).rowIcon) === null || _b === void 0 ? void 0 : _b.call(_a, key, items2, i8);
      return {
        label: key,
        formattedLabel: (_e = (_d = (_c = this.config).rowLabelFormatter) === null || _d === void 0 ? void 0 : _d.call(_c, key, items2, i8)) !== null && _e !== void 0 ? _e : key,
        iconHref: icon === null || icon === void 0 ? void 0 : icon.href,
        iconSize: icon === null || icon === void 0 ? void 0 : icon.size,
        iconColor: icon === null || icon === void 0 ? void 0 : icon.color,
        data: items2
      };
    });
    return rowLabels;
  }
  // Override the default XYComponent getXDataExtent method to take into account line lengths
  getXDataExtent() {
    const { config, datamodel } = this;
    const min7 = getMin(datamodel.data, config.x);
    const max8 = getMax(datamodel.data, (d18, i8) => {
      var _a, _b;
      return getNumber(d18, config.x, i8) + ((_b = getNumber(d18, (_a = config.lineDuration) !== null && _a !== void 0 ? _a : config.length, i8)) !== null && _b !== void 0 ? _b : 0);
    });
    return [min7, max8];
  }
};
Timeline.selectors = style_exports11;

// node_modules/@unovis/ts/data-models/graph.js
var GraphDataModel = class extends CoreDataModel {
  constructor() {
    super(...arguments);
    this._nodes = [];
    this._links = [];
    this._inputNodesMap = /* @__PURE__ */ new Map();
    this._nodesMap = /* @__PURE__ */ new Map();
    this.nodeId = (n) => isString(n.id) || isFinite(n.id) ? `${n.id}` : void 0;
    this.linkId = (l7) => isString(l7.id) || isFinite(l7.id) ? `${l7.id}` : void 0;
  }
  getNodeById(id2) {
    return this._nodesMap.get(id2);
  }
  get data() {
    return this._data;
  }
  set data(inputData) {
    var _a, _b;
    if (!inputData)
      return;
    this._data = inputData;
    const prevNodes = this.nodes;
    const prevLinks = this.links;
    this._inputNodesMap.clear();
    this._nodesMap.clear();
    const nodes4 = cloneDeep((_a = inputData === null || inputData === void 0 ? void 0 : inputData.nodes) !== null && _a !== void 0 ? _a : []);
    const links5 = cloneDeep((_b = inputData === null || inputData === void 0 ? void 0 : inputData.links) !== null && _b !== void 0 ? _b : []);
    this.transferState(nodes4, prevNodes, this.nodeId);
    this.transferState(links5, prevLinks, this.linkId);
    nodes4.forEach((node4, i8) => {
      node4._index = i8;
      node4._id = this.nodeId(node4) || `${i8}`;
      this._inputNodesMap.set(node4, inputData.nodes[i8]);
      this._nodesMap.set(node4._id, node4);
    });
    if (isFunction(this.nodeSort))
      nodes4.sort(this.nodeSort);
    links5.forEach((link7, i8) => {
      link7._indexGlobal = i8;
      link7.source = this.findNode(nodes4, link7.source);
      link7.target = this.findNode(nodes4, link7.target);
    });
    links5.forEach((link7, i8) => {
      if (!isUndefined(link7._index) && !isUndefined(link7._neighbours))
        return;
      const linksFiltered = links5.filter((l7) => link7.source === l7.source && link7.target === l7.target || link7.source === l7.target && link7.target === l7.source);
      linksFiltered.forEach((l7, i9) => {
        var _a2, _b2;
        l7._index = i9;
        l7._id = this.linkId(l7) || `${(_a2 = l7.source) === null || _a2 === void 0 ? void 0 : _a2._id}-${(_b2 = l7.target) === null || _b2 === void 0 ? void 0 : _b2._id}-${i9}`;
        l7._neighbours = linksFiltered.length;
        l7._direction = link7.source === l7.source && link7.target === l7.target ? 1 : -1;
      });
    });
    nodes4.forEach((d18) => {
      d18.links = links5.filter((l7) => l7.source === d18 || l7.target === d18);
      d18._isConnected = d18.links.length !== 0;
    });
    this._nonConnectedNodes = nodes4.filter((d18) => !d18._isConnected);
    this._connectedNodes = without(nodes4, ...this._nonConnectedNodes);
    this._nodes = nodes4;
    this._links = links5.filter((l7) => {
      if (l7.source === l7.target) {
        console.warn(`Unovis | Graph Data Model: Skipping link ${l7._id} because it has the same source and target`);
        return false;
      }
      return l7.source && l7.target;
    });
  }
  get nodes() {
    return this._nodes;
  }
  get links() {
    return this._links;
  }
  get connectedNodes() {
    return this._connectedNodes;
  }
  get nonConnectedNodes() {
    return this._nonConnectedNodes;
  }
  findNode(nodes4, nodeIdentifier) {
    let foundNode;
    if (isNumber(nodeIdentifier))
      foundNode = nodes4[nodeIdentifier];
    else if (isString(nodeIdentifier))
      foundNode = nodes4.find((node4) => this.nodeId(node4) === nodeIdentifier);
    else if (isObject(nodeIdentifier))
      foundNode = nodes4.find((node4) => isEqual(this._inputNodesMap.get(node4), nodeIdentifier));
    if (!foundNode) {
      console.warn(`Unovis | Graph Data Model: Node ${nodeIdentifier} is missing from the nodes list`);
    }
    return foundNode;
  }
  transferState(items2, itemsPrev, getId) {
    for (const item4 of items2) {
      const dPrev = itemsPrev.find((dp) => getId(dp) === getId(item4));
      if (dPrev)
        item4._state = Object.assign({}, dPrev._state);
      else
        item4._state = {};
    }
  }
  setNodeStateById(id2, state) {
    const node4 = this.getNodeById(id2);
    if (!node4) {
      console.warn(`Unovis | Graph Data Model: Node ${id2} not found`);
      return;
    }
    node4._state = state;
  }
};

// node_modules/@unovis/ts/components/sankey/config.js
var SankeyDefaultConfig = Object.assign(Object.assign({}, ComponentDefaultConfig), {
  heightNormalizationCoeff: 1 / 16,
  exitTransitionType: SankeyExitTransitionType.Default,
  enterTransitionType: SankeyEnterTransitionType.Default,
  id: (d18, i8) => {
    var _a;
    return (_a = d18._id) !== null && _a !== void 0 ? _a : `${i8}`;
  },
  highlightSubtreeOnHover: false,
  highlightDuration: 300,
  highlightDelay: 1e3,
  iterations: 32,
  nodeSort: void 0,
  nodeWidth: 25,
  nodeAlign: SankeyNodeAlign.Justify,
  nodeHorizontalSpacing: 150,
  nodeMinHeight: 20,
  nodeMaxHeight: 100,
  nodePadding: 2,
  nodeColor: (d18) => d18.color,
  nodeFixedValue: (d18) => d18.fixedValue,
  showSingleNode: true,
  nodeCursor: void 0,
  nodeIcon: void 0,
  nodeIconColor: void 0,
  label: (d18) => d18.label,
  labelPosition: Position.Auto,
  labelVerticalAlign: VerticalAlign.Middle,
  labelBackground: false,
  labelTextSeparator: [" ", "-"],
  labelFit: FitMode.Trim,
  labelTrimMode: TrimMode.Middle,
  labelForceWordBreak: true,
  labelFontSize: void 0,
  labelCursor: void 0,
  labelColor: void 0,
  labelMaxWidth: 70,
  labelExpandTrimmedOnHover: true,
  labelVisibility: void 0,
  subLabel: void 0,
  subLabelFontSize: void 0,
  subLabelColor: void 0,
  subLabelPlacement: SankeySubLabelPlacement.Below,
  subLabelToLabelInlineWidthRatio: 0.4,
  linkValue: (d18) => d18.value,
  linkColor: (d18) => d18.color,
  linkCursor: void 0,
  // https://stackoverflow.com/a/21648197/2040291
  init: function() {
    this.linkSort = (link22, link1) => getNumber(link1, this.linkValue) - getNumber(link22, this.linkValue);
    delete this.init;
    return this;
  }
}).init();

// node_modules/@unovis/ts/components/sankey/style.js
var style_exports12 = {};
__export(style_exports12, {
  SANKEY_ICON_SIZE: () => SANKEY_ICON_SIZE,
  background: () => background2,
  forceShow: () => forceShow,
  hidden: () => hidden2,
  label: () => label6,
  labelBackground: () => labelBackground,
  labelGroup: () => labelGroup,
  labelTrimmed: () => labelTrimmed,
  link: () => link3,
  linkPath: () => linkPath,
  linkSelectionHelper: () => linkSelectionHelper,
  links: () => links,
  node: () => node,
  nodeExit: () => nodeExit,
  nodeGroup: () => nodeGroup,
  nodeIcon: () => nodeIcon,
  nodes: () => nodes,
  root: () => root14,
  sublabel: () => sublabel,
  variables: () => variables7
});
var SANKEY_ICON_SIZE = 22;
var root14 = css`
  label: sankey-component;
`;
var variables7 = injectGlobal`
  :root {
     /* Links */
    --vis-sankey-link-cursor: default;
    --vis-sankey-link-color: var(--vis-color-main-light);
    --vis-sankey-link-opacity: 0.5;
    --vis-sankey-link-hover-opacity: 1.0;
    /* Nodes */
    --vis-sankey-node-cursor: default;
    --vis-sankey-node-color: var(--vis-color-main);
    --vis-sankey-node-label-color: #575c65;
    --vis-sankey-node-opacity: 0.9;
    --vis-sankey-node-hover-opacity: 1.0;
    /* Node Labels */
    --vis-sankey-node-label-background-fill-color: #ffffff;
    --vis-sankey-node-label-background-stroke-color: #eaeaea;
    --vis-sankey-node-label-background-opacity: 0.9;
    --vis-sankey-node-label-color: #575c65;
    --vis-sankey-node-label-cursor: default;
    --vis-sankey-node-label-font-weight: 600;
    --vis-sankey-node-label-font-size: 12px;
    --vis-sankey-node-label-text-decoration: none;

    --vis-sankey-node-sublabel-font-size: 10px;
    --vis-sankey-node-sublabel-font-weight: 500;

    /* Icons */
    --vis-sankey-icon-size: ${SANKEY_ICON_SIZE}px;
    --vis-sankey-icon-color: #ffffff;
    --vis-sankey-icon-stroke-opacity: 0.6;
    --vis-sankey-icon-font-family: ${UNOVIS_ICON_FONT_FAMILY_DEFAULT};

    // Undefined by default to allow proper fallback to var(--vis-font-family)
    /* --vis-sankey-label-font-family: */

    /* Dark Theme */
    --vis-dark-sankey-link-color: var(--vis-color-main-dark);
    --vis-dark-sankey-node-color: var(--vis-color-main);
    --vis-dark-sankey-node-label-color: #eaeaea;
    --vis-dark-sankey-node-label-background-fill-color: #292b34;
    --vis-dark-sankey-node-label-background-stroke-color: #575c65;
    --vis-dark-sankey-icon-color: #292b34;
  }

  body.theme-dark ${`.${root14}`} {
    --vis-sankey-node-color: var(--vis-dark-sankey-node-color);
    --vis-sankey-link-color: var(--vis-dark-sankey-link-color);
    --vis-sankey-node-label-color: var(--vis-dark-sankey-node-label-color);
    --vis-sankey-node-label-background-fill-color: var(--vis-dark-sankey-label-background-fill-color);
    --vis-sankey-node-label-background-stroke-color: var(--vis-dark-sankey-label-background-stroke-color);
    --vis-sankey-icon-color: var(--vis-dark-sankey-icon-color);
  }
`;
var links = css`
  label: links;
`;
var nodes = css`
  label: nodes;
`;
var link3 = css`
  label: link;

  path {
    cursor: var(--vis-sankey-link-cursor);
    fill: var(--vis-sankey-link-color);
    fill-opacity: var(--vis-sankey-link-opacity);
  }

  &:hover {
    path {
      fill-opacity: var(--vis-sankey-link-hover-opacity);
    }
  }
`;
var linkPath = css`
  label: visible;
`;
var linkSelectionHelper = css`
  label: transparent;
  opacity: 0;
`;
var labelGroup = css`
  label: label-group;
  cursor: var(--vis-sankey-node-label-cursor);
`;
var labelTrimmed = css`
  label: label-trimmed;
`;
var label6 = css`
  label: label;
  dominant-baseline: hanging;

  fill: var(--vis-sankey-node-label-color);
  text-decoration: var(--vis-sankey-node-label-text-decoration);
  font-weight: var(--vis-sankey-node-label-font-weight);
  user-select: none;

  &, tspan {
    font-family: var(--vis-sankey-label-font-family, var(--vis-font-family));
    dominant-baseline: hanging;
  }
`;
var sublabel = css`
  label: sub-label;
  dominant-baseline: hanging;

  fill: var(--vis-sankey-node-label-color);
  user-select: none;

  &, tspan {
    font-family: var(--vis-sankey-label-font-family, var(--vis-font-family));
    font-weight: var(--vis-sankey-node-sublabel-font-weight);
    dominant-baseline: hanging;
  }
`;
var labelBackground = css`
  label: label-background;
  stroke: var(--vis-sankey-node-label-background-stroke-color);
  fill: var(--vis-sankey-node-label-background-fill-color);
  opacity: var(--vis-sankey-node-label-background-opacity);
`;
var hidden2 = css`
  label: hidden;
  visibility: hidden;
`;
var forceShow = css`
  label: forceShow;
  visibility: visible;
`;
var nodeGroup = css`
  label: node-group;
`;
var node = css`
  label: node;

  cursor: var(--vis-sankey-node-cursor);
  fill: var(--vis-sankey-node-color);
  opacity: var(--vis-sankey-node-opacity);

  &:hover {
    opacity: var(--vis-sankey-node-hover-opacity);
  }
`;
var nodeIcon = css`
  label: icon;

  font-family: var(--vis-sankey-icon-font-family);
  text-anchor: middle;
  font-size: var(--vis-sankey-icon-size);
  fill: var(--vis-sankey-node-icon-color);
  stroke: var(--vis-sankey-node-color);
  stroke-opacity: var(--vis-sankey-icon-stroke-opacity);
  user-select: none;
  pointer-events: none;
`;
var nodeExit = css`
  label: node-exit;
`;
var background2 = css`
  label: background;
`;

// node_modules/@unovis/ts/components/sankey/modules/link.js
function linkPath2({ x0: x06, x1: x110, y0: y06, y1: y110, width }) {
  const top0 = y06 - width / 2;
  const top1 = y110 - width / 2;
  const bottom0 = y06 + width / 2;
  const bottom1 = y110 + width / 2;
  const centerX = (x06 + x110) / 2;
  return `
    M ${x06}, ${top0}

    C ${centerX}, ${top0}
      ${centerX}, ${top1}
      ${x110}, ${top1}

    L ${x110}, ${bottom1}

    C ${centerX}, ${bottom1}
      ${centerX}, ${bottom0}
      ${x06}, ${bottom0}
    z
  `;
}
function createLinks(sel) {
  sel.append("path").attr("class", linkPath).attr("d", (d18, i8, el) => {
    el[i8]._animState = {
      x0: d18.source.x1,
      x1: d18.target.x0,
      y0: d18.y0,
      y1: d18.y1,
      width: Math.max(1, d18.width)
    };
    return linkPath2(el[i8]._animState);
  });
  sel.append("path").attr("class", linkSelectionHelper);
  sel.style("opacity", 0);
}
function updateLinks(sel, config, duration) {
  smartTransition(sel, duration).style("opacity", (d18) => d18._state.greyout ? 0.2 : 1);
  const linkSelection = sel.select(`.${linkPath}`).style("cursor", (d18) => getString(d18, config.linkCursor));
  const selectionTransition = smartTransition(linkSelection, duration).style("fill", (link7) => getColor(link7, config.linkColor));
  if (duration) {
    selectionTransition.attrTween("d", (d18, i8, el) => {
      const previous = el[i8]._animState;
      const next = {
        x0: d18.source.x1,
        x1: d18.target.x0,
        y0: d18.y0,
        y1: d18.y1,
        width: Math.max(1, d18.width)
      };
      const interpolator = {
        x0: number_default(previous.x0, next.x0),
        x1: number_default(previous.x1, next.x1),
        y0: number_default(previous.y0, next.y0),
        y1: number_default(previous.y1, next.y1),
        width: number_default(previous.width, next.width)
      };
      el[i8]._animState = next;
      return function(t4) {
        return linkPath2({
          x0: interpolator.x0(t4),
          x1: interpolator.x1(t4),
          y0: interpolator.y0(t4),
          y1: interpolator.y1(t4),
          width: interpolator.width(t4)
        });
      };
    });
  } else {
    linkSelection.attr("d", (d18) => linkPath2({
      x0: d18.source.x1,
      x1: d18.target.x0,
      y0: d18.y0,
      y1: d18.y1,
      width: Math.max(1, d18.width)
    }));
  }
  sel.select(`.${linkSelectionHelper}`).attr("d", (d18) => linkPath2({
    x0: d18.source.x1,
    x1: d18.target.x0,
    y0: d18.y0,
    y1: d18.y1,
    width: Math.max(10, d18.width)
  })).style("cursor", (d18) => getString(d18, config.linkCursor));
}
function removeLinks(sel) {
  sel.remove();
}

// node_modules/@unovis/ts/components/sankey/modules/label.js
var NODE_LABEL_SPACING = 10;
var LABEL_BLOCK_PADDING = 6.5;
function getLabelBackground(width, height, orientation, arrowWidth = 5, arrowHeight = 8) {
  const halfHeight = height / 2;
  const halfArrowHeight = arrowHeight / 2;
  if (orientation === Position.Left) {
    const rightArrowPos = `L 0 ${halfHeight - halfArrowHeight}   L   ${+arrowWidth} ${halfHeight} L 0 ${halfHeight + halfArrowHeight}`;
    return `
      M 0 0
      ${rightArrowPos}
      L 0  ${height}
      L ${-width} ${height}
      L ${-width} 0
      L 0 0 `;
  } else {
    const leftArrowPos = `L 0 ${halfHeight - halfArrowHeight}   L   ${-arrowWidth} ${halfHeight} L 0 ${halfHeight + halfArrowHeight}`;
    return `
      M 0 0
      ${leftArrowPos}
      L 0  ${height}
      L ${width} ${height}
      L ${width} 0
      L 0 0 `;
  }
}
function getLabelOrientation(d18, sankeyWidth, labelPosition) {
  let orientation = getValue(d18, labelPosition);
  if (orientation === Position.Auto || !orientation) {
    orientation = d18.x0 < sankeyWidth / 2 ? Position.Left : Position.Right;
  }
  return orientation;
}
var requiredLabelSpace = (labelWidth, labelFontSize) => {
  return {
    height: labelFontSize * 2.5 + 2 * LABEL_BLOCK_PADDING,
    width: labelWidth + 2 * NODE_LABEL_SPACING + 2 * LABEL_BLOCK_PADDING
  };
};
function getLabelGroupXTranslate(d18, config, width) {
  const orientation = getLabelOrientation(d18, width, config.labelPosition);
  switch (orientation) {
    case Position.Right:
      return config.nodeWidth + NODE_LABEL_SPACING;
    case Position.Left:
    default:
      return -NODE_LABEL_SPACING;
  }
}
function getLabelGroupYTranslate(d18, labelGroupHeight, config) {
  const nodeHeight = d18.y1 - d18.y0;
  if (config.labelBackground && nodeHeight < labelGroupHeight)
    return (nodeHeight - labelGroupHeight) / 2;
  switch (config.labelVerticalAlign) {
    case VerticalAlign.Bottom:
      return nodeHeight - labelGroupHeight;
    case VerticalAlign.Middle:
      return nodeHeight / 2 - labelGroupHeight / 2;
    case VerticalAlign.Top:
    default:
      return 0;
  }
}
function getLabelTextAnchor(d18, config, width) {
  const orientation = getLabelOrientation(d18, width, config.labelPosition);
  switch (orientation) {
    case Position.Right:
      return "start";
    case Position.Left:
    default:
      return "end";
  }
}
function getSubLabelTextAnchor(d18, config, width) {
  const isSublabelInline = config.subLabelPlacement === SankeySubLabelPlacement.Inline;
  const orientation = getLabelOrientation(d18, width, config.labelPosition);
  switch (orientation) {
    case Position.Right:
      return isSublabelInline ? "end" : "start";
    case Position.Left:
    default:
      return isSublabelInline ? "start" : "end";
  }
}
function renderLabel(labelGroup4, d18, config, width, duration, forceExpand = false) {
  var _a, _b;
  const labelTextSelection = labelGroup4.select(`.${label6}`);
  const labelShowBackground = config.labelBackground || forceExpand;
  const sublabelTextSelection = labelGroup4.select(`.${sublabel}`);
  const labelPadding = labelShowBackground ? LABEL_BLOCK_PADDING : 0;
  const isSublabelInline = config.subLabelPlacement === SankeySubLabelPlacement.Inline;
  const separator = config.labelForceWordBreak ? "" : config.labelTextSeparator;
  const fastEstimatesMode = true;
  const fontWidthToHeightRatio = 0.52;
  const dy = 0.32;
  const labelOrientation = getLabelOrientation(d18, width, config.labelPosition);
  const labelOrientationMult = labelOrientation === Position.Left ? -1 : 1;
  const labelText4 = getString(d18, config.label);
  const sublabelText = getString(d18, config.subLabel);
  let wasTrimmed = false;
  const labelFontSize = (_a = config.labelFontSize) !== null && _a !== void 0 ? _a : getCSSVariableValueInPixels("var(--vis-sankey-node-label-font-size)", labelGroup4.node());
  const subLabelFontSize = (_b = config.subLabelFontSize) !== null && _b !== void 0 ? _b : getCSSVariableValueInPixels("var(--vis-sankey-node-sublabel-font-size)", labelGroup4.node());
  const labelsFontSizeDifference = sublabelText ? labelFontSize - subLabelFontSize : 0;
  const labelTranslateY = labelPadding + (isSublabelInline && labelsFontSizeDifference < 0 ? -0.6 * labelsFontSizeDifference : 0);
  labelTextSelection.text(labelText4).attr("font-size", labelFontSize).style("fill", getColor(d18, config.labelColor)).attr("transform", `translate(${labelOrientationMult * labelPadding},${labelTranslateY})`).style("cursor", (d19) => getString(d19, config.labelCursor));
  const labelMaxWidth = isSublabelInline ? config.labelMaxWidth * (1 - (sublabelText ? config.subLabelToLabelInlineWidthRatio : 0)) : config.labelMaxWidth;
  if (config.labelFit === FitMode.Wrap || forceExpand)
    wrapSVGText(labelTextSelection, labelMaxWidth, separator);
  else
    wasTrimmed = trimSVGText(labelTextSelection, labelMaxWidth, config.labelTrimMode, fastEstimatesMode, labelFontSize, fontWidthToHeightRatio);
  const labelSize = estimateTextSize(labelTextSelection, labelFontSize, dy, fastEstimatesMode, fontWidthToHeightRatio);
  const sublabelTranslateX = labelOrientationMult * (labelPadding + (isSublabelInline ? config.labelMaxWidth : 0));
  const sublabelMarginTop = 0;
  const sublabelTranslateY = labelPadding + (isSublabelInline ? labelsFontSizeDifference > 0 ? 0.6 * labelsFontSizeDifference : 0 : labelSize.height + sublabelMarginTop);
  sublabelTextSelection.text(sublabelText).attr("font-size", subLabelFontSize).style("fill", getColor(d18, config.subLabelColor)).attr("transform", `translate(${sublabelTranslateX},${sublabelTranslateY})`).style("cursor", (d19) => getString(d19, config.labelCursor));
  const sublabelMaxWidth = isSublabelInline ? config.labelMaxWidth * config.subLabelToLabelInlineWidthRatio : config.labelMaxWidth;
  if (config.labelFit === FitMode.Wrap || forceExpand)
    wrapSVGText(sublabelTextSelection, sublabelMaxWidth, separator);
  else
    wasTrimmed = wasTrimmed || trimSVGText(sublabelTextSelection, sublabelMaxWidth, config.labelTrimMode, fastEstimatesMode, subLabelFontSize, fontWidthToHeightRatio);
  labelGroup4.classed(labelTrimmed, wasTrimmed);
  const sublabelSize = estimateTextSize(sublabelTextSelection, subLabelFontSize, dy, fastEstimatesMode, fontWidthToHeightRatio);
  const labelGroupHeight = (isSublabelInline ? Math.max(labelSize.height, sublabelSize.height) : labelSize.height + sublabelSize.height) + 2 * labelPadding;
  const labelBackground$1 = labelGroup4.select(`.${labelBackground}`);
  labelBackground$1.attr("d", labelShowBackground ? getLabelBackground(config.labelMaxWidth + 2 * labelPadding, labelGroupHeight, labelOrientation) : null);
  const labelTextAnchor = getLabelTextAnchor(d18, config, width);
  const sublabelTextAnchor = getSubLabelTextAnchor(d18, config, width);
  const xTranslate = getLabelGroupXTranslate(d18, config, width);
  const yTranslate = getLabelGroupYTranslate(d18, labelGroupHeight, config);
  labelTextSelection.attr("text-anchor", labelTextAnchor);
  sublabelTextSelection.attr("text-anchor", sublabelTextAnchor);
  const hasTransform = !!labelGroup4.attr("transform");
  smartTransition(labelGroup4, hasTransform ? duration : 0).attr("transform", `translate(${xTranslate},${yTranslate})`);
  return {
    x: d18.x0 + xTranslate,
    y: d18.y0 + yTranslate,
    width: config.labelMaxWidth,
    height: labelGroupHeight,
    layer: d18.layer,
    selection: labelGroup4
  };
}

// node_modules/@unovis/ts/components/sankey/modules/node.js
function createNodes(sel, config, width, bleed) {
  const { enterTransitionType } = config;
  sel.append("rect").attr("class", node).attr("width", config.nodeWidth).attr("height", (d18) => d18.y1 - d18.y0).style("fill", (node4) => getColor(node4, config.nodeColor));
  const labelGroup$1 = sel.append("g").attr("class", labelGroup);
  labelGroup$1.append("path").attr("class", labelBackground);
  labelGroup$1.append("text").attr("class", label6);
  labelGroup$1.append("text").attr("class", sublabel);
  sel.append("text").attr("class", nodeIcon).attr("text-anchor", "middle").attr("dy", "0.5px");
  sel.attr("transform", (d18) => {
    var _a;
    const x21 = enterTransitionType === SankeyEnterTransitionType.FromAncestor && ((_a = d18.targetLinks) === null || _a === void 0 ? void 0 : _a[0]) ? d18.targetLinks[0].source.x0 : d18.x0;
    return `translate(${sel.size() === 1 ? width * 0.5 - bleed.left : x21}, ${d18.y0})`;
  }).style("opacity", 0);
}
function getNodeXPos(d18, config, width, bleed, hasLinks) {
  if (hasLinks)
    return d18.x0;
  switch (config.nodeAlign) {
    case SankeyNodeAlign.Left:
      return d18.x0;
    case SankeyNodeAlign.Right:
      return width - bleed.right;
    case SankeyNodeAlign.Center:
    case SankeyNodeAlign.Justify:
    default:
      return width * 0.5 - bleed.left;
  }
}
function updateNodes(sel, config, width, bleed, hasLinks, duration) {
  smartTransition(sel, duration).attr("transform", (d18) => `translate(${getNodeXPos(d18, config, width, bleed, hasLinks)},${d18.y0})`).style("opacity", (d18) => d18._state.greyout ? 0.2 : 1);
  smartTransition(sel.select(`.${node}`), duration).attr("width", config.nodeWidth).attr("height", (d18) => d18.y1 - d18.y0).style("cursor", (d18) => getString(d18, config.nodeCursor)).style("fill", (d18) => getColor(d18, config.nodeColor));
  renderNodeLabels(sel, config, width, duration);
  const nodeIcon$1 = sel.select(`.${nodeIcon}`);
  if (config.nodeIcon) {
    nodeIcon$1.attr("visibility", null).attr("text-anchor", "middle").style("dominant-baseline", "central").style("stroke", (d18) => getColor(d18, config.nodeIconColor)).style("fill", (d18) => getColor(d18, config.nodeIconColor)).style("font-size", (d18) => {
      const nodeHeight = d18.y1 - d18.y0;
      return nodeHeight < SANKEY_ICON_SIZE ? `${nodeHeight * 0.65}px` : null;
    }).html((d18) => getString(d18, config.nodeIcon));
    smartTransition(nodeIcon$1, duration).attr("x", config.nodeWidth / 2).attr("y", (d18) => (d18.y1 - d18.y0) / 2);
  } else {
    nodeIcon$1.attr("visibility", "hidden");
  }
}
function renderNodeLabels(sel, config, width, duration, enforceNodeVisibility) {
  const labelGroupSelection = sel.select(`.${labelGroup}`);
  const labelGroupEls = labelGroupSelection.nodes() || [];
  const labelGroupBBoxes = labelGroupEls.map((g15) => {
    const gSelection = select_default2(g15);
    const datum2 = gSelection.datum();
    return renderLabel(gSelection, datum2, config, width, duration, enforceNodeVisibility === datum2);
  });
  if (config.labelVisibility) {
    for (const b25 of labelGroupBBoxes) {
      const datum2 = b25.selection.datum();
      const box = { x: b25.x, y: b25.y, width: b25.width, height: b25.height };
      b25.hidden = !config.labelVisibility(datum2, box, enforceNodeVisibility === datum2);
    }
  } else {
    const maxLayer = Math.max(...labelGroupBBoxes.map((b25) => b25.layer));
    for (let layer = 0; layer <= maxLayer; layer += 1) {
      const boxes = labelGroupBBoxes.filter((b25) => b25.layer === layer);
      boxes.sort((a7, b25) => a7.y - b25.y);
      let lastVisibleIdx = 0;
      for (let i8 = 1; i8 < boxes.length; i8 += 1) {
        const b02 = boxes[lastVisibleIdx];
        const b110 = boxes[i8];
        const shouldBeHidden = b110.y < b02.y + b02.height;
        if (shouldBeHidden) {
          if (b110.selection.datum() === enforceNodeVisibility)
            b02.hidden = true;
          else
            b110.hidden = true;
        }
        if (!b110.hidden)
          lastVisibleIdx = i8;
      }
    }
  }
  for (const b25 of labelGroupBBoxes) {
    b25.selection.classed(hidden2, b25.hidden);
  }
}
function removeNodes(selection2, config, duration) {
  const { exitTransitionType } = config;
  selection2.each((d18, i8, els) => {
    var _a;
    const node4 = select_default2(els[i8]);
    const transition2 = smartTransition(node4, duration);
    if (exitTransitionType === SankeyExitTransitionType.ToAncestor && ((_a = d18.targetLinks) === null || _a === void 0 ? void 0 : _a[0])) {
      transition2.attr("transform", `translate(${d18.targetLinks[0].source.x0},${d18.y0})`);
    }
    transition2.style("opacity", 0).remove();
  });
}
function onNodeMouseOver(d18, nodeSelection2, config, width) {
  const labelGroup$1 = nodeSelection2.raise().select(`.${labelGroup}`);
  if (config.labelExpandTrimmedOnHover && labelGroup$1.classed(labelTrimmed) || labelGroup$1.classed(hidden2)) {
    renderLabel(labelGroup$1, d18, config, width, 0, true);
  }
  labelGroup$1.classed(forceShow, true);
}
function onNodeMouseOut(d18, nodeSelection2, config, width) {
  const labelGroup$1 = nodeSelection2.select(`.${labelGroup}`);
  if (config.labelExpandTrimmedOnHover || labelGroup$1.classed(hidden2)) {
    renderLabel(labelGroup$1, d18, config, width, 0);
  }
  labelGroup$1.classed(forceShow, false);
}

// node_modules/@unovis/ts/components/sankey/index.js
var Sankey2 = class _Sankey extends ComponentCore {
  constructor(config) {
    super();
    this._defaultConfig = SankeyDefaultConfig;
    this.config = this._defaultConfig;
    this.datamodel = new GraphDataModel();
    this._extendedWidth = void 0;
    this._extendedHeight = void 0;
    this._extendedHeightIncreased = void 0;
    this._sankey = Sankey();
    this._highlightTimeoutId = null;
    this._highlightActive = false;
    this.events = {
      [_Sankey.selectors.nodeGroup]: {
        mouseenter: this._onNodeMouseOver.bind(this),
        mouseleave: this._onNodeMouseOut.bind(this)
      },
      [_Sankey.selectors.node]: {
        mouseenter: this._onNodeRectMouseOver.bind(this),
        mouseleave: this._onNodeRectMouseOut.bind(this)
      },
      [_Sankey.selectors.link]: {
        mouseenter: this._onLinkMouseOver.bind(this),
        mouseleave: this._onLinkMouseOut.bind(this)
      }
    };
    if (config)
      this.setConfig(config);
    this._backgroundRect = this.g.append("rect").attr("class", background2);
    this._linksGroup = this.g.append("g").attr("class", links);
    this._nodesGroup = this.g.append("g").attr("class", nodes);
  }
  get bleed() {
    var _a;
    const { config, datamodel: { nodes: nodes4, links: links5 } } = this;
    const labelFontSize = (_a = config.labelFontSize) !== null && _a !== void 0 ? _a : getCSSVariableValueInPixels("var(--vis-sankey-label-font-size)", this.element);
    const labelSize = requiredLabelSpace(config.labelMaxWidth, labelFontSize);
    let left3 = 0;
    let right3 = 0;
    if (nodes4.length) {
      const sankeyProbeSize = 1e3;
      this._populateLinkAndNodeValues();
      this._sankey.size([sankeyProbeSize, sankeyProbeSize]);
      this._sankey({ nodes: nodes4, links: links5 });
      const maxDepth2 = max(nodes4, (d18) => d18.depth);
      const zeroDepthNodes = nodes4.filter((d18) => d18.depth === 0);
      const maxDepthNodes = nodes4.filter((d18) => d18.depth === maxDepth2);
      left3 = zeroDepthNodes.some((d18) => getLabelOrientation(d18, sankeyProbeSize, config.labelPosition) === Position.Left) ? labelSize.width : 0;
      right3 = maxDepthNodes.some((d18) => getLabelOrientation(d18, sankeyProbeSize, config.labelPosition) === Position.Right) ? labelSize.width : 0;
    }
    const top2 = config.labelVerticalAlign === VerticalAlign.Top ? 0 : config.labelVerticalAlign === VerticalAlign.Bottom ? labelSize.height : labelSize.height / 2;
    const bottom2 = config.labelVerticalAlign === VerticalAlign.Top ? labelSize.height : config.labelVerticalAlign === VerticalAlign.Bottom ? 0 : labelSize.height / 2;
    return { top: top2, bottom: bottom2, left: left3, right: right3 };
  }
  setData(data) {
    super.setData(data);
    if (this.sizing !== Sizing.Fit || !this._hasLinks())
      this._preCalculateComponentSize();
  }
  setConfig(config) {
    super.setConfig(config);
    if (this.sizing !== Sizing.Fit || !this._hasLinks())
      this._preCalculateComponentSize();
    const nodeId = ((d18, i8) => getString(d18, this.config.id, i8));
    this._sankey.linkSort(this.config.linkSort);
    this._sankey.nodeId(nodeId).nodeWidth(this.config.nodeWidth).nodePadding(this.config.nodePadding).nodeAlign(SankeyLayout[this.config.nodeAlign]).nodeSort(this.config.nodeSort).iterations(this.config.iterations);
  }
  _render(customDuration) {
    const { config, bleed, datamodel: { nodes: nodes4, links: links5 } } = this;
    const duration = isNumber(customDuration) ? customDuration : config.duration;
    if (nodes4.length === 0 || nodes4.length === 1 && links5.length > 0 || nodes4.length === 1 && !config.showSingleNode || nodes4.length > 1 && links5.length === 0) {
      this._linksGroup.selectAll(`.${link3}`).call(removeLinks, duration);
      this._nodesGroup.selectAll(`.${nodeGroup}`).call(removeNodes, config, duration);
    }
    this._prepareLayout();
    smartTransition(this._linksGroup, duration).attr("transform", `translate(${bleed.left},${bleed.top})`);
    const linkSelection = this._linksGroup.selectAll(`.${link3}`).data(links5, (d18, i8) => {
      var _a;
      return (_a = config.id(d18, i8)) !== null && _a !== void 0 ? _a : i8;
    });
    const linkSelectionEnter = linkSelection.enter().append("g").attr("class", link3);
    linkSelectionEnter.call(createLinks);
    linkSelection.merge(linkSelectionEnter).call(updateLinks, config, duration);
    linkSelection.exit().call(removeLinks);
    smartTransition(this._nodesGroup, duration).attr("transform", `translate(${bleed.left},${bleed.top})`);
    const nodeSelection2 = this._nodesGroup.selectAll(`.${nodeGroup}`).data(nodes4, (d18, i8) => {
      var _a;
      return (_a = config.id(d18, i8)) !== null && _a !== void 0 ? _a : i8;
    });
    const nodeSelectionEnter = nodeSelection2.enter().append("g").attr("class", nodeGroup);
    nodeSelectionEnter.call(createNodes, this.config, this._width, bleed);
    nodeSelection2.merge(nodeSelectionEnter).call(updateNodes, config, this._width, bleed, this._hasLinks(), duration);
    nodeSelection2.exit().attr("class", nodeExit).call(removeNodes, config, duration);
    this._backgroundRect.attr("width", this.getWidth()).attr("height", this.getHeight()).attr("opacity", 0);
  }
  _populateLinkAndNodeValues() {
    const { config, datamodel } = this;
    const nodes4 = datamodel.nodes;
    const links5 = datamodel.links;
    links5.forEach((link7, i8) => {
      link7.value = getNumber(link7, (d18) => getNumber(d18, config.linkValue, i8));
    });
    nodes4.forEach((node4, i8) => {
      node4.fixedValue = getNumber(node4, config.nodeFixedValue, i8);
    });
  }
  _preCalculateComponentSize() {
    const { bleed, config, datamodel } = this;
    const nodes4 = datamodel.nodes;
    if (nodes4.length) {
      this._populateLinkAndNodeValues();
      this._sankey(datamodel);
    }
    const scaleExtent = extent(nodes4, (d18) => d18.value || void 0);
    const scaleRange = [config.nodeMinHeight, config.nodeMaxHeight];
    const scale = linear3().domain(scaleExtent).range(scaleRange).clamp(true);
    nodes4.forEach((n) => {
      n._state.precalculatedHeight = scale(n.value) || config.nodeMinHeight;
    });
    const groupedByColumn = groupBy(nodes4, (d18) => d18.layer);
    const values = Object.values(groupedByColumn).map((group3) => sum(group3.map((n) => n._state.precalculatedHeight + config.nodePadding)) - config.nodePadding);
    const height = max(values) || config.nodeMinHeight;
    this._extendedHeight = height + bleed.top + bleed.bottom;
    this._extendedWidth = Math.max(0, (config.nodeWidth + config.nodeHorizontalSpacing) * Object.keys(groupedByColumn).length - config.nodeHorizontalSpacing + bleed.left + bleed.right);
  }
  _prepareLayout() {
    var _a, _b;
    const { config, bleed, datamodel } = this;
    const isExtendedSize = this.sizing === Sizing.Extend;
    const sankeyHeight = this.sizing === Sizing.Fit ? this._height : this._extendedHeight;
    const sankeyWidth = this.sizing === Sizing.Fit ? this._width : this._extendedWidth;
    this._sankey.size([
      Math.max(sankeyWidth - bleed.left - bleed.right, 0),
      Math.max(sankeyHeight - bleed.top - bleed.bottom, 0)
    ]);
    const nodes4 = datamodel.nodes;
    const links5 = datamodel.links;
    if (!this._hasLinks()) {
      let y25 = 0;
      const nodesTotalHeight = sum(nodes4, (n) => n._state.precalculatedHeight || 1);
      for (const node4 of nodes4) {
        const sankeyHeight2 = this.getHeight() - bleed.top - bleed.bottom;
        const nodeHeight = node4._state.precalculatedHeight || 1;
        const h17 = isExtendedSize ? nodeHeight : (sankeyHeight2 - config.nodePadding * (nodes4.length - 1)) * nodeHeight / nodesTotalHeight;
        node4.width = Math.max(10, config.nodeWidth);
        node4.x0 = 0;
        node4.x1 = node4.width;
        node4.y0 = y25;
        node4.y1 = y25 + Math.max(1, h17);
        node4.layer = 0;
        y25 = node4.y1 + config.nodePadding;
      }
      this._extendedHeightIncreased = void 0;
      return;
    }
    this._populateLinkAndNodeValues();
    this._sankey({ nodes: nodes4, links: links5 });
    for (const node4 of nodes4) {
      const singleExtendedSize = isExtendedSize && !((_a = node4.sourceLinks) === null || _a === void 0 ? void 0 : _a.length) && !((_b = node4.targetLinks) === null || _b === void 0 ? void 0 : _b.length);
      const h17 = Math.max(singleExtendedSize ? config.nodeMinHeight : 1, node4.y1 - node4.y0);
      const y25 = (node4.y0 + node4.y1) / 2;
      node4.y0 = y25 - h17 / 2;
      node4.y1 = y25 + h17 / 2;
    }
    if (isExtendedSize) {
      const height = max(nodes4, (d18) => d18.y1);
      this._extendedHeightIncreased = height + bleed.top + bleed.bottom;
    }
  }
  getWidth() {
    return this.sizing === Sizing.Fit ? this._width : this._extendedWidth || 0;
  }
  getHeight() {
    return this.sizing === Sizing.Fit ? this._height : Math.max(this._extendedHeightIncreased || 0, this._extendedHeight || 0);
  }
  getLayoutWidth() {
    return this.sizing === Sizing.Fit ? this._width : this._extendedWidth;
  }
  getLayoutHeight() {
    return this.sizing === Sizing.Fit ? this._height : this._extendedHeightIncreased || this._extendedHeight;
  }
  getColumnCenters() {
    const { datamodel } = this;
    const nodes4 = datamodel.nodes;
    const centers = nodes4.reduce((pos, node4) => {
      const idx = node4.layer;
      if (!isFinite(pos[idx])) {
        pos[idx] = (node4.x0 + node4.x1) / 2;
      }
      return pos;
    }, []);
    return centers;
  }
  highlightSubtree(node4) {
    const { config, datamodel } = this;
    clearTimeout(this._highlightTimeoutId);
    this._highlightTimeoutId = setTimeout(() => {
      for (const n of datamodel.nodes)
        n._state.greyout = true;
      for (const l7 of datamodel.links)
        l7._state.greyout = true;
      this.recursiveSetSubtreeState(node4, "sourceLinks", "target", "greyout", false);
      this.recursiveSetSubtreeState(node4, "targetLinks", "source", "greyout", false);
      this._render(config.highlightDuration);
      this._highlightActive = true;
    }, config.highlightDelay);
  }
  recursiveSetSubtreeState(node4, linksKey, nodeKey, key, value2) {
    node4._state[key] = value2;
    for (const l7 of node4[linksKey]) {
      l7._state[key] = value2;
      this.recursiveSetSubtreeState(l7[nodeKey], linksKey, nodeKey, key, value2);
    }
  }
  disableHighlight() {
    const { config, datamodel } = this;
    clearTimeout(this._highlightTimeoutId);
    if (this._highlightActive) {
      this._highlightActive = false;
      for (const n of datamodel.nodes)
        n._state.greyout = false;
      for (const l7 of datamodel.links)
        l7._state.greyout = false;
      this._render(config.highlightDuration);
    }
  }
  _hasLinks() {
    const { datamodel } = this;
    return datamodel.links.length > 0;
  }
  _onNodeMouseOver(d18, event) {
    onNodeMouseOver(d18, select_default2(event.currentTarget), this.config, this._width);
  }
  _onNodeMouseOut(d18, event) {
    onNodeMouseOut(d18, select_default2(event.currentTarget), this.config, this._width);
  }
  _onNodeRectMouseOver(d18) {
    const { config } = this;
    if (config.highlightSubtreeOnHover)
      this.highlightSubtree(d18);
  }
  _onNodeRectMouseOut(d18) {
    this.disableHighlight();
  }
  _onLinkMouseOver(d18, event) {
    const { config } = this;
    if (config.highlightSubtreeOnHover)
      this.highlightSubtree(d18.target);
  }
  _onLinkMouseOut(d18, event) {
    this.disableHighlight();
  }
};
Sankey2.selectors = style_exports12;

// node_modules/@unovis/ts/components/area/config.js
var AreaDefaultConfig = Object.assign(Object.assign({}, XYComponentDefaultConfig), { color: void 0, curveType: CurveType.MonotoneX, baseline: () => 0, opacity: 1, cursor: null, minHeight1Px: false, minHeight: void 0 });

// node_modules/@unovis/ts/components/area/style.js
var style_exports13 = {};
__export(style_exports13, {
  area: () => area,
  globalStyles: () => globalStyles8,
  root: () => root15
});
var root15 = css`
  label: area-component;
`;
var globalStyles8 = injectGlobal`
  :root {
    --vis-area-cursor: default;
    --vis-area-fill-opacity: 1;
    --vis-area-stroke-color: none;
    --vis-area-stroke-width: 0px;
    --vis-area-stroke-dasharray: none;
    --vis-area-stroke-opacity: 1;
    --vis-area-hover-fill-opacity: none;
    --vis-area-hover-stroke-width: none;

    /* Dark Theme */
    --vis-dark-area-stroke-color: none;
  }

  body.theme-dark ${`.${root15}`} {
    --vis-area-stroke-color: var(--vis-dark-area-stroke-color);
  }

`;
var area = css`
  label: area;
  cursor: var(--vis-area-cursor);
  fill-opacity: var(--vis-area-fill-opacity);
  stroke-width: var(--vis-area-stroke-width);
  stroke-dasharray: var(--vis-area-stroke-dasharray);
  stroke: var(--vis-area-stroke-color);
  stroke-opacity: var(--vis-area-stroke-opacity);

  &:hover {
    fill-opacity: var(--vis-area-hover-fill-opacity);
    stroke-width: var(--vis-area-hover-stroke-width);
  }
`;

// node_modules/@unovis/ts/components/area/index.js
var Area = class _Area extends XYComponentCore {
  constructor(config) {
    super();
    this._defaultConfig = AreaDefaultConfig;
    this.config = this._defaultConfig;
    this.stacked = true;
    this.events = {
      [_Area.selectors.area]: {}
    };
    if (config)
      this.setConfig(config);
    this.stacked = Array.isArray(this.config.y);
  }
  _render(customDuration) {
    super._render(customDuration);
    const { config, datamodel: { data } } = this;
    const duration = isNumber(customDuration) ? customDuration : config.duration;
    const curveGen = Curve[config.curveType];
    this._areaGen = area_default().x((d18) => d18.x).y0((d18) => d18.y0).y1((d18) => d18.y1).curve(curveGen);
    const yAccessors = isArray(config.y) ? config.y : [config.y];
    const areaDataX = data.map((d18, i8) => this.xScale(getNumber(d18, config.x, i8)));
    const stacked = getStackedData(data, config.baseline, yAccessors, this._prevNegative);
    this._prevNegative = stacked.map((s12) => !!s12.isMostlyNegative);
    const minHeightCumulativeArray = [];
    const stackedData = stacked.map((arr) => arr.map((d18, j6) => {
      var _a, _b;
      const x21 = areaDataX[j6];
      const y06 = this.yScale(d18[0]);
      const y110 = this.yScale(d18[1]);
      const isNegativeArea = y110 > y06;
      const cumulative = minHeightCumulativeArray[j6] || 0;
      const adjustedY0 = isNegativeArea ? y06 + cumulative : y06 - cumulative;
      const adjustedY1 = isNegativeArea ? y110 + cumulative : y110 - cumulative;
      let heightAdjustment = 0;
      if ((config.minHeight || config.minHeight1Px) && Math.abs(adjustedY1 - adjustedY0) < ((_a = config.minHeight) !== null && _a !== void 0 ? _a : 1)) {
        heightAdjustment = ((_b = config.minHeight) !== null && _b !== void 0 ? _b : 1) - Math.abs(adjustedY1 - adjustedY0);
        minHeightCumulativeArray[j6] = cumulative + heightAdjustment;
      }
      return {
        x: x21,
        y0: adjustedY0,
        y1: isNegativeArea ? adjustedY1 + heightAdjustment : adjustedY1 - heightAdjustment
      };
    }));
    const areaMaxIdx = stackedData.length - 1;
    const stackedDataReversed = stackedData.reverse();
    const areas = this.g.selectAll(`.${area}`).data(stackedDataReversed);
    const areasEnter = areas.enter().append("path").attr("class", area).attr("d", (d18) => this._areaGen(d18) || this._emptyPath()).style("opacity", 0).style("fill", (d18, i8) => getColor(data, config.color, areaMaxIdx - i8));
    const areasMerged = smartTransition(areasEnter.merge(areas), duration).style("opacity", (d18, i8) => {
      const isDefined = d18.some((p13) => p13.y0 - p13.y1 !== 0);
      return isDefined ? getNumber(data, config.opacity, areaMaxIdx - i8) : 0;
    }).style("fill", (d18, i8) => getColor(data, config.color, areaMaxIdx - i8)).style("cursor", (d18, i8) => getString(data, config.cursor, areaMaxIdx - i8));
    if (duration) {
      const transition2 = areasMerged;
      transition2.attrTween("d", (d18, i8, el) => {
        const previous = select_default2(el[i8]).attr("d");
        const next = this._areaGen(d18) || this._emptyPath();
        return interpolatePath(previous, next);
      });
    } else {
      areasMerged.attr("d", (d18) => this._areaGen(d18) || this._emptyPath());
    }
    smartTransition(areas.exit(), duration).style("opacity", 0).remove();
  }
  getYDataExtent(scaleByVisibleData) {
    const { config, datamodel } = this;
    const yAccessors = isArray(config.y) ? config.y : [config.y];
    const xDomain = this.xScale.domain();
    const data = scaleByVisibleData ? filterDataByRange(datamodel.data, xDomain, config.x, true) : datamodel.data;
    return getStackedExtent(data, config.baseline, ...yAccessors);
  }
  _emptyPath() {
    const xRange = this.xScale.range();
    const yDomain = this.yScale.domain();
    const y06 = this.yScale((yDomain[0] + yDomain[1]) / 2);
    const y110 = y06;
    return this._areaGen([
      { y0: y06, y1: y110, x: xRange[0] },
      { y0: y06, y1: y110, x: xRange[1] }
    ]);
  }
};
Area.selectors = style_exports13;

// node_modules/d3-zoom/src/constant.js
var constant_default9 = (x21) => () => x21;

// node_modules/d3-zoom/src/event.js
function ZoomEvent(type2, {
  sourceEvent,
  target,
  transform: transform2,
  dispatch
}) {
  Object.defineProperties(this, {
    type: { value: type2, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    transform: { value: transform2, enumerable: true, configurable: true },
    _: { value: dispatch }
  });
}

// node_modules/d3-zoom/src/transform.js
function Transform(k17, x21, y25) {
  this.k = k17;
  this.x = x21;
  this.y = y25;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k17) {
    return k17 === 1 ? this : new Transform(this.k * k17, this.x, this.y);
  },
  translate: function(x21, y25) {
    return x21 === 0 & y25 === 0 ? this : new Transform(this.k, this.x + this.k * x21, this.y + this.k * y25);
  },
  apply: function(point13) {
    return [point13[0] * this.k + this.x, point13[1] * this.k + this.y];
  },
  applyX: function(x21) {
    return x21 * this.k + this.x;
  },
  applyY: function(y25) {
    return y25 * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x21) {
    return (x21 - this.x) / this.k;
  },
  invertY: function(y25) {
    return (y25 - this.y) / this.k;
  },
  rescaleX: function(x21) {
    return x21.copy().domain(x21.range().map(this.invertX, this).map(x21.invert, x21));
  },
  rescaleY: function(y25) {
    return y25.copy().domain(y25.range().map(this.invertY, this).map(y25.invert, y25));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity4 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node4) {
  while (!node4.__zoom) if (!(node4 = node4.parentNode)) return identity4;
  return node4.__zoom;
}

// node_modules/d3-zoom/src/noevent.js
function nopropagation3(event) {
  event.stopImmediatePropagation();
}
function noevent_default3(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-zoom/src/zoom.js
function defaultFilter3(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent2() {
  var e3 = this;
  if (e3 instanceof SVGElement) {
    e3 = e3.ownerSVGElement || e3;
    if (e3.hasAttribute("viewBox")) {
      e3 = e3.viewBox.baseVal;
      return [[e3.x, e3.y], [e3.x + e3.width, e3.y + e3.height]];
    }
    return [[0, 0], [e3.width.baseVal.value, e3.height.baseVal.value]];
  }
  return [[0, 0], [e3.clientWidth, e3.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity4;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable3() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent2, translateExtent) {
  var dx0 = transform2.invertX(extent2[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent2[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent2[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent2[1][1]) - translateExtent[1][1];
  return transform2.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom_default2() {
  var filter3 = defaultFilter3, extent2 = defaultExtent2, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable3, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom.transform = function(collection, transform2, point13, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule(collection, transform2, point13, event);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
      });
    }
  };
  zoom.scaleBy = function(selection2, k17, p13, event) {
    zoom.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k17 === "function" ? k17.apply(this, arguments) : k17;
      return k0 * k1;
    }, p13, event);
  };
  zoom.scaleTo = function(selection2, k17, p13, event) {
    zoom.transform(selection2, function() {
      var e3 = extent2.apply(this, arguments), t03 = this.__zoom, p0 = p13 == null ? centroid(e3) : typeof p13 === "function" ? p13.apply(this, arguments) : p13, p1 = t03.invert(p0), k1 = typeof k17 === "function" ? k17.apply(this, arguments) : k17;
      return constrain(translate(scale(t03, k1), p0, p1), e3, translateExtent);
    }, p13, event);
  };
  zoom.translateBy = function(selection2, x21, y25, event) {
    zoom.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x21 === "function" ? x21.apply(this, arguments) : x21,
        typeof y25 === "function" ? y25.apply(this, arguments) : y25
      ), extent2.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom.translateTo = function(selection2, x21, y25, p13, event) {
    zoom.transform(selection2, function() {
      var e3 = extent2.apply(this, arguments), t4 = this.__zoom, p0 = p13 == null ? centroid(e3) : typeof p13 === "function" ? p13.apply(this, arguments) : p13;
      return constrain(identity4.translate(p0[0], p0[1]).scale(t4.k).translate(
        typeof x21 === "function" ? -x21.apply(this, arguments) : -x21,
        typeof y25 === "function" ? -y25.apply(this, arguments) : -y25
      ), e3, translateExtent);
    }, p13, event);
  };
  function scale(transform2, k17) {
    k17 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k17));
    return k17 === transform2.k ? transform2 : new Transform(k17, transform2.x, transform2.y);
  }
  function translate(transform2, p0, p1) {
    var x21 = p0[0] - p1[0] * transform2.k, y25 = p0[1] - p1[1] * transform2.k;
    return x21 === transform2.x && y25 === transform2.y ? transform2 : new Transform(transform2.k, x21, y25);
  }
  function centroid(extent3) {
    return [(+extent3[0][0] + +extent3[1][0]) / 2, (+extent3[0][1] + +extent3[1][1]) / 2];
  }
  function schedule(transition2, transform2, point13, event) {
    transition2.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g15 = gesture(that, args).event(event), e3 = extent2.apply(that, args), p13 = point13 == null ? centroid(e3) : typeof point13 === "function" ? point13.apply(that, args) : point13, w14 = Math.max(e3[1][0] - e3[0][0], e3[1][1] - e3[0][1]), a7 = that.__zoom, b25 = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i8 = interpolate(a7.invert(p13).concat(w14 / a7.k), b25.invert(p13).concat(w14 / b25.k));
      return function(t4) {
        if (t4 === 1) t4 = b25;
        else {
          var l7 = i8(t4), k17 = w14 / l7[2];
          t4 = new Transform(k17, p13[0] - l7[0] * k17, p13[1] - l7[1] * k17);
        }
        g15.zoom(null, t4);
      };
    });
  }
  function gesture(that, args, clean2) {
    return !clean2 && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent2.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform2) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform2.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform2.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform2.invert(this.touch1[0]);
      this.that.__zoom = transform2;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type2) {
      var d18 = select_default2(this.that).datum();
      listeners.call(
        type2,
        this.that,
        new ZoomEvent(type2, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type: type2,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d18
      );
    }
  };
  function wheeled(event, ...args) {
    if (!filter3.apply(this, arguments)) return;
    var g15 = gesture(this, args).event(event), t4 = this.__zoom, k17 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t4.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p13 = pointer_default(event);
    if (g15.wheel) {
      if (g15.mouse[0][0] !== p13[0] || g15.mouse[0][1] !== p13[1]) {
        g15.mouse[1] = t4.invert(g15.mouse[0] = p13);
      }
      clearTimeout(g15.wheel);
    } else if (t4.k === k17) return;
    else {
      g15.mouse = [p13, t4.invert(p13)];
      interrupt_default(this);
      g15.start();
    }
    noevent_default3(event);
    g15.wheel = setTimeout(wheelidled, wheelDelay);
    g15.zoom("mouse", constrain(translate(scale(t4, k17), g15.mouse[0], g15.mouse[1]), g15.extent, translateExtent));
    function wheelidled() {
      g15.wheel = null;
      g15.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter3.apply(this, arguments)) return;
    var currentTarget = event.currentTarget, g15 = gesture(this, args, true).event(event), v28 = select_default2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p13 = pointer_default(event, currentTarget), x06 = event.clientX, y06 = event.clientY;
    nodrag_default(event.view);
    nopropagation3(event);
    g15.mouse = [p13, this.__zoom.invert(p13)];
    interrupt_default(this);
    g15.start();
    function mousemoved(event2) {
      noevent_default3(event2);
      if (!g15.moved) {
        var dx = event2.clientX - x06, dy = event2.clientY - y06;
        g15.moved = dx * dx + dy * dy > clickDistance2;
      }
      g15.event(event2).zoom("mouse", constrain(translate(g15.that.__zoom, g15.mouse[0] = pointer_default(event2, currentTarget), g15.mouse[1]), g15.extent, translateExtent));
    }
    function mouseupped(event2) {
      v28.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event2.view, g15.moved);
      noevent_default3(event2);
      g15.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (!filter3.apply(this, arguments)) return;
    var t03 = this.__zoom, p0 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t03.invert(p0), k1 = t03.k * (event.shiftKey ? 0.5 : 2), t13 = constrain(translate(scale(t03, k1), p0, p1), extent2.apply(this, args), translateExtent);
    noevent_default3(event);
    if (duration > 0) select_default2(this).transition().duration(duration).call(schedule, t13, p0, event);
    else select_default2(this).call(zoom.transform, t13, p0, event);
  }
  function touchstarted(event, ...args) {
    if (!filter3.apply(this, arguments)) return;
    var touches = event.touches, n = touches.length, g15 = gesture(this, args, event.changedTouches.length === n).event(event), started, i8, t4, p13;
    nopropagation3(event);
    for (i8 = 0; i8 < n; ++i8) {
      t4 = touches[i8], p13 = pointer_default(t4, this);
      p13 = [p13, this.__zoom.invert(p13), t4.identifier];
      if (!g15.touch0) g15.touch0 = p13, started = true, g15.taps = 1 + !!touchstarting;
      else if (!g15.touch1 && g15.touch0[2] !== p13[2]) g15.touch1 = p13, g15.taps = 0;
    }
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g15.taps < 2) touchfirst = p13[0], touchstarting = setTimeout(function() {
        touchstarting = null;
      }, touchDelay);
      interrupt_default(this);
      g15.start();
    }
  }
  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g15 = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i8, t4, p13, l7;
    noevent_default3(event);
    for (i8 = 0; i8 < n; ++i8) {
      t4 = touches[i8], p13 = pointer_default(t4, this);
      if (g15.touch0 && g15.touch0[2] === t4.identifier) g15.touch0[0] = p13;
      else if (g15.touch1 && g15.touch1[2] === t4.identifier) g15.touch1[0] = p13;
    }
    t4 = g15.that.__zoom;
    if (g15.touch1) {
      var p0 = g15.touch0[0], l0 = g15.touch0[1], p1 = g15.touch1[0], l1 = g15.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t4 = scale(t4, Math.sqrt(dp / dl));
      p13 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l7 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g15.touch0) p13 = g15.touch0[0], l7 = g15.touch0[1];
    else return;
    g15.zoom("touch", constrain(translate(t4, p13, l7), g15.extent, translateExtent));
  }
  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g15 = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i8, t4;
    nopropagation3(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i8 = 0; i8 < n; ++i8) {
      t4 = touches[i8];
      if (g15.touch0 && g15.touch0[2] === t4.identifier) delete g15.touch0;
      else if (g15.touch1 && g15.touch1[2] === t4.identifier) delete g15.touch1;
    }
    if (g15.touch1 && !g15.touch0) g15.touch0 = g15.touch1, delete g15.touch1;
    if (g15.touch0) g15.touch0[1] = this.__zoom.invert(g15.touch0[0]);
    else {
      g15.end();
      if (g15.taps === 2) {
        t4 = pointer_default(t4, this);
        if (Math.hypot(touchfirst[0] - t4[0], touchfirst[1] - t4[1]) < tapDistance) {
          var p13 = select_default2(this).on("dblclick.zoom");
          if (p13) p13.apply(this, arguments);
        }
      }
    }
  }
  zoom.wheelDelta = function(_17) {
    return arguments.length ? (wheelDelta = typeof _17 === "function" ? _17 : constant_default9(+_17), zoom) : wheelDelta;
  };
  zoom.filter = function(_17) {
    return arguments.length ? (filter3 = typeof _17 === "function" ? _17 : constant_default9(!!_17), zoom) : filter3;
  };
  zoom.touchable = function(_17) {
    return arguments.length ? (touchable = typeof _17 === "function" ? _17 : constant_default9(!!_17), zoom) : touchable;
  };
  zoom.extent = function(_17) {
    return arguments.length ? (extent2 = typeof _17 === "function" ? _17 : constant_default9([[+_17[0][0], +_17[0][1]], [+_17[1][0], +_17[1][1]]]), zoom) : extent2;
  };
  zoom.scaleExtent = function(_17) {
    return arguments.length ? (scaleExtent[0] = +_17[0], scaleExtent[1] = +_17[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom.translateExtent = function(_17) {
    return arguments.length ? (translateExtent[0][0] = +_17[0][0], translateExtent[1][0] = +_17[1][0], translateExtent[0][1] = +_17[0][1], translateExtent[1][1] = +_17[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom.constrain = function(_17) {
    return arguments.length ? (constrain = _17, zoom) : constrain;
  };
  zoom.duration = function(_17) {
    return arguments.length ? (duration = +_17, zoom) : duration;
  };
  zoom.interpolate = function(_17) {
    return arguments.length ? (interpolate = _17, zoom) : interpolate;
  };
  zoom.on = function() {
    var value2 = listeners.on.apply(listeners, arguments);
    return value2 === listeners ? zoom : value2;
  };
  zoom.clickDistance = function(_17) {
    return arguments.length ? (clickDistance2 = (_17 = +_17) * _17, zoom) : Math.sqrt(clickDistance2);
  };
  zoom.tapDistance = function(_17) {
    return arguments.length ? (tapDistance = +_17, zoom) : tapDistance;
  };
  return zoom;
}

// node_modules/topojson-client/src/identity.js
function identity_default8(x21) {
  return x21;
}

// node_modules/topojson-client/src/transform.js
function transform_default2(transform2) {
  if (transform2 == null) return identity_default8;
  var x06, y06, kx4 = transform2.scale[0], ky3 = transform2.scale[1], dx = transform2.translate[0], dy = transform2.translate[1];
  return function(input, i8) {
    if (!i8) x06 = y06 = 0;
    var j6 = 2, n = input.length, output = new Array(n);
    output[0] = (x06 += input[0]) * kx4 + dx;
    output[1] = (y06 += input[1]) * ky3 + dy;
    while (j6 < n) output[j6] = input[j6], ++j6;
    return output;
  };
}

// node_modules/topojson-client/src/reverse.js
function reverse_default3(array3, n) {
  var t4, j6 = array3.length, i8 = j6 - n;
  while (i8 < --j6) t4 = array3[i8], array3[i8++] = array3[j6], array3[j6] = t4;
}

// node_modules/topojson-client/src/feature.js
function feature_default(topology, o2) {
  if (typeof o2 === "string") o2 = topology.objects[o2];
  return o2.type === "GeometryCollection" ? { type: "FeatureCollection", features: o2.geometries.map(function(o3) {
    return feature(topology, o3);
  }) } : feature(topology, o2);
}
function feature(topology, o2) {
  var id2 = o2.id, bbox = o2.bbox, properties = o2.properties == null ? {} : o2.properties, geometry = object(topology, o2);
  return id2 == null && bbox == null ? { type: "Feature", properties, geometry } : bbox == null ? { type: "Feature", id: id2, properties, geometry } : { type: "Feature", id: id2, bbox, properties, geometry };
}
function object(topology, o2) {
  var transformPoint = transform_default2(topology.transform), arcs = topology.arcs;
  function arc2(i8, points3) {
    if (points3.length) points3.pop();
    for (var a7 = arcs[i8 < 0 ? ~i8 : i8], k17 = 0, n = a7.length; k17 < n; ++k17) {
      points3.push(transformPoint(a7[k17], k17));
    }
    if (i8 < 0) reverse_default3(points3, n);
  }
  function point13(p13) {
    return transformPoint(p13);
  }
  function line5(arcs2) {
    var points3 = [];
    for (var i8 = 0, n = arcs2.length; i8 < n; ++i8) arc2(arcs2[i8], points3);
    if (points3.length < 2) points3.push(points3[0]);
    return points3;
  }
  function ring(arcs2) {
    var points3 = line5(arcs2);
    while (points3.length < 4) points3.push(points3[0]);
    return points3;
  }
  function polygon2(arcs2) {
    return arcs2.map(ring);
  }
  function geometry(o3) {
    var type2 = o3.type, coordinates;
    switch (type2) {
      case "GeometryCollection":
        return { type: type2, geometries: o3.geometries.map(geometry) };
      case "Point":
        coordinates = point13(o3.coordinates);
        break;
      case "MultiPoint":
        coordinates = o3.coordinates.map(point13);
        break;
      case "LineString":
        coordinates = line5(o3.arcs);
        break;
      case "MultiLineString":
        coordinates = o3.arcs.map(line5);
        break;
      case "Polygon":
        coordinates = polygon2(o3.arcs);
        break;
      case "MultiPolygon":
        coordinates = o3.arcs.map(polygon2);
        break;
      default:
        return null;
    }
    return { type: type2, coordinates };
  }
  return geometry(o2);
}

// node_modules/@unovis/ts/data-models/map-graph.js
var MapGraphDataModel = class extends CoreDataModel {
  constructor() {
    super(...arguments);
    this._areas = [];
    this._points = [];
    this._links = [];
    this.pointId = (n) => n.id;
    this.linkSource = (l7) => l7.source;
    this.linkTarget = (l7) => l7.target;
  }
  get data() {
    return this._data;
  }
  set data(data) {
    var _a, _b, _c;
    if (!data)
      return;
    this._data = data;
    this._areas = cloneDeep((_a = data === null || data === void 0 ? void 0 : data.areas) !== null && _a !== void 0 ? _a : []);
    this._points = cloneDeep((_b = data === null || data === void 0 ? void 0 : data.points) !== null && _b !== void 0 ? _b : []);
    this._links = cloneDeep((_c = data === null || data === void 0 ? void 0 : data.links) !== null && _c !== void 0 ? _c : []).reduce((arr, link7) => {
      const source = this.findPoint(this.points, this.linkSource(link7));
      const target = this.findPoint(this.points, this.linkTarget(link7));
      if (source && target)
        arr.push({ source, target });
      return arr;
    }, []);
  }
  get areas() {
    return this._areas;
  }
  get points() {
    return this._points;
  }
  get links() {
    return this._links;
  }
  findPoint(points3, pointIdentifier) {
    let foundPoint;
    if (isNumber(pointIdentifier))
      foundPoint = points3[pointIdentifier];
    else if (isString(pointIdentifier))
      foundPoint = points3.find((node4, i8) => this.pointId(node4, i8) === pointIdentifier);
    else if (isObject(pointIdentifier))
      foundPoint = points3.find((node4) => node4 === pointIdentifier);
    if (!foundPoint) {
      console.warn(`Point ${pointIdentifier} is missing from the points list`);
    }
    return foundPoint;
  }
};

// node_modules/@unovis/ts/components/topojson-map/config.js
var TopoJSONMapDefaultConfig = Object.assign(Object.assign({}, ComponentDefaultConfig), { projection: void 0, duration: 1500, topojson: void 0, mapFeatureName: "countries", mapFitToPoints: false, zoomExtent: [0.5, 6], zoomDuration: 400, disableZoom: false, zoomFactor: void 0, linkWidth: (d18) => {
  var _a;
  return (_a = d18.width) !== null && _a !== void 0 ? _a : 1;
}, linkColor: (d18) => {
  var _a;
  return (_a = d18.color) !== null && _a !== void 0 ? _a : null;
}, linkCursor: null, linkId: (d18, i8) => {
  var _a;
  return `${(_a = d18.id) !== null && _a !== void 0 ? _a : i8}`;
}, linkSource: (d18) => d18.source, linkTarget: (d18) => d18.target, areaId: (d18) => {
  var _a;
  return (_a = d18.id) !== null && _a !== void 0 ? _a : "";
}, areaColor: (d18) => {
  var _a;
  return (_a = d18.color) !== null && _a !== void 0 ? _a : null;
}, areaCursor: null, longitude: (d18) => d18.longitude, latitude: (d18) => d18.latitude, pointColor: (d18) => {
  var _a;
  return (_a = d18.color) !== null && _a !== void 0 ? _a : null;
}, pointRadius: (d18) => {
  var _a;
  return (_a = d18.radius) !== null && _a !== void 0 ? _a : 8;
}, pointStrokeWidth: (d18) => {
  var _a;
  return (_a = d18.strokeWidth) !== null && _a !== void 0 ? _a : 0;
}, pointCursor: null, pointLabel: void 0, pointLabelPosition: MapPointLabelPosition.Bottom, pointLabelTextBrightnessRatio: 0.65, pointId: (d18) => d18.id, heatmapMode: false, heatmapModeBlurStdDeviation: 8, heatmapModeZoomLevelThreshold: 2.5 });

// node_modules/@unovis/ts/components/topojson-map/utils.js
function getLonLat(d18, pointLongitude, pointLatitude) {
  const lat = getNumber(d18, pointLatitude);
  const lon = getNumber(d18, pointLongitude);
  return [lon, lat];
}
function arc(source, target, curvature) {
  if (!target || !source)
    return "M0,0,l0,0z";
  const d18 = 3;
  const angleOffset = curvature || 0;
  const s12 = { x: source[0], y: source[1] };
  const t4 = { x: target[0], y: target[1] };
  const ds = { x: (t4.x - s12.x) / d18, y: (t4.y - s12.y) / d18 };
  const dt = { x: (s12.x - t4.x) / d18, y: (s12.y - t4.y) / d18 };
  let angle = 0.16667 * Math.PI * (1 + angleOffset);
  if (s12.x < t4.x)
    angle = -angle;
  const cs = Math.cos(angle);
  const ss = Math.sin(angle);
  const ct = Math.cos(-angle);
  const st = Math.sin(-angle);
  const dds = { x: cs * ds.x - ss * ds.y, y: ss * ds.x + cs * ds.y };
  const ddt = { x: ct * dt.x - st * dt.y, y: st * dt.x + ct * dt.y };
  return `M${s12.x},${s12.y} C${s12.x + dds.x},${s12.y + dds.y} ${t4.x + ddt.x},${t4.y + ddt.y} ${t4.x},${t4.y}`;
}

// node_modules/@unovis/ts/components/topojson-map/style.js
var style_exports14 = {};
__export(style_exports14, {
  background: () => background3,
  feature: () => feature2,
  features: () => features,
  link: () => link4,
  links: () => links2,
  point: () => point11,
  pointCircle: () => pointCircle,
  pointLabel: () => pointLabel,
  points: () => points,
  root: () => root16,
  variables: () => variables8
});
var root16 = css`
  label: topojson-map-component;

  &.draggable {
    &:active {
      cursor: grabbing;
      cursor: -moz-grabbing;
      cursor: -webkit-grabbing;
    }
  }
`;
var variables8 = injectGlobal`
  :root {
    --vis-map-feature-color: #dce3eb;
    --vis-map-boundary-color: #ffffff;

    --vis-map-point-label-text-color-dark: #5b5f6d;
    --vis-map-point-label-text-color-light: #fff;

    // Undefined by default to allow proper fallback to var(--vis-font-family)
    /* --vis-map-point-label-font-family: */
    --vis-map-point-label-font-weight: 600;
    --vis-map-point-label-font-size: 12px;

    /* Dark Theme */
    --vis-dark-map-feature-color: #5b5f6d;
    --vis-dark-map-boundary-color: #2a2a2a;
    --vis-dark-map-point-label-text-color-dark: #fff;
    --vis-dark-map-point-label-text-color-light:#5b5f6d;
  }

  body.theme-dark ${`.${root16}`} {
    --vis-map-feature-color: var(--vis-dark-map-feature-color);
    --vis-map-boundary-color: var(--vis-dark-map-boundary-color);
    --vis-map-point-label-text-color-dark: var(--vis-dark-map-point-label-text-color-dark);
    --vis-map-point-label-text-color-light: var(--vis-dark-map-point-label-text-color-light);
  }
`;
var features = css`
  label: features;
`;
var feature2 = css`
  label: feature;
  fill: var(--vis-map-feature-color);
  stroke: var(--vis-map-boundary-color);
  stroke-opacity: 0.5;
`;
var background3 = css`
  label: background;

  fill-opacity: 0;
  pointer-events: all;
`;
var points = css`
  label: points;
`;
var point11 = css`
  label: point;
`;
var pointCircle = css`
  label: point;

  stroke-opacity: 0.4;
  pointer-events: fill;

  &:active {
    cursor: default;
  }
`;
var pointLabel = css`
  label: label;

  text-anchor: middle;
  cursor: default;
  pointer-events:none;

  font-size: var(--vis-map-point-label-font-size);
  font-family: var(--vis-map-point-label-font-family, var(--vis-font-family));
  font-weight: var(--vis-map-point-label-font-weight);
  fill: var(--vis-map-point-label-text-color-dark);
`;
var links2 = css`
  label: links;
`;
var link4 = css`
  label: link;

  fill: none;
  stroke-opacity: .50;
  stroke-linecap: round;

  &:hover {
    stroke-opacity: .90;
  }
`;

// node_modules/@unovis/ts/components/topojson-map/index.js
var TopoJSONMap = class _TopoJSONMap extends ComponentCore {
  constructor(config, data) {
    super();
    this._defaultConfig = TopoJSONMapDefaultConfig;
    this.config = this._defaultConfig;
    this.datamodel = new MapGraphDataModel();
    this._firstRender = true;
    this._isResizing = false;
    this._initialScale = void 0;
    this._currentZoomLevel = void 0;
    this._path = path_default();
    this._zoomBehavior = zoom_default2();
    this._backgroundRect = this.g.append("rect").attr("class", background3);
    this._featuresGroup = this.g.append("g").attr("class", features);
    this._linksGroup = this.g.append("g").attr("class", links2);
    this._pointsGroup = this.g.append("g").attr("class", points);
    this.events = {
      [_TopoJSONMap.selectors.point]: {},
      [_TopoJSONMap.selectors.feature]: {}
    };
    this._zoomBehavior.on("zoom", this._onZoom.bind(this));
    if (config)
      this.setConfig(config);
    if (data)
      this.setData(data);
    this.g.append("defs").append("filter").attr("id", "heatmapFilter").html(`
        <feGaussianBlur in="SourceGraphic" stdDeviation="${this.config.heatmapModeBlurStdDeviation}" color-interpolation-filters="sRGB" result="blur"></feGaussianBlur>
        <feColorMatrix class="blurValues" in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 20 -4"></feColorMatrix>
      `);
  }
  setData(data) {
    const { config } = this;
    this.datamodel.pointId = config.pointId;
    this.datamodel.linkSource = config.linkSource;
    this.datamodel.linkTarget = config.linkTarget;
    this.datamodel.data = data;
    this._firstRender = this._firstRender || config.mapFitToPoints;
  }
  setConfig(config) {
    var _a;
    super.setConfig(config);
    const newProjection = (_a = this.config.projection) !== null && _a !== void 0 ? _a : MapProjection.Kavrayskiy7();
    if (this._projection) {
      newProjection.scale(this._projection.scale()).translate(this._projection.translate());
    }
    this._projection = newProjection;
  }
  _render(customDuration) {
    const { config } = this;
    const duration = isNumber(customDuration) ? customDuration : config.duration;
    this._renderBackground();
    this._renderMap(duration);
    this._renderGroups(duration);
    this._renderLinks(duration);
    this._renderPoints(duration);
    if (duration && !config.disableZoom) {
      this.g.on(".zoom", null);
      timeout_default(() => {
        this.g.call(this._zoomBehavior);
      }, duration);
    }
    this.g.classed("draggable", !config.disableZoom);
    this._firstRender = false;
  }
  _renderBackground() {
    this._backgroundRect.attr("width", "100%").attr("height", "100%").attr("transform", `translate(${-this.bleed.left}, ${-this.bleed.top})`);
  }
  _renderGroups(duration) {
    const transformString = this._transform.toString();
    smartTransition(this._featuresGroup, duration).attr("transform", transformString).attr("stroke-width", 1 / this._currentZoomLevel);
    smartTransition(this._linksGroup, duration).attr("transform", transformString);
    smartTransition(this._pointsGroup, duration).attr("transform", transformString);
  }
  _renderMap(duration) {
    var _a, _b, _c;
    const { bleed, config, datamodel } = this;
    this.g.attr("transform", `translate(${bleed.left}, ${bleed.top})`);
    const mapData = config.topojson;
    const featureName = config.mapFeatureName;
    const featureObject = (_a = mapData === null || mapData === void 0 ? void 0 : mapData.objects) === null || _a === void 0 ? void 0 : _a[featureName];
    if (!featureObject)
      return;
    this._featureCollection = feature_default(mapData, featureObject);
    const featureData = (_c = (_b = this._featureCollection) === null || _b === void 0 ? void 0 : _b.features) !== null && _c !== void 0 ? _c : [];
    if (this._firstRender) {
      this._projection.fitExtent([[0, 0], [this._width, this._height]], this._featureCollection);
      this._initialScale = this._projection.scale();
      this._center = this._projection.translate();
      if (config.mapFitToPoints) {
        this._fitToPoints();
      }
      const zoomExtent = config.zoomExtent;
      this._zoomBehavior.scaleExtent([zoomExtent[0] * this._initialScale, zoomExtent[1] * this._initialScale]);
      this.setZoom(config.zoomFactor || 1);
      if (!config.disableZoom) {
        this.g.call(this._zoomBehavior);
        this._applyZoom();
      }
      this._prevWidth = this._width;
      this._prevHeight = this._height;
    }
    if (this._prevWidth !== this._width || this._prevHeight !== this._height) {
      this._onResize();
    }
    this._path.projection(this._projection);
    const areaData = datamodel.areas;
    areaData.forEach((a7) => {
      const feature3 = featureData.find((f29) => f29.id.toString() === getString(a7, config.areaId).toString());
      if (feature3)
        feature3.data = a7;
      else if (this._firstRender)
        console.warn(`Can't find feature by area code ${getString(a7, config.areaId)}`);
    });
    const features2 = this._featuresGroup.selectAll(`.${feature2}`).data(featureData);
    const featuresEnter = features2.enter().append("path").attr("class", feature2);
    smartTransition(featuresEnter.merge(features2), duration).attr("d", this._path).style("fill", (d18, i8) => d18.data ? getColor(d18.data, config.areaColor, i8) : null).style("cursor", (d18) => d18.data ? getString(d18.data, config.areaCursor) : null);
    features2.exit().remove();
  }
  _renderLinks(duration) {
    const { config, datamodel } = this;
    const links5 = datamodel.links;
    const edges = this._linksGroup.selectAll(`.${link4}`).data(links5, (d18, i8) => getString(d18, config.linkId, i8));
    const edgesEnter = edges.enter().append("path").attr("class", link4).style("stroke-width", 0);
    smartTransition(edgesEnter.merge(edges), duration).attr("d", (link7) => {
      const source = this._projection(getLonLat(link7.source, config.longitude, config.latitude));
      const target = this._projection(getLonLat(link7.target, config.longitude, config.latitude));
      return arc(source, target);
    }).style("stroke-width", (link7) => getNumber(link7, config.linkWidth) / this._currentZoomLevel).style("cursor", (link7) => getString(link7, config.linkCursor)).style("stroke", (link7, i8) => getColor(link7, config.linkColor, i8));
    edges.exit().remove();
  }
  _renderPoints(duration) {
    const { config, datamodel } = this;
    const pointData = datamodel.points;
    const points3 = this._pointsGroup.selectAll(`.${point11}`).data(pointData, (d18, i8) => getString(d18, config.pointId, i8));
    const pointsEnter = points3.enter().append("g").attr("class", point11).attr("transform", (d18) => {
      const pos = this._projection(getLonLat(d18, config.longitude, config.latitude));
      return `translate(${pos[0]},${pos[1]})`;
    }).style("opacity", 0);
    pointsEnter.append("circle").attr("class", pointCircle).attr("r", 0).style("fill", (d18, i8) => getColor(d18, config.pointColor, i8)).style("stroke-width", (d18) => getNumber(d18, config.pointStrokeWidth));
    pointsEnter.append("text").attr("class", pointLabel).style("opacity", 0);
    const pointsMerged = pointsEnter.merge(points3);
    smartTransition(pointsMerged, duration).attr("transform", (d18) => {
      const pos = this._projection(getLonLat(d18, config.longitude, config.latitude));
      return `translate(${pos[0]},${pos[1]})`;
    }).style("cursor", (d18) => getString(d18, config.pointCursor)).style("opacity", 1);
    smartTransition(pointsMerged.select(`.${pointCircle}`), duration).attr("r", (d18) => getNumber(d18, config.pointRadius) / this._currentZoomLevel).style("fill", (d18, i8) => getColor(d18, config.pointColor, i8)).style("stroke", (d18, i8) => getColor(d18, config.pointColor, i8)).style("stroke-width", (d18) => getNumber(d18, config.pointStrokeWidth) / this._currentZoomLevel);
    const pointLabelsMerged = pointsMerged.select(`.${pointLabel}`);
    pointLabelsMerged.text((d18) => {
      var _a;
      return (_a = getString(d18, config.pointLabel)) !== null && _a !== void 0 ? _a : "";
    }).style("font-size", (d18) => {
      if (config.pointLabelPosition === MapPointLabelPosition.Bottom) {
        return `calc(var(--vis-map-point-label-font-size) / ${this._currentZoomLevel}`;
      }
      const pointDiameter = 2 * getNumber(d18, config.pointRadius);
      const pointLabelText = getString(d18, config.pointLabel) || "";
      const textLength = pointLabelText.length;
      const fontSize = 0.5 * pointDiameter / Math.pow(textLength, 0.4);
      return clamp(fontSize, fontSize, 16);
    }).attr("y", (d18) => {
      if (config.pointLabelPosition === MapPointLabelPosition.Center)
        return null;
      const pointRadius = getNumber(d18, config.pointRadius) / this._currentZoomLevel;
      return pointRadius;
    }).attr("dy", config.pointLabelPosition === MapPointLabelPosition.Center ? "0.32em" : "1em");
    smartTransition(pointLabelsMerged, duration).style("fill", (d18, i8) => {
      var _a;
      if (config.pointLabelPosition === MapPointLabelPosition.Bottom)
        return null;
      const pointColor = getColor(d18, config.pointColor, i8);
      const hex2 = (_a = color(isStringCSSVariable(pointColor) ? getCSSVariableValue(pointColor, this.element) : pointColor)) === null || _a === void 0 ? void 0 : _a.hex();
      if (!hex2)
        return null;
      const brightness = hexToBrightness(hex2);
      return brightness > config.pointLabelTextBrightnessRatio ? "var(--vis-map-point-label-text-color-dark)" : "var(--vis-map-point-label-text-color-light)";
    }).style("opacity", 1);
    points3.exit().remove();
    this._pointsGroup.style("filter", config.heatmapMode && this._currentZoomLevel < config.heatmapModeZoomLevelThreshold ? "url(#heatmapFilter)" : null);
    this._pointsGroup.selectAll(`.${pointLabel}`).style("display", config.heatmapMode && this._currentZoomLevel < config.heatmapModeZoomLevelThreshold ? "none" : null);
  }
  _fitToPoints(points3, pad2 = 0.1) {
    const { config, datamodel } = this;
    const pointData = points3 || datamodel.points;
    if (pointData.length === 0)
      return;
    this.fitView();
    const featureCollection = {
      type: "FeatureCollection",
      features: [{
        type: "Feature",
        properties: {},
        geometry: {
          type: "MultiPoint",
          coordinates: pointData.map((p13) => {
            return [
              getNumber(p13, (d18) => getNumber(d18, config.longitude)),
              getNumber(p13, (d18) => getNumber(d18, config.latitude))
            ];
          })
        }
      }]
    };
    this._projection.fitExtent([
      [this._width * pad2, this._height * pad2],
      [this._width * (1 - pad2), this._height * (1 - pad2)]
    ], featureCollection);
    const maxScale = config.zoomExtent[1] * this._initialScale;
    const fittedScale = this._projection.scale();
    if (fittedScale > maxScale) {
      const fittedTranslate = this._projection.translate();
      const scaleRatio = maxScale / fittedScale;
      this._projection.scale(maxScale);
      this._projection.translate([
        this._width / 2 - (this._width / 2 - fittedTranslate[0]) * scaleRatio,
        this._height / 2 - (this._height / 2 - fittedTranslate[1]) * scaleRatio
      ]);
    }
    this._center = this._projection.translate();
    this._applyZoom();
  }
  _applyZoom() {
    var _a;
    const translate = (_a = this._center) !== null && _a !== void 0 ? _a : this._projection.translate();
    const scale = this._initialScale * this._currentZoomLevel;
    this.g.call(this._zoomBehavior.transform, identity4.translate(translate[0], translate[1]).scale(scale));
  }
  _onResize() {
    this._isResizing = true;
    const prevTranslate = this._projection.translate();
    this._projection.fitExtent([[0, 0], [this._width, this._height]], this._featureCollection);
    this._initialScale = this._projection.scale();
    this._center = [
      this._projection.translate()[0] * this._center[0] / prevTranslate[0],
      this._projection.translate()[1] * this._center[1] / prevTranslate[1]
    ];
    this._applyZoom();
    this._isResizing = false;
    this._prevWidth = this._width;
    this._prevHeight = this._height;
  }
  _onZoom(event) {
    if (this._firstRender)
      return;
    const isMouseEvent = event.sourceEvent !== void 0;
    const isExternalEvent = !(event === null || event === void 0 ? void 0 : event.sourceEvent) && !this._isResizing;
    window.cancelAnimationFrame(this._animFrameId);
    this._animFrameId = window.requestAnimationFrame(this._onZoomHandler.bind(this, event.transform, isMouseEvent, isExternalEvent));
    if (isMouseEvent) {
      this._center = [event.transform.x, event.transform.y];
    }
    this._currentZoomLevel = (event === null || event === void 0 ? void 0 : event.transform.k) / this._initialScale || 1;
  }
  _onZoomHandler(transform2, isMouseEvent, isExternalEvent) {
    const scale = transform2.k / this._initialScale || 1;
    const center3 = this._projection.translate();
    this._transform = identity4.translate(transform2.x - center3[0] * scale, transform2.y - center3[1] * scale).scale(scale);
    const customDuration = isExternalEvent ? this.config.zoomDuration : isMouseEvent ? 0 : null;
    this._renderGroups(customDuration);
    this._renderLinks(customDuration);
    this._renderPoints(customDuration);
  }
  zoomIn(increment = 0.5) {
    this.setZoom(this._currentZoomLevel + increment);
  }
  zoomOut(increment = 0.5) {
    this.setZoom(this._currentZoomLevel - increment);
  }
  setZoom(zoomLevel) {
    const { config } = this;
    this._currentZoomLevel = clamp(zoomLevel, config.zoomExtent[0], config.zoomExtent[1]);
    this._transform = identity4.translate(this._center[0] * (1 - this._currentZoomLevel), this._center[1] * (1 - this._currentZoomLevel)).scale(this._currentZoomLevel);
    this._applyZoom();
  }
  fitView() {
    var _a;
    this._projection.fitExtent([[0, 0], [this._width, this._height]], this._featureCollection);
    this._currentZoomLevel = ((_a = this._projection) === null || _a === void 0 ? void 0 : _a.scale()) / this._initialScale || 1;
    this._center = this._projection.translate();
    this._applyZoom();
  }
  destroy() {
    window.cancelAnimationFrame(this._animFrameId);
  }
};
TopoJSONMap.selectors = style_exports14;

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count2(node4) {
  var sum5 = 0, children2 = node4.children, i8 = children2 && children2.length;
  if (!i8) sum5 = 1;
  else while (--i8 >= 0) sum5 += children2[i8].value;
  node4.value = sum5;
}
function count_default() {
  return this.eachAfter(count2);
}

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default2(callback, that) {
  let index3 = -1;
  for (const node4 of this) {
    callback.call(that, node4, ++index3, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node4 = this, nodes4 = [node4], children2, i8, index3 = -1;
  while (node4 = nodes4.pop()) {
    callback.call(that, node4, ++index3, this);
    if (children2 = node4.children) {
      for (i8 = children2.length - 1; i8 >= 0; --i8) {
        nodes4.push(children2[i8]);
      }
    }
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node4 = this, nodes4 = [node4], next = [], children2, i8, n, index3 = -1;
  while (node4 = nodes4.pop()) {
    next.push(node4);
    if (children2 = node4.children) {
      for (i8 = 0, n = children2.length; i8 < n; ++i8) {
        nodes4.push(children2[i8]);
      }
    }
  }
  while (node4 = next.pop()) {
    callback.call(that, node4, ++index3, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default(callback, that) {
  let index3 = -1;
  for (const node4 of this) {
    if (callback.call(that, node4, ++index3, this)) {
      return node4;
    }
  }
}

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value2) {
  return this.eachAfter(function(node4) {
    var sum5 = +value2(node4.data) || 0, children2 = node4.children, i8 = children2 && children2.length;
    while (--i8 >= 0) sum5 += children2[i8].value;
    node4.value = sum5;
  });
}

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default2(compare) {
  return this.eachBefore(function(node4) {
    if (node4.children) {
      node4.children.sort(compare);
    }
  });
}

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default3(end) {
  var start2 = this, ancestor = leastCommonAncestor(start2, end), nodes4 = [start2];
  while (start2 !== ancestor) {
    start2 = start2.parent;
    nodes4.push(start2);
  }
  var k17 = nodes4.length;
  while (end !== ancestor) {
    nodes4.splice(k17, 0, end);
    end = end.parent;
  }
  return nodes4;
}
function leastCommonAncestor(a7, b25) {
  if (a7 === b25) return a7;
  var aNodes = a7.ancestors(), bNodes = b25.ancestors(), c6 = null;
  a7 = aNodes.pop();
  b25 = bNodes.pop();
  while (a7 === b25) {
    c6 = a7;
    a7 = aNodes.pop();
    b25 = bNodes.pop();
  }
  return c6;
}

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node4 = this, nodes4 = [node4];
  while (node4 = node4.parent) {
    nodes4.push(node4);
  }
  return nodes4;
}

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node4) {
    if (!node4.children) {
      leaves.push(node4);
    }
  });
  return leaves;
}

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root29 = this, links5 = [];
  root29.each(function(node4) {
    if (node4 !== root29) {
      links5.push({ source: node4.parent, target: node4 });
    }
  });
  return links5;
}

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default2() {
  var node4 = this, current, next = [node4], children2, i8, n;
  do {
    current = next.reverse(), next = [];
    while (node4 = current.pop()) {
      yield node4;
      if (children2 = node4.children) {
        for (i8 = 0, n = children2.length; i8 < n; ++i8) {
          next.push(children2[i8]);
        }
      }
    }
  } while (next.length);
}

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data, children2) {
  if (data instanceof Map) {
    data = [void 0, data];
    if (children2 === void 0) children2 = mapChildren;
  } else if (children2 === void 0) {
    children2 = objectChildren;
  }
  var root29 = new Node(data), node4, nodes4 = [root29], child, childs, i8, n;
  while (node4 = nodes4.pop()) {
    if ((childs = children2(node4.data)) && (n = (childs = Array.from(childs)).length)) {
      node4.children = childs;
      for (i8 = n - 1; i8 >= 0; --i8) {
        nodes4.push(child = childs[i8] = new Node(childs[i8]));
        child.parent = node4;
        child.depth = node4.depth + 1;
      }
    }
  }
  return root29.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d18) {
  return d18.children;
}
function mapChildren(d18) {
  return Array.isArray(d18) ? d18[1] : null;
}
function copyData(node4) {
  if (node4.data.value !== void 0) node4.value = node4.data.value;
  node4.data = node4.data.data;
}
function computeHeight(node4) {
  var height = 0;
  do
    node4.height = height;
  while ((node4 = node4.parent) && node4.height < ++height);
}
function Node(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: count_default,
  each: each_default2,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default,
  sum: sum_default,
  sort: sort_default2,
  path: path_default3,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default2
};

// node_modules/d3-hierarchy/src/accessors.js
function required(f29) {
  if (typeof f29 !== "function") throw new Error();
  return f29;
}

// node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
function constant_default10(x21) {
  return function() {
    return x21;
  };
}

// node_modules/d3-hierarchy/src/lcg.js
var a3 = 1664525;
var c2 = 1013904223;
var m = 4294967296;
function lcg_default() {
  let s12 = 1;
  return () => (s12 = (a3 * s12 + c2) % m) / m;
}

// node_modules/d3-hierarchy/src/array.js
function array_default3(x21) {
  return typeof x21 === "object" && "length" in x21 ? x21 : Array.from(x21);
}
function shuffle(array3, random) {
  let m30 = array3.length, t4, i8;
  while (m30) {
    i8 = random() * m30-- | 0;
    t4 = array3[m30];
    array3[m30] = array3[i8];
    array3[i8] = t4;
  }
  return array3;
}

// node_modules/d3-hierarchy/src/pack/enclose.js
function packEncloseRandom(circles, random) {
  var i8 = 0, n = (circles = shuffle(Array.from(circles), random)).length, B12 = [], p13, e3;
  while (i8 < n) {
    p13 = circles[i8];
    if (e3 && enclosesWeak(e3, p13)) ++i8;
    else e3 = encloseBasis(B12 = extendBasis(B12, p13)), i8 = 0;
  }
  return e3;
}
function extendBasis(B12, p13) {
  var i8, j6;
  if (enclosesWeakAll(p13, B12)) return [p13];
  for (i8 = 0; i8 < B12.length; ++i8) {
    if (enclosesNot(p13, B12[i8]) && enclosesWeakAll(encloseBasis2(B12[i8], p13), B12)) {
      return [B12[i8], p13];
    }
  }
  for (i8 = 0; i8 < B12.length - 1; ++i8) {
    for (j6 = i8 + 1; j6 < B12.length; ++j6) {
      if (enclosesNot(encloseBasis2(B12[i8], B12[j6]), p13) && enclosesNot(encloseBasis2(B12[i8], p13), B12[j6]) && enclosesNot(encloseBasis2(B12[j6], p13), B12[i8]) && enclosesWeakAll(encloseBasis3(B12[i8], B12[j6], p13), B12)) {
        return [B12[i8], B12[j6], p13];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a7, b25) {
  var dr = a7.r - b25.r, dx = b25.x - a7.x, dy = b25.y - a7.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a7, b25) {
  var dr = a7.r - b25.r + Math.max(a7.r, b25.r, 1) * 1e-9, dx = b25.x - a7.x, dy = b25.y - a7.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a7, B12) {
  for (var i8 = 0; i8 < B12.length; ++i8) {
    if (!enclosesWeak(a7, B12[i8])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B12) {
  switch (B12.length) {
    case 1:
      return encloseBasis1(B12[0]);
    case 2:
      return encloseBasis2(B12[0], B12[1]);
    case 3:
      return encloseBasis3(B12[0], B12[1], B12[2]);
  }
}
function encloseBasis1(a7) {
  return {
    x: a7.x,
    y: a7.y,
    r: a7.r
  };
}
function encloseBasis2(a7, b25) {
  var x110 = a7.x, y110 = a7.y, r1 = a7.r, x22 = b25.x, y25 = b25.y, r22 = b25.r, x21 = x22 - x110, y212 = y25 - y110, r21 = r22 - r1, l7 = Math.sqrt(x21 * x21 + y212 * y212);
  return {
    x: (x110 + x22 + x21 / l7 * r21) / 2,
    y: (y110 + y25 + y212 / l7 * r21) / 2,
    r: (l7 + r1 + r22) / 2
  };
}
function encloseBasis3(a7, b25, c6) {
  var x110 = a7.x, y110 = a7.y, r1 = a7.r, x22 = b25.x, y25 = b25.y, r22 = b25.r, x32 = c6.x, y32 = c6.y, r32 = c6.r, a22 = x110 - x22, a32 = x110 - x32, b26 = y110 - y25, b32 = y110 - y32, c22 = r22 - r1, c32 = r32 - r1, d1 = x110 * x110 + y110 * y110 - r1 * r1, d22 = d1 - x22 * x22 - y25 * y25 + r22 * r22, d32 = d1 - x32 * x32 - y32 * y32 + r32 * r32, ab = a32 * b26 - a22 * b32, xa = (b26 * d32 - b32 * d22) / (ab * 2) - x110, xb = (b32 * c22 - b26 * c32) / ab, ya = (a32 * d22 - a22 * d32) / (ab * 2) - y110, yb = (a22 * c32 - a32 * c22) / ab, A8 = xb * xb + yb * yb - 1, B12 = 2 * (r1 + xa * xb + ya * yb), C10 = xa * xa + ya * ya - r1 * r1, r4 = -(Math.abs(A8) > 1e-6 ? (B12 + Math.sqrt(B12 * B12 - 4 * A8 * C10)) / (2 * A8) : C10 / B12);
  return {
    x: x110 + xa + xb * r4,
    y: y110 + ya + yb * r4,
    r: r4
  };
}

// node_modules/d3-hierarchy/src/pack/siblings.js
function place(b25, a7, c6) {
  var dx = b25.x - a7.x, x21, a22, dy = b25.y - a7.y, y25, b26, d22 = dx * dx + dy * dy;
  if (d22) {
    a22 = a7.r + c6.r, a22 *= a22;
    b26 = b25.r + c6.r, b26 *= b26;
    if (a22 > b26) {
      x21 = (d22 + b26 - a22) / (2 * d22);
      y25 = Math.sqrt(Math.max(0, b26 / d22 - x21 * x21));
      c6.x = b25.x - x21 * dx - y25 * dy;
      c6.y = b25.y - x21 * dy + y25 * dx;
    } else {
      x21 = (d22 + a22 - b26) / (2 * d22);
      y25 = Math.sqrt(Math.max(0, a22 / d22 - x21 * x21));
      c6.x = a7.x + x21 * dx - y25 * dy;
      c6.y = a7.y + x21 * dy + y25 * dx;
    }
  } else {
    c6.x = a7.x + c6.r;
    c6.y = a7.y;
  }
}
function intersects(a7, b25) {
  var dr = a7.r + b25.r - 1e-6, dx = b25.x - a7.x, dy = b25.y - a7.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node4) {
  var a7 = node4._, b25 = node4.next._, ab = a7.r + b25.r, dx = (a7.x * b25.r + b25.x * a7.r) / ab, dy = (a7.y * b25.r + b25.y * a7.r) / ab;
  return dx * dx + dy * dy;
}
function Node2(circle2) {
  this._ = circle2;
  this.next = null;
  this.previous = null;
}
function packSiblingsRandom(circles, random) {
  if (!(n = (circles = array_default3(circles)).length)) return 0;
  var a7, b25, c6, n, aa, ca, i8, j6, k17, sj, sk;
  a7 = circles[0], a7.x = 0, a7.y = 0;
  if (!(n > 1)) return a7.r;
  b25 = circles[1], a7.x = -b25.r, b25.x = a7.r, b25.y = 0;
  if (!(n > 2)) return a7.r + b25.r;
  place(b25, a7, c6 = circles[2]);
  a7 = new Node2(a7), b25 = new Node2(b25), c6 = new Node2(c6);
  a7.next = c6.previous = b25;
  b25.next = a7.previous = c6;
  c6.next = b25.previous = a7;
  pack: for (i8 = 3; i8 < n; ++i8) {
    place(a7._, b25._, c6 = circles[i8]), c6 = new Node2(c6);
    j6 = b25.next, k17 = a7.previous, sj = b25._.r, sk = a7._.r;
    do {
      if (sj <= sk) {
        if (intersects(j6._, c6._)) {
          b25 = j6, a7.next = b25, b25.previous = a7, --i8;
          continue pack;
        }
        sj += j6._.r, j6 = j6.next;
      } else {
        if (intersects(k17._, c6._)) {
          a7 = k17, a7.next = b25, b25.previous = a7, --i8;
          continue pack;
        }
        sk += k17._.r, k17 = k17.previous;
      }
    } while (j6 !== k17.next);
    c6.previous = a7, c6.next = b25, a7.next = b25.previous = b25 = c6;
    aa = score(a7);
    while ((c6 = c6.next) !== b25) {
      if ((ca = score(c6)) < aa) {
        a7 = c6, aa = ca;
      }
    }
    b25 = a7.next;
  }
  a7 = [b25._], c6 = b25;
  while ((c6 = c6.next) !== b25) a7.push(c6._);
  c6 = packEncloseRandom(a7, random);
  for (i8 = 0; i8 < n; ++i8) a7 = circles[i8], a7.x -= c6.x, a7.y -= c6.y;
  return c6.r;
}
function siblings_default(circles) {
  packSiblingsRandom(circles, lcg_default());
  return circles;
}

// node_modules/d3-hierarchy/src/treemap/round.js
function round_default2(node4) {
  node4.x0 = Math.round(node4.x0);
  node4.y0 = Math.round(node4.y0);
  node4.x1 = Math.round(node4.x1);
  node4.y1 = Math.round(node4.y1);
}

// node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x06, y06, x110, y110) {
  var nodes4 = parent.children, node4, i8 = -1, n = nodes4.length, k17 = parent.value && (x110 - x06) / parent.value;
  while (++i8 < n) {
    node4 = nodes4[i8], node4.y0 = y06, node4.y1 = y110;
    node4.x0 = x06, node4.x1 = x06 += node4.value * k17;
  }
}

// node_modules/d3-hierarchy/src/partition.js
function partition_default() {
  var dx = 1, dy = 1, padding = 0, round2 = false;
  function partition(root29) {
    var n = root29.height + 1;
    root29.x0 = root29.y0 = padding;
    root29.x1 = dx;
    root29.y1 = dy / n;
    root29.eachBefore(positionNode(dy, n));
    if (round2) root29.eachBefore(round_default2);
    return root29;
  }
  function positionNode(dy2, n) {
    return function(node4) {
      if (node4.children) {
        dice_default(node4, node4.x0, dy2 * (node4.depth + 1) / n, node4.x1, dy2 * (node4.depth + 2) / n);
      }
      var x06 = node4.x0, y06 = node4.y0, x110 = node4.x1 - padding, y110 = node4.y1 - padding;
      if (x110 < x06) x06 = x110 = (x06 + x110) / 2;
      if (y110 < y06) y06 = y110 = (y06 + y110) / 2;
      node4.x0 = x06;
      node4.y0 = y06;
      node4.x1 = x110;
      node4.y1 = y110;
    };
  }
  partition.round = function(x21) {
    return arguments.length ? (round2 = !!x21, partition) : round2;
  };
  partition.size = function(x21) {
    return arguments.length ? (dx = +x21[0], dy = +x21[1], partition) : [dx, dy];
  };
  partition.padding = function(x21) {
    return arguments.length ? (padding = +x21, partition) : padding;
  };
  return partition;
}

// node_modules/d3-hierarchy/src/tree.js
function TreeNode(node4, i8) {
  this._ = node4;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i8;
}
TreeNode.prototype = Object.create(Node.prototype);

// node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x06, y06, x110, y110) {
  var nodes4 = parent.children, node4, i8 = -1, n = nodes4.length, k17 = parent.value && (y110 - y06) / parent.value;
  while (++i8 < n) {
    node4 = nodes4[i8], node4.x0 = x06, node4.x1 = x110;
    node4.y0 = y06, node4.y1 = y06 += node4.value * k17;
  }
}

// node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x06, y06, x110, y110) {
  var rows2 = [], nodes4 = parent.children, row2, nodeValue, i0 = 0, i1 = 0, n = nodes4.length, dx, dy, value2 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x110 - x06, dy = y110 - y06;
    do
      sumValue = nodes4[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value2 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes4[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows2.push(row2 = { value: sumValue, dice: dx < dy, children: nodes4.slice(i0, i1) });
    if (row2.dice) dice_default(row2, x06, y06, x110, value2 ? y06 += dy * sumValue / value2 : y110);
    else slice_default(row2, x06, y06, value2 ? x06 += dx * sumValue / value2 : x110, y110);
    value2 -= sumValue, i0 = i1;
  }
  return rows2;
}
var squarify_default = (function custom24(ratio) {
  function squarify(parent, x06, y06, x110, y110) {
    squarifyRatio(ratio, parent, x06, y06, x110, y110);
  }
  squarify.ratio = function(x21) {
    return custom24((x21 = +x21) > 1 ? x21 : 1);
  };
  return squarify;
})(phi);

// node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
  var tile2 = squarify_default, round2 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root29) {
    root29.x0 = root29.y0 = 0;
    root29.x1 = dx;
    root29.y1 = dy;
    root29.eachBefore(positionNode);
    paddingStack = [0];
    if (round2) root29.eachBefore(round_default2);
    return root29;
  }
  function positionNode(node4) {
    var p13 = paddingStack[node4.depth], x06 = node4.x0 + p13, y06 = node4.y0 + p13, x110 = node4.x1 - p13, y110 = node4.y1 - p13;
    if (x110 < x06) x06 = x110 = (x06 + x110) / 2;
    if (y110 < y06) y06 = y110 = (y06 + y110) / 2;
    node4.x0 = x06;
    node4.y0 = y06;
    node4.x1 = x110;
    node4.y1 = y110;
    if (node4.children) {
      p13 = paddingStack[node4.depth + 1] = paddingInner(node4) / 2;
      x06 += paddingLeft(node4) - p13;
      y06 += paddingTop(node4) - p13;
      x110 -= paddingRight(node4) - p13;
      y110 -= paddingBottom(node4) - p13;
      if (x110 < x06) x06 = x110 = (x06 + x110) / 2;
      if (y110 < y06) y06 = y110 = (y06 + y110) / 2;
      tile2(node4, x06, y06, x110, y110);
    }
  }
  treemap.round = function(x21) {
    return arguments.length ? (round2 = !!x21, treemap) : round2;
  };
  treemap.size = function(x21) {
    return arguments.length ? (dx = +x21[0], dy = +x21[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x21) {
    return arguments.length ? (tile2 = required(x21), treemap) : tile2;
  };
  treemap.padding = function(x21) {
    return arguments.length ? treemap.paddingInner(x21).paddingOuter(x21) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x21) {
    return arguments.length ? (paddingInner = typeof x21 === "function" ? x21 : constant_default10(+x21), treemap) : paddingInner;
  };
  treemap.paddingOuter = function(x21) {
    return arguments.length ? treemap.paddingTop(x21).paddingRight(x21).paddingBottom(x21).paddingLeft(x21) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x21) {
    return arguments.length ? (paddingTop = typeof x21 === "function" ? x21 : constant_default10(+x21), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x21) {
    return arguments.length ? (paddingRight = typeof x21 === "function" ? x21 : constant_default10(+x21), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x21) {
    return arguments.length ? (paddingBottom = typeof x21 === "function" ? x21 : constant_default10(+x21), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x21) {
    return arguments.length ? (paddingLeft = typeof x21 === "function" ? x21 : constant_default10(+x21), treemap) : paddingLeft;
  };
  return treemap;
}

// node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default = (function custom25(ratio) {
  function resquarify(parent, x06, y06, x110, y110) {
    if ((rows2 = parent._squarify) && rows2.ratio === ratio) {
      var rows2, row2, nodes4, i8, j6 = -1, n, m30 = rows2.length, value2 = parent.value;
      while (++j6 < m30) {
        row2 = rows2[j6], nodes4 = row2.children;
        for (i8 = row2.value = 0, n = nodes4.length; i8 < n; ++i8) row2.value += nodes4[i8].value;
        if (row2.dice) dice_default(row2, x06, y06, x110, value2 ? y06 += (y110 - y06) * row2.value / value2 : y110);
        else slice_default(row2, x06, y06, value2 ? x06 += (x110 - x06) * row2.value / value2 : x110, y110);
        value2 -= row2.value;
      }
    } else {
      parent._squarify = rows2 = squarifyRatio(ratio, parent, x06, y06, x110, y110);
      rows2.ratio = ratio;
    }
  }
  resquarify.ratio = function(x21) {
    return custom25((x21 = +x21) > 1 ? x21 : 1);
  };
  return resquarify;
})(phi);

// node_modules/@unovis/ts/utils/map.js
function getDataLatLngBounds(data, pointLatitude, pointLongitude, paddingDegrees = 1) {
  const northWest = {
    lat: max(data !== null && data !== void 0 ? data : [], (d18) => getNumber(d18, pointLatitude)),
    lng: min(data !== null && data !== void 0 ? data : [], (d18) => getNumber(d18, pointLongitude))
  };
  const southEast = {
    lat: min(data !== null && data !== void 0 ? data : [], (d18) => getNumber(d18, pointLatitude)),
    lng: max(data !== null && data !== void 0 ? data : [], (d18) => getNumber(d18, pointLongitude))
  };
  return [
    [northWest.lat + paddingDegrees || 90, northWest.lng - paddingDegrees || -180],
    [southEast.lat - paddingDegrees || -70, southEast.lng + paddingDegrees || 180]
  ];
}

// node_modules/@unovis/ts/data-models/map.js
var MapDataModel = class extends CoreDataModel {
  getDataLatLngBounds(pointLatitude, pointLongitude, paddingDegrees = 1) {
    return getDataLatLngBounds(this.data, pointLatitude, pointLongitude, paddingDegrees);
  }
};

// node_modules/@unovis/ts/components/leaflet-map/renderer/mapboxgl-utils.js
function constraintMapView(map5, latMin = -75, latMax = 85) {
  const bounds = map5.getBounds();
  const northEast = bounds.getNorthEast();
  const southWest = bounds.getSouthWest();
  if (northEast.lat > latMax && southWest.lat < latMin) {
    map5.fitBounds([
      [latMin, 0],
      [latMax, 0]
    ]);
  }
}
function mapboxglWheelEvent(map5, layer, event) {
  const { deltaY } = event;
  if (!layer || !layer.getMaplibreMap)
    return;
  const mapboxmap = layer.getMaplibreMap();
  const delta = deltaY * -1;
  const bounds = map5.getBounds();
  const northEast = bounds.getNorthEast();
  const southWest = bounds.getSouthWest();
  const latMin = -70;
  const latMax = 80;
  if (delta < 0 && northEast.lat > latMax && southWest.lat < latMin) {
    constraintMapView(map5);
    return;
  }
  const zoom = mapboxmap.getZoom() + delta * 1e-3;
  const xy = map5.mouseEventToLayerPoint(event);
  map5.setZoomAround(xy, zoom + 1, { animate: false });
}
var mapboxglWheelEventThrottled = throttle(mapboxglWheelEvent, 32);
var constraintMapViewThrottled = throttle(constraintMapView, 1e3);

// node_modules/kdbush/src/sort.js
function sortKD(ids, coords, nodeSize, left3, right3, depth) {
  if (right3 - left3 <= nodeSize) return;
  const m30 = left3 + right3 >> 1;
  select(ids, coords, m30, left3, right3, depth % 2);
  sortKD(ids, coords, nodeSize, left3, m30 - 1, depth + 1);
  sortKD(ids, coords, nodeSize, m30 + 1, right3, depth + 1);
}
function select(ids, coords, k17, left3, right3, inc) {
  while (right3 > left3) {
    if (right3 - left3 > 600) {
      const n = right3 - left3 + 1;
      const m30 = k17 - left3 + 1;
      const z3 = Math.log(n);
      const s12 = 0.5 * Math.exp(2 * z3 / 3);
      const sd = 0.5 * Math.sqrt(z3 * s12 * (n - s12) / n) * (m30 - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left3, Math.floor(k17 - m30 * s12 / n + sd));
      const newRight = Math.min(right3, Math.floor(k17 + (n - m30) * s12 / n + sd));
      select(ids, coords, k17, newLeft, newRight, inc);
    }
    const t4 = coords[2 * k17 + inc];
    let i8 = left3;
    let j6 = right3;
    swapItem(ids, coords, left3, k17);
    if (coords[2 * right3 + inc] > t4) swapItem(ids, coords, left3, right3);
    while (i8 < j6) {
      swapItem(ids, coords, i8, j6);
      i8++;
      j6--;
      while (coords[2 * i8 + inc] < t4) i8++;
      while (coords[2 * j6 + inc] > t4) j6--;
    }
    if (coords[2 * left3 + inc] === t4) swapItem(ids, coords, left3, j6);
    else {
      j6++;
      swapItem(ids, coords, j6, right3);
    }
    if (j6 <= k17) left3 = j6 + 1;
    if (k17 <= j6) right3 = j6 - 1;
  }
}
function swapItem(ids, coords, i8, j6) {
  swap(ids, i8, j6);
  swap(coords, 2 * i8, 2 * j6);
  swap(coords, 2 * i8 + 1, 2 * j6 + 1);
}
function swap(arr, i8, j6) {
  const tmp = arr[i8];
  arr[i8] = arr[j6];
  arr[j6] = tmp;
}

// node_modules/kdbush/src/range.js
function range2(ids, coords, minX, minY, maxX, maxY, nodeSize) {
  const stack = [0, ids.length - 1, 0];
  const result = [];
  let x21, y25;
  while (stack.length) {
    const axis3 = stack.pop();
    const right3 = stack.pop();
    const left3 = stack.pop();
    if (right3 - left3 <= nodeSize) {
      for (let i8 = left3; i8 <= right3; i8++) {
        x21 = coords[2 * i8];
        y25 = coords[2 * i8 + 1];
        if (x21 >= minX && x21 <= maxX && y25 >= minY && y25 <= maxY) result.push(ids[i8]);
      }
      continue;
    }
    const m30 = Math.floor((left3 + right3) / 2);
    x21 = coords[2 * m30];
    y25 = coords[2 * m30 + 1];
    if (x21 >= minX && x21 <= maxX && y25 >= minY && y25 <= maxY) result.push(ids[m30]);
    const nextAxis = (axis3 + 1) % 2;
    if (axis3 === 0 ? minX <= x21 : minY <= y25) {
      stack.push(left3);
      stack.push(m30 - 1);
      stack.push(nextAxis);
    }
    if (axis3 === 0 ? maxX >= x21 : maxY >= y25) {
      stack.push(m30 + 1);
      stack.push(right3);
      stack.push(nextAxis);
    }
  }
  return result;
}

// node_modules/kdbush/src/within.js
function within(ids, coords, qx, qy, r4, nodeSize) {
  const stack = [0, ids.length - 1, 0];
  const result = [];
  const r22 = r4 * r4;
  while (stack.length) {
    const axis3 = stack.pop();
    const right3 = stack.pop();
    const left3 = stack.pop();
    if (right3 - left3 <= nodeSize) {
      for (let i8 = left3; i8 <= right3; i8++) {
        if (sqDist(coords[2 * i8], coords[2 * i8 + 1], qx, qy) <= r22) result.push(ids[i8]);
      }
      continue;
    }
    const m30 = Math.floor((left3 + right3) / 2);
    const x21 = coords[2 * m30];
    const y25 = coords[2 * m30 + 1];
    if (sqDist(x21, y25, qx, qy) <= r22) result.push(ids[m30]);
    const nextAxis = (axis3 + 1) % 2;
    if (axis3 === 0 ? qx - r4 <= x21 : qy - r4 <= y25) {
      stack.push(left3);
      stack.push(m30 - 1);
      stack.push(nextAxis);
    }
    if (axis3 === 0 ? qx + r4 >= x21 : qy + r4 >= y25) {
      stack.push(m30 + 1);
      stack.push(right3);
      stack.push(nextAxis);
    }
  }
  return result;
}
function sqDist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}

// node_modules/kdbush/src/index.js
var defaultGetX = (p13) => p13[0];
var defaultGetY = (p13) => p13[1];
var KDBush = class {
  constructor(points3, getX3 = defaultGetX, getY3 = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {
    this.nodeSize = nodeSize;
    this.points = points3;
    const IndexArrayType = points3.length < 65536 ? Uint16Array : Uint32Array;
    const ids = this.ids = new IndexArrayType(points3.length);
    const coords = this.coords = new ArrayType(points3.length * 2);
    for (let i8 = 0; i8 < points3.length; i8++) {
      ids[i8] = i8;
      coords[2 * i8] = getX3(points3[i8]);
      coords[2 * i8 + 1] = getY3(points3[i8]);
    }
    sortKD(ids, coords, nodeSize, 0, ids.length - 1, 0);
  }
  range(minX, minY, maxX, maxY) {
    return range2(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);
  }
  within(x21, y25, r4) {
    return within(this.ids, this.coords, x21, y25, r4, this.nodeSize);
  }
};

// node_modules/supercluster/index.js
var defaultOptions = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: false,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: false,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (props) => props
  // props => ({sum: props.my_value})
};
var fround = Math.fround || /* @__PURE__ */ ((tmp) => ((x21) => {
  tmp[0] = +x21;
  return tmp[0];
}))(new Float32Array(1));
var Supercluster = class {
  constructor(options) {
    this.options = extend3(Object.create(defaultOptions), options);
    this.trees = new Array(this.options.maxZoom + 1);
  }
  load(points3) {
    const { log: log4, minZoom, maxZoom, nodeSize } = this.options;
    if (log4) console.time("total time");
    const timerId = `prepare ${points3.length} points`;
    if (log4) console.time(timerId);
    this.points = points3;
    let clusters = [];
    for (let i8 = 0; i8 < points3.length; i8++) {
      if (!points3[i8].geometry) continue;
      clusters.push(createPointCluster(points3[i8], i8));
    }
    this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);
    if (log4) console.timeEnd(timerId);
    for (let z3 = maxZoom; z3 >= minZoom; z3--) {
      const now2 = +Date.now();
      clusters = this._cluster(clusters, z3);
      this.trees[z3] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);
      if (log4) console.log("z%d: %d clusters in %dms", z3, clusters.length, +Date.now() - now2);
    }
    if (log4) console.timeEnd("total time");
    return this;
  }
  getClusters(bbox, zoom) {
    let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;
    const minLat = Math.max(-90, Math.min(90, bbox[1]));
    let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;
    const maxLat = Math.max(-90, Math.min(90, bbox[3]));
    if (bbox[2] - bbox[0] >= 360) {
      minLng = -180;
      maxLng = 180;
    } else if (minLng > maxLng) {
      const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);
      const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);
      return easternHem.concat(westernHem);
    }
    const tree = this.trees[this._limitZoom(zoom)];
    const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));
    const clusters = [];
    for (const id2 of ids) {
      const c6 = tree.points[id2];
      clusters.push(c6.numPoints ? getClusterJSON(c6) : this.points[c6.index]);
    }
    return clusters;
  }
  getChildren(clusterId) {
    const originId = this._getOriginId(clusterId);
    const originZoom = this._getOriginZoom(clusterId);
    const errorMsg = "No cluster with the specified id.";
    const index3 = this.trees[originZoom];
    if (!index3) throw new Error(errorMsg);
    const origin = index3.points[originId];
    if (!origin) throw new Error(errorMsg);
    const r4 = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));
    const ids = index3.within(origin.x, origin.y, r4);
    const children2 = [];
    for (const id2 of ids) {
      const c6 = index3.points[id2];
      if (c6.parentId === clusterId) {
        children2.push(c6.numPoints ? getClusterJSON(c6) : this.points[c6.index]);
      }
    }
    if (children2.length === 0) throw new Error(errorMsg);
    return children2;
  }
  getLeaves(clusterId, limit, offset) {
    limit = limit || 10;
    offset = offset || 0;
    const leaves = [];
    this._appendLeaves(leaves, clusterId, limit, offset, 0);
    return leaves;
  }
  getTile(z3, x21, y25) {
    const tree = this.trees[this._limitZoom(z3)];
    const z22 = Math.pow(2, z3);
    const { extent: extent2, radius } = this.options;
    const p13 = radius / extent2;
    const top2 = (y25 - p13) / z22;
    const bottom2 = (y25 + 1 + p13) / z22;
    const tile2 = {
      features: []
    };
    this._addTileFeatures(
      tree.range((x21 - p13) / z22, top2, (x21 + 1 + p13) / z22, bottom2),
      tree.points,
      x21,
      y25,
      z22,
      tile2
    );
    if (x21 === 0) {
      this._addTileFeatures(
        tree.range(1 - p13 / z22, top2, 1, bottom2),
        tree.points,
        z22,
        y25,
        z22,
        tile2
      );
    }
    if (x21 === z22 - 1) {
      this._addTileFeatures(
        tree.range(0, top2, p13 / z22, bottom2),
        tree.points,
        -1,
        y25,
        z22,
        tile2
      );
    }
    return tile2.features.length ? tile2 : null;
  }
  getClusterExpansionZoom(clusterId) {
    let expansionZoom = this._getOriginZoom(clusterId) - 1;
    while (expansionZoom <= this.options.maxZoom) {
      const children2 = this.getChildren(clusterId);
      expansionZoom++;
      if (children2.length !== 1) break;
      clusterId = children2[0].properties.cluster_id;
    }
    return expansionZoom;
  }
  _appendLeaves(result, clusterId, limit, offset, skipped) {
    const children2 = this.getChildren(clusterId);
    for (const child of children2) {
      const props = child.properties;
      if (props && props.cluster) {
        if (skipped + props.point_count <= offset) {
          skipped += props.point_count;
        } else {
          skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);
        }
      } else if (skipped < offset) {
        skipped++;
      } else {
        result.push(child);
      }
      if (result.length === limit) break;
    }
    return skipped;
  }
  _addTileFeatures(ids, points3, x21, y25, z22, tile2) {
    for (const i8 of ids) {
      const c6 = points3[i8];
      const isCluster = c6.numPoints;
      let tags, px, py;
      if (isCluster) {
        tags = getClusterProperties(c6);
        px = c6.x;
        py = c6.y;
      } else {
        const p13 = this.points[c6.index];
        tags = p13.properties;
        px = lngX(p13.geometry.coordinates[0]);
        py = latY(p13.geometry.coordinates[1]);
      }
      const f29 = {
        type: 1,
        geometry: [[
          Math.round(this.options.extent * (px * z22 - x21)),
          Math.round(this.options.extent * (py * z22 - y25))
        ]],
        tags
      };
      let id2;
      if (isCluster) {
        id2 = c6.id;
      } else if (this.options.generateId) {
        id2 = c6.index;
      } else if (this.points[c6.index].id) {
        id2 = this.points[c6.index].id;
      }
      if (id2 !== void 0) f29.id = id2;
      tile2.features.push(f29);
    }
  }
  _limitZoom(z3) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+z3), this.options.maxZoom + 1));
  }
  _cluster(points3, zoom) {
    const clusters = [];
    const { radius, extent: extent2, reduce: reduce2, minPoints } = this.options;
    const r4 = radius / (extent2 * Math.pow(2, zoom));
    for (let i8 = 0; i8 < points3.length; i8++) {
      const p13 = points3[i8];
      if (p13.zoom <= zoom) continue;
      p13.zoom = zoom;
      const tree = this.trees[zoom + 1];
      const neighborIds = tree.within(p13.x, p13.y, r4);
      const numPointsOrigin = p13.numPoints || 1;
      let numPoints = numPointsOrigin;
      for (const neighborId of neighborIds) {
        const b25 = tree.points[neighborId];
        if (b25.zoom > zoom) numPoints += b25.numPoints || 1;
      }
      if (numPoints > numPointsOrigin && numPoints >= minPoints) {
        let wx = p13.x * numPointsOrigin;
        let wy = p13.y * numPointsOrigin;
        let clusterProperties = reduce2 && numPointsOrigin > 1 ? this._map(p13, true) : null;
        const id2 = (i8 << 5) + (zoom + 1) + this.points.length;
        for (const neighborId of neighborIds) {
          const b25 = tree.points[neighborId];
          if (b25.zoom <= zoom) continue;
          b25.zoom = zoom;
          const numPoints2 = b25.numPoints || 1;
          wx += b25.x * numPoints2;
          wy += b25.y * numPoints2;
          b25.parentId = id2;
          if (reduce2) {
            if (!clusterProperties) clusterProperties = this._map(p13, true);
            reduce2(clusterProperties, this._map(b25));
          }
        }
        p13.parentId = id2;
        clusters.push(createCluster(wx / numPoints, wy / numPoints, id2, numPoints, clusterProperties));
      } else {
        clusters.push(p13);
        if (numPoints > 1) {
          for (const neighborId of neighborIds) {
            const b25 = tree.points[neighborId];
            if (b25.zoom <= zoom) continue;
            b25.zoom = zoom;
            clusters.push(b25);
          }
        }
      }
    }
    return clusters;
  }
  // get index of the point from which the cluster originated
  _getOriginId(clusterId) {
    return clusterId - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(clusterId) {
    return (clusterId - this.points.length) % 32;
  }
  _map(point13, clone) {
    if (point13.numPoints) {
      return clone ? extend3({}, point13.properties) : point13.properties;
    }
    const original = this.points[point13.index].properties;
    const result = this.options.map(original);
    return clone && result === original ? extend3({}, result) : result;
  }
};
function createCluster(x21, y25, id2, numPoints, properties) {
  return {
    x: fround(x21),
    // weighted cluster center; round for consistency with Float32Array index
    y: fround(y25),
    zoom: Infinity,
    // the last zoom the cluster was processed at
    id: id2,
    // encodes index of the first child of the cluster and its zoom level
    parentId: -1,
    // parent cluster id
    numPoints,
    properties
  };
}
function createPointCluster(p13, id2) {
  const [x21, y25] = p13.geometry.coordinates;
  return {
    x: fround(lngX(x21)),
    // projected point coordinates
    y: fround(latY(y25)),
    zoom: Infinity,
    // the last zoom the point was processed at
    index: id2,
    // index of the source feature in the original input array,
    parentId: -1
    // parent cluster id
  };
}
function getClusterJSON(cluster2) {
  return {
    type: "Feature",
    id: cluster2.id,
    properties: getClusterProperties(cluster2),
    geometry: {
      type: "Point",
      coordinates: [xLng(cluster2.x), yLat(cluster2.y)]
    }
  };
}
function getClusterProperties(cluster2) {
  const count3 = cluster2.numPoints;
  const abbrev = count3 >= 1e4 ? `${Math.round(count3 / 1e3)}k` : count3 >= 1e3 ? `${Math.round(count3 / 100) / 10}k` : count3;
  return extend3(extend3({}, cluster2.properties), {
    cluster: true,
    cluster_id: cluster2.id,
    point_count: count3,
    point_count_abbreviated: abbrev
  });
}
function lngX(lng) {
  return lng / 360 + 0.5;
}
function latY(lat) {
  const sin6 = Math.sin(lat * Math.PI / 180);
  const y25 = 0.5 - 0.25 * Math.log((1 + sin6) / (1 - sin6)) / Math.PI;
  return y25 < 0 ? 0 : y25 > 1 ? 1 : y25;
}
function xLng(x21) {
  return (x21 - 0.5) * 360;
}
function yLat(y25) {
  const y26 = (180 - y25 * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(y26)) / Math.PI - 90;
}
function extend3(dest, src) {
  for (const id2 in src) dest[id2] = src[id2];
  return dest;
}
function getX(p13) {
  return p13.x;
}
function getY(p13) {
  return p13.y;
}

// node_modules/@unovis/ts/utils/html.js
function getHTMLTransform(el) {
  const styleTransform = select_default2(el).style("transform");
  const match3D = styleTransform.match(/matrix3d\((.*?)\)/);
  const match2D = styleTransform.match(/matrix\((.*?)\)/);
  if (!match3D && !match2D)
    return [0, 0, 0];
  if (match3D) {
    const values2 = match3D[1].split(",").map((d18) => parseFloat(d18.trim()));
    return values2.slice(0, 3);
  }
  const values = match2D[1].split(",").map((d18) => parseFloat(d18.trim()));
  values.push(0);
  return values.slice(0, 3);
}

// node_modules/@unovis/ts/components/leaflet-map/modules/utils.js
function bBoxMerge(bBoxArray) {
  let box = { x1: 0, x2: 0, y1: 0, y2: 0 };
  bBoxArray.forEach((coords) => {
    if (!box) {
      box = Object.assign({}, coords);
    } else {
      if (box.x1 > coords.x1)
        box.x1 = coords.x1;
      if (box.y1 > coords.y1)
        box.y1 = coords.y1;
      if (box.x2 < coords.x2)
        box.x2 = coords.x2;
      if (box.y2 < coords.y2)
        box.y2 = coords.y2;
    }
  });
  return {
    x: box.x1,
    y: box.y1,
    width: box.x2 - box.x1,
    height: box.y2 - box.y1
  };
}
var getNextZoomLevelOnClusterClick = (level) => clamp(1 + level * 1.5, level, 12);
function projectPoint(geoJSONPoint, leafletMap) {
  const lat = geoJSONPoint.geometry.coordinates[1];
  const lon = geoJSONPoint.geometry.coordinates[0];
  const projected = leafletMap.latLngToLayerPoint([lat, lon]);
  return projected;
}
function getPointRadius(geoPoint, pointRadius, zoomLevel) {
  const isDynamic = !pointRadius;
  const radius = isDynamic ? 1 + 2 * Math.pow(zoomLevel, 0.8) : getNumber(geoPoint.properties, pointRadius);
  const isCluster = geoPoint.properties.cluster;
  return isCluster && isDynamic ? clamp(Math.pow(geoPoint.properties.point_count, 0.35) * radius, radius * 1.1, radius * 3) : radius;
}
function getPointPos(point13, leafletMap) {
  const properties = point13.properties;
  const isFromCluster = !!properties.expandedClusterPoint;
  if (isFromCluster) {
    const { x: x21, y: y25 } = projectPoint(properties.expandedClusterPoint, leafletMap);
    return {
      x: x21 + properties.dx,
      y: y25 + properties.dy
    };
  } else {
    return projectPoint(point13, leafletMap);
  }
}
function toGeoJSONPoint(d18, i8, pointLatitude, pointLongitude) {
  const lat = getNumber(d18, pointLatitude);
  const lon = getNumber(d18, pointLongitude);
  return {
    type: "Feature",
    properties: Object.assign(Object.assign({}, d18), { _index: i8 }),
    geometry: {
      type: "Point",
      coordinates: [lon, lat]
    }
  };
}
function calculateClusterIndex(data, config, maxClusterZoomLevel = 23) {
  const { colorMap, pointShape, pointLatitude, pointLongitude, clusteringDistance } = config;
  return new Supercluster({
    radius: clusteringDistance,
    maxZoom: maxClusterZoomLevel,
    map: (d18) => {
      const shape = getString(d18, pointShape);
      const clusterPoint = { shape };
      for (const key of Object.keys(colorMap)) {
        clusterPoint[key] = d18[key] || 0;
      }
      return clusterPoint;
    },
    reduce: (acc, clusterPoint) => {
      var _a, _b;
      acc.shape = acc.shape === clusterPoint.shape ? acc.shape : LeafletMapPointShape.Circle;
      acc.value = ((_a = acc.value) !== null && _a !== void 0 ? _a : 0) + ((_b = clusterPoint.value) !== null && _b !== void 0 ? _b : 0);
      for (const key of Object.keys(colorMap)) {
        acc[key] += clusterPoint[key];
      }
    }
  }).load(data.map((d18, i8) => toGeoJSONPoint(d18, i8, pointLatitude, pointLongitude)));
}
function getNodePathData({ x: x21, y: y25 }, radius, shape) {
  switch (shape) {
    case LeafletMapPointShape.Triangle:
      return polygon(radius * 2, 3);
    case LeafletMapPointShape.Square:
      return polygon(radius * 2, 4);
    case LeafletMapPointShape.Circle:
    case LeafletMapPointShape.Ring:
    default:
      return circlePath(x21, y25, radius);
  }
}
function getDonutData(d18, colorMap) {
  return Object.keys(colorMap).map((key) => ({
    name: key,
    value: d18[key],
    color: colorMap[key].color,
    className: colorMap[key].className
  }));
}
function geoJsonPointToScreenPoint(geoPoint, i8, leafletMap, config) {
  var _a;
  const zoomLevel = leafletMap.getZoom();
  const isCluster = geoPoint.properties.cluster;
  const clusterIndex = geoPoint.properties.clusterIndex;
  const clusterPoints = isCluster ? clusterIndex.getLeaves(geoPoint.properties.cluster_id, Infinity).map((d18) => d18.properties) : void 0;
  const { x: x21, y: y25 } = getPointPos(geoPoint, leafletMap);
  const id2 = isCluster ? `cluster-${geoPoint.id}` : (_a = getString(geoPoint.properties, config.pointId)) !== null && _a !== void 0 ? _a : geoPoint.geometry.coordinates.join("");
  const pointColor = getColor(geoPoint.properties, isCluster ? config.clusterColor : config.pointColor);
  const radius = getPointRadius(geoPoint, isCluster ? config.clusterRadius : config.pointRadius, zoomLevel);
  const shape = isCluster ? LeafletMapPointShape.Circle : getString(geoPoint.properties, config.pointShape);
  const isRing = shape === LeafletMapPointShape.Ring;
  const donutData = getDonutData(geoPoint.properties, config.colorMap);
  const maxValue = max(donutData, (d18) => d18.value);
  const maxValueIndex = donutData.map((d18) => d18.value).indexOf(maxValue);
  const biggestDatum = donutData[maxValueIndex !== null && maxValueIndex !== void 0 ? maxValueIndex : 0];
  const color2 = isCluster ? pointColor : isRing ? null : pointColor !== null && pointColor !== void 0 ? pointColor : biggestDatum === null || biggestDatum === void 0 ? void 0 : biggestDatum.color;
  const bbox = { x1: x21 - radius, y1: y25 - radius, x2: x21 + radius, y2: y25 + radius };
  const path3 = getNodePathData({ x: 0, y: 0 }, radius, shape);
  const _zIndex = 0;
  const screenPoint = Object.assign(Object.assign({}, geoPoint), {
    id: id2,
    bbox,
    radius,
    donutData,
    path: path3,
    color: color2,
    isCluster,
    clusterIndex,
    clusterPoints,
    _zIndex
  });
  return screenPoint;
}
function shouldClusterExpand(cluster2, zoomLevel, midLevel = 4, maxLevel = 8, maxClusterZoomLevel = 23) {
  if (!cluster2)
    return false;
  const clusterExpansionZoomLevel = cluster2.clusterIndex.getClusterExpansionZoom(cluster2.properties.cluster_id);
  return zoomLevel >= maxLevel || zoomLevel >= midLevel && (cluster2.properties.point_count < 20 || clusterExpansionZoomLevel >= maxClusterZoomLevel);
}
function findPointAndClusterByPointId(points3, id2, pointId) {
  let point13;
  let cluster2;
  points3.forEach((p13) => {
    var _a;
    if (p13.isCluster) {
      const leaves = (_a = p13.clusterIndex.getLeaves(p13.properties.cluster_id, Infinity)) !== null && _a !== void 0 ? _a : [];
      const foundPoint = leaves.find((d18) => getString(d18.properties, pointId) === id2);
      if (foundPoint) {
        point13 = foundPoint;
        cluster2 = p13;
      }
    }
  });
  return { point: point13, cluster: cluster2 };
}
function getNodeRelativePosition(d18, leafletMap) {
  const paneTransform = getHTMLTransform(leafletMap.getPane("mapPane"));
  const { x: x21, y: y25 } = getPointPos(d18, leafletMap);
  return { x: x21 + paneTransform[0], y: y25 + paneTransform[1] };
}
function getClusterRadius(cluster2) {
  const { points: points3 } = cluster2;
  const minX = min(points3.map((d18) => d18.properties.dx - d18.properties.r));
  const maxX = max(points3.map((d18) => d18.properties.dx + d18.properties.r));
  const minY = min(points3.map((d18) => d18.properties.dy - d18.properties.r));
  const maxY = max(points3.map((d18) => d18.properties.dy + d18.properties.r));
  return Math.sqrt(Math.pow(maxX - minX, 2) + Math.pow(maxY - minY, 2)) * 0.5;
}
function getClustersAndPoints(clusterIndex, leafletMap, customBounds) {
  const leafletBounds = leafletMap.getBounds();
  const southWest = leafletBounds.getSouthWest();
  const northEast = leafletBounds.getNorthEast();
  const bounds = customBounds || [southWest.lng, southWest.lat, northEast.lng, northEast.lat];
  const zoom = Math.round(leafletMap.getZoom());
  const points3 = clusterIndex.getClusters(bounds, zoom);
  for (const p13 of points3) {
    const point13 = p13;
    const isCluster = point13.properties.cluster;
    if (isCluster) {
      point13.properties.clusterIndex = clusterIndex;
      point13.properties.clusterPoints = clusterIndex.getLeaves(point13.properties.cluster_id, Infinity).map((d18) => d18.properties);
    }
  }
  return points3;
}

// node_modules/@unovis/ts/components/leaflet-map/config.js
var LeafletMapDefaultConfig = Object.assign(Object.assign({}, ComponentDefaultConfig), {
  // General
  width: void 0,
  height: void 0,
  flyToDuration: 1500,
  fitViewPadding: [150, 150],
  zoomDuration: 800,
  initialBounds: void 0,
  fitBoundsOnUpdate: void 0,
  fitViewOnInit: true,
  fitViewOnUpdate: false,
  attribution: ['<a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap contributors</a>'],
  accessToken: "",
  style: void 0,
  styleDarkTheme: void 0,
  renderer: LeafletMapRenderer.MapLibre,
  // Map events
  onMapInitialized: void 0,
  onMapMoveZoom: void 0,
  onMapMoveStart: void 0,
  onMapMoveEnd: void 0,
  onMapZoomStart: void 0,
  onMapZoomEnd: void 0,
  onMapClick: void 0,
  // Point
  pointLongitude: (d18) => d18.longitude,
  pointLatitude: (d18) => d18.latitude,
  pointId: (d18) => d18.id,
  pointShape: (d18) => d18.shape,
  pointColor: (d18) => d18.color,
  pointRadius: void 0,
  pointLabel: void 0,
  pointLabelColor: void 0,
  pointBottomLabel: "",
  pointCursor: null,
  pointRingWidth: 1.25,
  selectedPointId: void 0,
  // Cluster
  clusterColor: void 0,
  clusterRadius: void 0,
  clusterLabel: (d18) => `${d18.point_count}`,
  clusterLabelColor: void 0,
  clusterBottomLabel: "",
  clusterRingWidth: 1.25,
  clusterBackground: true,
  clusterExpandOnClick: true,
  clusteringDistance: 55,
  colorMap: {},
  // TopoJSON Overlay
  topoJSONLayer: {
    sources: void 0,
    fillOpacity: 0.6,
    strokeOpacity: 0.8,
    strokeWidth: 1,
    featureName: void 0,
    fillProperty: void 0,
    strokeProperty: void 0
  },
  // Misc
  tooltip: void 0,
  ariaLabel: void 0
});

// node_modules/@unovis/ts/components/leaflet-map/style.js
var style_exports15 = {};
__export(style_exports15, {
  background: () => background4,
  backgroundRect: () => backgroundRect,
  bottomLabel: () => bottomLabel,
  clusterBackground: () => clusterBackground,
  donutCluster: () => donutCluster,
  innerLabel: () => innerLabel,
  innerLabelCluster: () => innerLabelCluster,
  map: () => map4,
  mapboxglCanvas: () => mapboxglCanvas,
  onFeatureHover: () => onFeatureHover,
  point: () => point12,
  pointPath: () => pointPath,
  pointPathCluster: () => pointPathCluster,
  pointPathRing: () => pointPathRing,
  pointSelection: () => pointSelection,
  pointSelectionRing: () => pointSelectionRing,
  points: () => points2,
  root: () => root17,
  svgOverlay: () => svgOverlay,
  variables: () => variables9
});

// node_modules/@unovis/ts/components/leaflet-map/leaflet.css.js
var css_248z = '.leaflet-image-layer,.leaflet-layer,.leaflet-marker-icon,.leaflet-marker-shadow,.leaflet-pane,.leaflet-pane>canvas,.leaflet-pane>svg,.leaflet-tile,.leaflet-tile-container,.leaflet-zoom-box{left:0;position:absolute;top:0}.leaflet-container{overflow:hidden}.leaflet-marker-icon,.leaflet-marker-shadow,.leaflet-tile{-webkit-user-drag:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.leaflet-safari .leaflet-tile{image-rendering:-webkit-optimize-contrast}.leaflet-safari .leaflet-tile-container{height:1600px;-webkit-transform-origin:0 0;width:1600px}.leaflet-marker-icon,.leaflet-marker-shadow{display:block}.leaflet-container .leaflet-marker-pane img,.leaflet-container .leaflet-overlay-pane svg,.leaflet-container .leaflet-shadow-pane img,.leaflet-container .leaflet-tile,.leaflet-container .leaflet-tile-pane img,.leaflet-container img.leaflet-image-layer{max-height:none!important;max-width:none!important}.leaflet-container.leaflet-touch-zoom{-ms-touch-action:pan-x pan-y;touch-action:pan-x pan-y}.leaflet-container.leaflet-touch-drag{-ms-touch-action:pinch-zoom;touch-action:none;touch-action:pinch-zoom}.leaflet-container.leaflet-touch-drag.leaflet-touch-zoom{-ms-touch-action:none;touch-action:none}.leaflet-container{-webkit-tap-highlight-color:transparent}.leaflet-container a{-webkit-tap-highlight-color:rgba(51,181,229,.4)}.leaflet-tile{filter:inherit;visibility:hidden}.leaflet-tile-loaded{visibility:inherit}.leaflet-zoom-box{-moz-box-sizing:border-box;box-sizing:border-box;height:0;width:0;z-index:800}.leaflet-overlay-pane svg{-moz-user-select:none}.leaflet-overlay-pane{z-index:1}.leaflet-vml-shape{height:1px;width:1px}.lvml{behavior:url(#default#VML);display:inline-block;position:absolute}.leaflet-control{pointer-events:visiblePainted;pointer-events:auto;position:relative;z-index:800}.leaflet-bottom,.leaflet-top{pointer-events:none;position:absolute;z-index:1}.leaflet-top{top:0}.leaflet-right{right:0}.leaflet-bottom{bottom:0}.leaflet-left{left:0}.leaflet-control{clear:both;float:left}.leaflet-right .leaflet-control{float:right}.leaflet-top .leaflet-control{margin-top:10px}.leaflet-bottom .leaflet-control{margin-bottom:10px}.leaflet-left .leaflet-control{margin-left:10px}.leaflet-right .leaflet-control{margin-right:10px}.leaflet-fade-anim .leaflet-tile{will-change:opacity}.leaflet-fade-anim .leaflet-popup{opacity:0;-webkit-transition:opacity .2s linear;-moz-transition:opacity .2s linear;transition:opacity .2s linear}.leaflet-fade-anim .leaflet-map-pane .leaflet-popup{opacity:1}.leaflet-zoom-animated{-webkit-transform-origin:0 0;-ms-transform-origin:0 0;transform-origin:0 0}.leaflet-zoom-anim .leaflet-zoom-animated{-webkit-transition:-webkit-transform .25s cubic-bezier(0,0,.25,1);-moz-transition:-moz-transform .25s cubic-bezier(0,0,.25,1);transition:transform .25s cubic-bezier(0,0,.25,1);will-change:transform}.leaflet-pan-anim .leaflet-tile,.leaflet-zoom-anim .leaflet-tile{-webkit-transition:none;-moz-transition:none;transition:none}.leaflet-zoom-anim .leaflet-zoom-hide{visibility:hidden}.leaflet-interactive{cursor:pointer}.leaflet-grab{cursor:-webkit-grab;cursor:-moz-grab;cursor:grab}.leaflet-crosshair,.leaflet-crosshair .leaflet-interactive{cursor:crosshair}.leaflet-control,.leaflet-popup-pane{cursor:auto}.leaflet-dragging .leaflet-grab,.leaflet-dragging .leaflet-grab .leaflet-interactive,.leaflet-dragging .leaflet-marker-draggable{cursor:move;cursor:-webkit-grabbing;cursor:-moz-grabbing;cursor:grabbing}.leaflet-image-layer,.leaflet-marker-icon,.leaflet-marker-shadow,.leaflet-pane>svg path,.leaflet-tile-container{pointer-events:none}.leaflet-image-layer.leaflet-interactive,.leaflet-marker-icon.leaflet-interactive,.leaflet-pane>svg path.leaflet-interactive{pointer-events:visiblePainted;pointer-events:auto}.leaflet-container{background:#dfe5eb;outline:0}.leaflet-container a{color:#0078a8}.leaflet-container a.leaflet-active{outline:2px solid orange}.leaflet-zoom-box{background:rgba(255,255,255,.5);border:2px dotted #38f}.leaflet-container{font:12px/1.5 Helvetica Neue,Arial,Helvetica,sans-serif}.leaflet-bar{border-radius:4px;box-shadow:0 1px 5px rgba(0,0,0,.65)}.leaflet-bar a,.leaflet-bar a:hover{background-color:#fff;border-bottom:1px solid rgba(130,130,130,.2);color:#000;display:block;height:26px;line-height:26px;text-align:center;text-decoration:none;width:26px}.leaflet-bar a,.leaflet-control-layers-toggle{background-position:50% 50%;background-repeat:no-repeat;display:block}.leaflet-bar a:hover{background-color:#f4f4f4}.leaflet-bar a:first-child{border-top-left-radius:4px;border-top-right-radius:4px}.leaflet-bar a:last-child{border-bottom:none;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.leaflet-bar a.leaflet-disabled{background-color:#f4f4f4;color:#bbb;cursor:default}.leaflet-touch .leaflet-bar a{height:30px;line-height:30px;width:30px}.leaflet-touch .leaflet-bar a:first-child{border-top-left-radius:2px;border-top-right-radius:2px}.leaflet-touch .leaflet-bar a:last-child{border-bottom-left-radius:2px;border-bottom-right-radius:2px}.leaflet-control-zoom-in,.leaflet-control-zoom-out{font:700 18px Lucida Console,Monaco,monospace;text-indent:1px}.leaflet-touch .leaflet-control-zoom-in,.leaflet-touch .leaflet-control-zoom-out{font-size:22px}.leaflet-control-layers{background:#fff;border-radius:5px;box-shadow:0 1px 5px rgba(0,0,0,.4)}.leaflet-touch .leaflet-control-layers-toggle{height:44px;width:44px}.leaflet-control-layers-expanded .leaflet-control-layers-toggle,.leaflet-control-layers .leaflet-control-layers-list{display:none}.leaflet-control-layers-expanded .leaflet-control-layers-list{display:block;position:relative}.leaflet-control-layers-expanded{background:#fff;color:#333;padding:6px 10px 6px 6px}.leaflet-control-layers-scrollbar{overflow-x:hidden;overflow-y:scroll;padding-right:5px}.leaflet-control-layers-selector{margin-top:2px;position:relative;top:1px}.leaflet-control-layers label{display:block}.leaflet-control-layers-separator{border-top:1px solid #ddd;height:0;margin:5px -10px 5px -6px}.leaflet-container .leaflet-control-attribution{background:#fff;background:hsla(0,0%,100%,.7);margin:0}.leaflet-control-attribution,.leaflet-control-scale-line{color:#333;padding:0 5px}.leaflet-control-attribution a{color:#333;font-size:7pt;opacity:.6;text-decoration:none}.leaflet-control-attribution a:hover{text-decoration:underline}.leaflet-container .leaflet-control-attribution,.leaflet-container .leaflet-control-scale{font-size:11px}.leaflet-left .leaflet-control-scale{margin-left:5px}.leaflet-bottom .leaflet-control-scale{margin-bottom:5px}.leaflet-control-scale-line{background:#fff;background:hsla(0,0%,100%,.5);border:2px solid #777;border-top:none;-moz-box-sizing:border-box;box-sizing:border-box;font-size:11px;line-height:1.1;overflow:hidden;padding:2px 5px 1px;white-space:nowrap}.leaflet-control-scale-line:not(:first-child){border-bottom:none;border-top:2px solid #777;margin-top:-2px}.leaflet-control-scale-line:not(:first-child):not(:last-child){border-bottom:2px solid #777}.leaflet-touch .leaflet-bar,.leaflet-touch .leaflet-control-attribution,.leaflet-touch .leaflet-control-layers{box-shadow:none}.leaflet-touch .leaflet-bar,.leaflet-touch .leaflet-control-layers{background-clip:padding-box;border:1px solid rgba(0,0,0,.15)}.leaflet-popup{margin-bottom:20px;position:absolute;text-align:center}.leaflet-popup-content-wrapper{border-radius:12px;padding:1px;text-align:left}.leaflet-popup-content{line-height:1.4;margin:13px 19px}.leaflet-popup-content p{margin:18px 0}.leaflet-popup-tip-container{height:20px;left:50%;margin-left:-20px;overflow:hidden;pointer-events:none;position:absolute;width:40px}.leaflet-popup-tip{height:17px;margin:-10px auto 0;padding:1px;-webkit-transform:rotate(45deg);-moz-transform:rotate(45deg);-ms-transform:rotate(45deg);transform:rotate(45deg);width:17px}.leaflet-popup-content-wrapper,.leaflet-popup-tip{background:#fff;box-shadow:0 3px 14px rgba(0,0,0,.4);color:#333}.leaflet-container a.leaflet-popup-close-button{background:transparent;border:none;color:#c3c3c3;font:16px/14px Tahoma,Verdana,sans-serif;font-weight:700;height:14px;padding:4px 4px 0 0;position:absolute;right:0;text-align:center;text-decoration:none;top:0;width:18px}.leaflet-container a.leaflet-popup-close-button:hover{color:#999}.leaflet-popup-scrolled{border-bottom:1px solid #ddd;border-top:1px solid #ddd;overflow:auto}.leaflet-oldie .leaflet-popup-content-wrapper{zoom:1}.leaflet-oldie .leaflet-popup-tip{-ms-filter:"progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)";filter:progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678,M12=0.70710678,M21=-0.70710678,M22=0.70710678);margin:0 auto;width:24px}.leaflet-oldie .leaflet-popup-tip-container{margin-top:-1px}.leaflet-oldie .leaflet-control-layers,.leaflet-oldie .leaflet-control-zoom,.leaflet-oldie .leaflet-popup-content-wrapper,.leaflet-oldie .leaflet-popup-tip{border:1px solid #999}.leaflet-div-icon{background:#fff;border:1px solid #666}.leaflet-tooltip{background-color:#fff;border:1px solid #fff;border-radius:3px;box-shadow:0 1px 3px rgba(0,0,0,.4);color:#222;padding:6px;pointer-events:none;position:absolute;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;white-space:nowrap}.leaflet-tooltip.leaflet-clickable{cursor:pointer;pointer-events:auto}.leaflet-tooltip-bottom:before,.leaflet-tooltip-left:before,.leaflet-tooltip-right:before,.leaflet-tooltip-top:before{background:transparent;border:6px solid transparent;content:"";pointer-events:none;position:absolute}.leaflet-tooltip-bottom{margin-top:6px}.leaflet-tooltip-top{margin-top:-6px}.leaflet-tooltip-bottom:before,.leaflet-tooltip-top:before{left:50%;margin-left:-6px}.leaflet-tooltip-top:before{border-top-color:#fff;bottom:0;margin-bottom:-12px}.leaflet-tooltip-bottom:before{border-bottom-color:#fff;margin-left:-6px;margin-top:-12px;top:0}.leaflet-tooltip-left{margin-left:-6px}.leaflet-tooltip-right{margin-left:6px}.leaflet-tooltip-left:before,.leaflet-tooltip-right:before{margin-top:-6px;top:50%}.leaflet-tooltip-left:before{border-left-color:#fff;margin-right:-12px;right:0}.leaflet-tooltip-right:before{border-right-color:#fff;left:0;margin-left:-12px}';

// node_modules/@unovis/ts/components/leaflet-map/style.js
injectGlobal(css_248z);
var cssVarDefaults4 = {
  "--vis-map-container-background-color": "#dfe5eb",
  /* Undefined by default to allow proper fallback to var(--vis-font-family) */
  "--vis-map-label-font-family": void 0,
  "--vis-map-point-default-fill-color": "#B9BEC3",
  "--vis-map-point-ring-fill-color": "#ffffff",
  "--vis-map-point-default-stroke-color": "#959da3",
  "--vis-map-point-default-stroke-width": "0px",
  "--vis-map-point-default-cursor": "default",
  "--vis-map-cluster-default-fill-color": "#fff",
  "--vis-map-cluster-default-stroke-color": "#B9BEC3",
  "--vis-map-cluster-default-stroke-width": "1.5px",
  "--vis-map-cluster-donut-fill-color": "#959da3",
  "--vis-map-cluster-inner-label-text-color-dark": "#5b5f6d",
  "--vis-map-cluster-inner-label-text-color-light": "#fff",
  "--vis-map-point-inner-label-text-color-dark": "#5b5f6d",
  "--vis-map-point-inner-label-text-color-light": "#fff",
  "--vis-map-point-bottom-label-text-color": "#5b5f6d",
  "--vis-map-point-bottom-label-font-size": "10px",
  "--vis-map-cluster-expanded-background-fill-color": "#fff",
  /* Dark Theme */
  "--vis-dark-map-container-background-color": "#dfe5eb",
  "--vis-dark-map-point-default-fill-color": "#B9BEC3",
  "--vis-dark-map-point-default-stroke-color": "#959da3",
  "--vis-dark-map-point-ring-fill-color": "#5b5f6d",
  "--vis-dark-map-cluster-default-fill-color": "#5b5f6d",
  "--vis-dark-map-cluster-default-stroke-color": "#B9BEC3",
  "--vis-dark-map-cluster-donut-fill-color": "#959da3",
  "--vis-dark-map-cluster-inner-label-text-color-dark": "#5b5f6d",
  "--vis-dark-map-cluster-inner-label-text-color-light": "#fff",
  "--vis-dark-map-point-inner-label-text-color-dark": "#5b5f6d",
  "--vis-dark-map-point-inner-label-text-color-light": "#fff",
  "--vis-dark-map-point-bottom-label-text-color": "#5b5f6d",
  "--vis-dark-map-cluster-expanded-background-fill-color": "#fff"
};
var root17 = css`
  label: leaflet-map-component;

  width: 100%;
  height: 100%;
  position: absolute;
  background-color: var(--vis-map-container-background-color);

  canvas {
    pointer-events: all;
  }
`;
var variables9 = getCssVarNames(cssVarDefaults4);
injectGlobalCssVariables(cssVarDefaults4, root17);
var background4 = `${root17} canvas`;
var points2 = css`
  label: g-points;
`;
var point12 = css`
  label: g-point;
`;
var pointPath = css`
  label: point-path;

  stroke-opacity: 1;
  fill-opacity: 1.0;
  fill: var(${variables9.mapPointDefaultFillColor});
  stroke: var(${variables9.mapPointDefaultStrokeColor});
  stroke-width: var(${variables9.mapPointDefaultStrokeWidth});
  pointer-events: fill !important;
  transition: .2s stroke-width, .3s transform;
  cursor: var(${variables9.mapPointDefaultCursor});

  &:hover {
    stroke-width: 2;
    fill-opacity: 1;
    animation: none;
    transform: scale(1.1);
  }
`;
var pointPathRing = css`
  label: point-path-ring;
  fill: var(${variables9.mapPointRingFillColor});
`;
var pointPathCluster = css`
  label: point-path-cluster;
  fill-opacity: 0.9;
  stroke: none;
  animation: none;
  fill: var(${variables9.mapClusterDefaultFillColor});
  stroke: var(${variables9.mapClusterDefaultStrokeColor});
  stroke-width: var(${variables9.mapClusterDefaultStrokeWidth});
`;
var pointSelectionRing = css`
  label: point-selection-ring;
  stroke: var(${variables9.mapPointDefaultFillColor});
`;
var pointSelection = css`
  label: point-selection;

  opacity: 0;
  transform: scale(1);

  &.active {
    transition: all 400ms cubic-bezier(0.230, 1.000, 0.320, 1.000);
    opacity: 1;
    transform: scale(1.25);
  }
`;
var innerLabel = css`
  label: inner-label;

  text-anchor: middle;
  fill: var(${variables9.mapPointInnerLabelTextColorDark});
  font-family: var(${variables9.mapLabelFontFamily}, var(--vis-font-family));
  pointer-events: none;
  font-weight: 600;
`;
var innerLabelCluster = css`
  label: inner-label-cluster;
  fill: var(${variables9.mapPointInnerLabelTextColorDark});
`;
var bottomLabel = css`
  label: bottom-label;

  text-anchor: middle;
  fill: var(${variables9.mapPointBottomLabelTextColor});
  font-family: var(${variables9.mapLabelFontFamily}, var(--vis-font-family));
  pointer-events: none;
  font-weight: 600;
`;
var donutCluster = css`
  label: donut-cluster;

  transform: scale(1);
  transition: .3s transform;
  path {
    fill: var(${variables9.mapClusterDonutFillColor});
    stroke-width: 0.5;
  }

  &:hover {
    transform: scale(1.1);
  }
`;
var svgOverlay = css`
  label: svg-overlay;
  position: absolute;
  pointer-events: none;
`;
var backgroundRect = css`
  label: background-rect;

  opacity: 0;
`;
var clusterBackground = css`
  label: cluster-background;

  fill: var(${variables9.mapClusterExpandedBackgroundFillColor});
  opacity: 0.6;
  visibility: hidden;

  &.active {
    visibility: visible;
  }
`;
var onFeatureHover = css`
  label: feature-hovered;
`;
var mapboxglCanvas = css`
  pointer-events: all;
  cursor: grab;

  &${`.${onFeatureHover}`} {
    cursor: default;
  }
`;
var map4 = css`
  label: map;
`;

// node_modules/tslib/tslib.es6.mjs
function __awaiter(thisArg, _arguments, P5, generator) {
  function adopt(value2) {
    return value2 instanceof P5 ? value2 : new P5(function(resolve) {
      resolve(value2);
    });
  }
  return new (P5 || (P5 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@unovis/ts/components/leaflet-map/modules/map.js
var initialMapCenter = [36, 14];
var initialMapZoom = 1.9;
function updateTopoJson(maplibreMap, config) {
  var _a, _b;
  const { topoJSONLayer } = config;
  if (topoJSONLayer.sources) {
    const featureObject = (_b = (_a = topoJSONLayer.sources) === null || _a === void 0 ? void 0 : _a.objects) === null || _b === void 0 ? void 0 : _b[topoJSONLayer.featureName];
    if (featureObject) {
      const mapSource = maplibreMap.getSource(topoJSONLayer.featureName);
      const featureCollection = feature_default(topoJSONLayer.sources, featureObject);
      if (mapSource) {
        mapSource.setData(featureCollection);
      } else {
        maplibreMap.addSource(topoJSONLayer.featureName, { type: "geojson", data: featureCollection });
      }
    }
  }
  const fillLayer = maplibreMap.getLayer(`${topoJSONLayer.featureName}-area`);
  if (topoJSONLayer.fillProperty) {
    if (!fillLayer) {
      maplibreMap.addLayer({
        id: `${topoJSONLayer.featureName}-area`,
        type: "fill",
        source: topoJSONLayer.featureName,
        paint: {
          // eslint-disable-next-line @typescript-eslint/naming-convention
          "fill-antialias": false,
          // eslint-disable-next-line @typescript-eslint/naming-convention
          "fill-opacity": topoJSONLayer.fillOpacity
        }
      });
    }
    maplibreMap.setPaintProperty(`${topoJSONLayer.featureName}-area`, "fill-color", [
      "case",
      ["!", ["has", topoJSONLayer.fillProperty]],
      "rgba(255, 255, 255, 0)",
      ["get", topoJSONLayer.fillProperty]
    ]);
  } else if (fillLayer)
    maplibreMap.removeLayer(`${topoJSONLayer.featureName}-area`);
  const strokeLayer = maplibreMap.getLayer(`${topoJSONLayer.featureName}-stroke`);
  if (topoJSONLayer.strokeProperty) {
    if (!strokeLayer) {
      maplibreMap.addLayer({
        id: `${topoJSONLayer.featureName}-stroke`,
        type: "line",
        source: topoJSONLayer.featureName,
        paint: {
          // eslint-disable-next-line @typescript-eslint/naming-convention
          "line-opacity": topoJSONLayer.strokeOpacity,
          // eslint-disable-next-line @typescript-eslint/naming-convention
          "line-width": topoJSONLayer.strokeWidth
        }
      });
    }
    maplibreMap.setPaintProperty(`${topoJSONLayer.featureName}-stroke`, "line-color", [
      "case",
      ["!", ["has", topoJSONLayer.strokeProperty]],
      "rgba(255, 255, 255, 0)",
      ["get", topoJSONLayer.strokeProperty]
    ]);
  } else if (strokeLayer) {
    maplibreMap.removeLayer(`${topoJSONLayer.featureName}-stroke`);
  }
}
function setupMap(mapContainer, config) {
  var _a, _b;
  return __awaiter(this, void 0, void 0, function* () {
    const { style, renderer, topoJSONLayer } = config;
    const leaflet = yield import("./leaflet-src-CNCCP7I6.js");
    const L6 = leaflet.default;
    if (!style) {
      console.error("Unovis | Leaflet Map: Please provide style settings in the map configuration object");
      return;
    }
    const leafletMap = L6.map(mapContainer, {
      scrollWheelZoom: renderer === LeafletMapRenderer.Raster,
      zoomControl: false,
      zoomDelta: renderer === LeafletMapRenderer.Raster ? 1 : 0.5,
      zoomSnap: renderer === LeafletMapRenderer.Raster ? 1 : 0,
      attributionControl: true,
      center: initialMapCenter,
      zoom: initialMapZoom,
      minZoom: Math.sqrt(mapContainer.offsetWidth) / 17,
      maxZoom: 23,
      maxBounds: L6.latLngBounds([-75, -290], [85, 290]),
      maxBoundsViscosity: 1
    });
    for (const attr of config.attribution) {
      leafletMap.attributionControl.addAttribution(attr);
    }
    let layer;
    let maplibreMap = null;
    switch (renderer) {
      case LeafletMapRenderer.MapLibre:
        const maplibre = yield import("./maplibre-gl-JOA22XFC.js");
        const { getMaplibreGLLayer } = yield import("./mapboxgl-layer-2OSF4AO3.js");
        layer = getMaplibreGLLayer(config, L6, maplibre.default);
        layer.addTo(leafletMap);
        maplibreMap = (_b = (_a = layer).getMaplibreMap) === null || _b === void 0 ? void 0 : _b.call(_a);
        select_default2(mapContainer).on("wheel", (event) => {
          event.preventDefault();
          mapboxglWheelEventThrottled(leafletMap, layer, event);
        });
        break;
      case LeafletMapRenderer.Raster:
        layer = L6.tileLayer(style);
        layer.addTo(leafletMap);
        break;
    }
    constraintMapView(leafletMap);
    if (maplibreMap && (topoJSONLayer === null || topoJSONLayer === void 0 ? void 0 : topoJSONLayer.sources)) {
      const canvas = maplibreMap.getCanvas();
      const canvasSelection = select_default2(canvas).classed(mapboxglCanvas, true);
      const tilePaneSelection = select_default2(leafletMap.getPanes().tilePane);
      maplibreMap.on("mousemove", (event) => {
        const layerName = `${topoJSONLayer.featureName}-area`;
        const layer2 = maplibreMap.getLayer(layerName);
        if (!layer2)
          return;
        const features2 = maplibreMap.queryRenderedFeatures(event.point, { layers: [layerName] });
        tilePaneSelection.datum(features2[0]);
        canvasSelection.classed(onFeatureHover, Boolean(features2[0]));
      });
      maplibreMap.on("load", () => {
        updateTopoJson(maplibreMap, config);
      });
    }
    const svgOverlay2 = select_default2(leafletMap.getPanes().overlayPane).append("svg");
    const svgGroup = svgOverlay2.append("g");
    return {
      leaflet: leafletMap,
      layer,
      svgOverlay: svgOverlay2,
      svgGroup
    };
  });
}

// node_modules/@unovis/ts/components/leaflet-map/modules/donut.js
var pieConstructor = pie_default().sort(null).value((d18) => d18.value);
function updateDonut(selection2, data, radius, arcWidth = 2, padAngle = 0.05) {
  pieConstructor.padAngle(padAngle);
  const arcs = pieConstructor(data.filter((d18) => d18.value));
  const arcPathGen = arc_default().innerRadius(arcWidth ? radius - arcWidth / 2 : 0).outerRadius(arcWidth ? radius + arcWidth / 2 : radius);
  const donuts = selection2.selectAll("path").data(arcs);
  donuts.exit().remove();
  donuts.enter().append("path").merge(donuts).attr("class", (d18) => {
    var _a;
    return (_a = d18.data.className) !== null && _a !== void 0 ? _a : null;
  }).attr("d", arcPathGen).style("fill", (d18) => {
    var _a;
    return (_a = d18.data.color) !== null && _a !== void 0 ? _a : null;
  }).style("stroke", (d18) => {
    var _a;
    return (_a = d18.data.color) !== null && _a !== void 0 ? _a : null;
  });
}

// node_modules/@unovis/ts/components/leaflet-map/modules/node.js
var BOTTOM_LABEL_TOP_MARGIN = 10;
function createNodes2(selection2) {
  selection2.append("path").attr("class", pointPath).attr("id", (d18) => `point-${d18.id}`).style("opacity", 0);
  selection2.append("g").attr("class", donutCluster);
  selection2.append("text").attr("class", innerLabel).classed(innerLabelCluster, (d18) => d18.properties.cluster).attr("id", (d18) => `label-${d18.id}`).attr("dy", "0.32em");
  selection2.append("text").attr("class", bottomLabel).attr("dy", "0.32em").attr("opacity", 1);
}
function updateNodes2(selection2, config, leafletMap, mapMoveZoomUpdateOnly) {
  selection2.each((d18, i8, elements) => {
    var _a, _b, _c;
    const group3 = select_default2(elements[i8]);
    const node4 = group3.select(`.${pointPath}`);
    const innerLabel$1 = group3.select(`.${innerLabel}`);
    const bottomLabel$1 = group3.select(`.${bottomLabel}`);
    const { x: x21, y: y25 } = getPointPos(d18, leafletMap);
    const donutData = d18.donutData;
    const isCluster = d18.properties.cluster;
    const fromExpandedCluster = !!d18.properties.expandedClusterPoint;
    const innerLabelText = (_a = isCluster ? getString(d18.properties, config.clusterLabel) : getString(d18.properties, config.pointLabel)) !== null && _a !== void 0 ? _a : "";
    const innerLabelColor = (_b = isCluster ? getString(d18.properties, config.clusterLabelColor) : getString(d18.properties, config.pointLabelColor)) !== null && _b !== void 0 ? _b : null;
    const bottomLabelText = (_c = isCluster ? getString(d18.properties, config.clusterBottomLabel) : getString(d18.properties, config.pointBottomLabel)) !== null && _c !== void 0 ? _c : "";
    const pointCursor = getString(d18.properties, config.pointCursor);
    const pointShape = getString(d18.properties, config.pointShape);
    const isRing = pointShape === LeafletMapPointShape.Ring;
    const isCircular = pointShape === LeafletMapPointShape.Circle || isRing || isCluster || !pointShape;
    const ringWidth = isCluster && config.clusterRingWidth || isRing && config.pointRingWidth || 0;
    group3.attr("transform", `translate(${x21},${y25})`);
    group3.select(`.${donutCluster}`).call(updateDonut, donutData, isCircular ? d18.radius : 0, ringWidth);
    node4.attr("d", d18.path);
    node4.style("cursor", isCluster ? "pointer" : pointCursor);
    bottomLabel$1.attr("transform", `translate(0,${d18.radius + BOTTOM_LABEL_TOP_MARGIN})`);
    innerLabel$1.attr("font-size", () => {
      const fontSize = d18.radius / Math.pow(innerLabelText.length, 0.4);
      return clamp(fontSize, fontSize, 16);
    });
    if (mapMoveZoomUpdateOnly)
      return;
    node4.classed(pointPathCluster, isCluster).classed(pointPathRing, isRing).style("fill", d18.color).style("stroke", d18.color).style("stroke-width", ringWidth).style("opacity", 1);
    innerLabel$1.text(innerLabelText || null).attr("visibility", innerLabelText ? null : "hidden").style("fill", () => {
      var _a2;
      if (innerLabelColor)
        return innerLabelColor;
      const c6 = getComputedStyle(node4.node()).fill;
      const hex2 = (_a2 = color(c6)) === null || _a2 === void 0 ? void 0 : _a2.hex();
      if (!hex2)
        return null;
      const brightness = hexToBrightness(hex2);
      return brightness > 0.5 ? isCluster ? cssvar(variables9.mapClusterInnerLabelTextColorDark) : cssvar(variables9.mapPointInnerLabelTextColorDark) : isCluster ? cssvar(variables9.mapClusterInnerLabelTextColorLight) : cssvar(variables9.mapPointInnerLabelTextColorLight);
    });
    const bottomLabelTextTrimmed = trimStringMiddle(bottomLabelText, 15);
    bottomLabel$1.text(bottomLabelTextTrimmed).attr("font-size", getCSSVariableValueInPixels(cssvar(variables9.mapPointBottomLabelFontSize), selection2.node())).attr("visibility", fromExpandedCluster ? "hidden" : null);
  });
}
function collideLabels2(selection2, leafletMap) {
  selection2.each((datum1, i8, elements) => {
    const group1LabelElement = elements[i8];
    const group1 = select_default2(group1LabelElement);
    const label1 = group1.select(`.${bottomLabel}`);
    group1LabelElement.labelVisible = true;
    const bottomLabelFontSizePx = getCSSVariableValueInPixels(cssvar(variables9.mapPointBottomLabelFontSize), selection2.node());
    const p1Pos = getPointPos(datum1, leafletMap);
    const label1Size = estimateTextSize(label1, bottomLabelFontSizePx, 0.32, true, 0.6);
    const label1BoundingRect = {
      x: p1Pos.x - label1Size.width / 2,
      y: p1Pos.y - label1Size.height / 2 + datum1.radius + BOTTOM_LABEL_TOP_MARGIN,
      width: label1Size.width,
      height: label1Size.height
    };
    for (let j6 = 0; j6 < elements.length; j6 += 1) {
      if (i8 === j6)
        continue;
      const group2LabelElement = elements[j6];
      const group22 = select_default2(group2LabelElement);
      const label22 = group22.select(`.${bottomLabel}`);
      const datum2 = group22.datum();
      const p2Pos = getPointPos(datum2, leafletMap);
      const point2BoundingRect = {
        x: p2Pos.x - datum2.radius,
        y: p2Pos.y - datum2.radius,
        width: 2 * datum2.radius,
        height: 2 * datum2.radius
      };
      let intersect2 = rectIntersect(label1BoundingRect, point2BoundingRect);
      const label2Visible = group2LabelElement.labelVisible;
      if (!intersect2 && label2Visible) {
        const label2Size = estimateTextSize(label22, bottomLabelFontSizePx, 0.32, true, 0.6);
        intersect2 = rectIntersect(label1BoundingRect, {
          x: p2Pos.x - label2Size.width / 2,
          y: p2Pos.y + datum2.radius + BOTTOM_LABEL_TOP_MARGIN - label2Size.height / 2,
          width: label2Size.width,
          height: label2Size.height
        });
      }
      if (intersect2) {
        group1LabelElement.labelVisible = false;
        break;
      }
    }
    smartTransition(label1, 0).attr("opacity", group1LabelElement.labelVisible ? 1 : 0);
  });
}
function removeNodes2(selection2) {
  selection2.remove();
}

// node_modules/@unovis/ts/components/leaflet-map/modules/selectionRing.js
function createNodeSelectionRing(selection2) {
  selection2.datum({ _zIndex: 3 });
  selection2.append("path").attr("class", pointSelection);
}
function updateNodeSelectionRing(selection2, selectedPoint, pointData, config, leafletMap) {
  selection2.attr("class", pointSelectionRing);
  const pointSelection$1 = selection2.select(`.${pointSelection}`);
  if (selectedPoint) {
    const isCluster = selectedPoint.isCluster;
    const selectedPointId = getString(selectedPoint.properties, config.pointId);
    const foundPoint = pointData.find((d18) => isCluster ? d18.id === selectedPoint.id : selectedPointId && getString(d18.properties, config.pointId) === selectedPointId);
    selection2.attr("transform", (d18) => {
      const { x: x21, y: y25 } = getPointPos(foundPoint !== null && foundPoint !== void 0 ? foundPoint : selectedPoint, leafletMap);
      return `translate(${x21},${y25})`;
    }).classed(`${selectedPoint.properties.shape}`, true);
    pointSelection$1.classed("active", Boolean(foundPoint)).attr("d", foundPoint ? foundPoint.path : null).style("fill", "transparent").style("stroke-width", 1).style("stroke", (d18) => {
      const node4 = foundPoint || selectedPoint;
      return node4 === null || node4 === void 0 ? void 0 : node4.color;
    });
  } else {
    pointSelection$1.classed("active", false);
  }
}

// node_modules/@unovis/ts/components/leaflet-map/modules/clusterBackground.js
function createBackgroundNode(selection2) {
  selection2.datum({ _zIndex: 1 });
  selection2.append("path");
}
function updateBackgroundNode(selection2, expandedCluster, config, leafletMap, clusterBackgroundRadius) {
  const { clusterBackground: clusterBackground2 } = config;
  if (expandedCluster && clusterBackground2) {
    const node4 = cloneDeep(expandedCluster.cluster);
    const { x: x21, y: y25 } = getPointPos(node4, leafletMap);
    const path3 = getNodePathData({ x: 0, y: 0 }, clusterBackgroundRadius, LeafletMapPointShape.Circle);
    selection2.select("path").attr("d", (d18) => path3);
    selection2.classed("active", true).attr("transform", `translate(${x21},${y25})`);
  } else {
    selection2.classed("active", false);
  }
}

// node_modules/@unovis/ts/components/leaflet-map/index.js
var LeafletMap = class _LeafletMap extends ComponentCore {
  constructor(container, config, data) {
    super(ComponentType.HTML);
    this._defaultConfig = LeafletMapDefaultConfig;
    this.config = this._defaultConfig;
    this.type = ComponentType.HTML;
    this.datamodel = new MapDataModel();
    this._expandedCluster = null;
    this._cancelBackgroundClick = false;
    this._hasBeenMoved = false;
    this._hasBeenZoomed = false;
    this._isMoving = false;
    this._isZooming = false;
    this._eventInitiatedByComponent = false;
    this._triggerBackgroundClick = false;
    this._externallySelectedPoint = null;
    this._zoomingToExternallySelectedPoint = false;
    this._forceExpandCluster = false;
    this._clusterBackgroundRadius = 0;
    this._selectedPoint = null;
    this._currentZoomLevel = null;
    this._firstRender = true;
    this._isDarkThemeActive = false;
    this._renderDataAnimationFrameId = null;
    this._flyToBoundsAnimationFrameId = null;
    this.events = {
      [_LeafletMap.selectors.point]: {
        mouseup: this._onPointMouseUp.bind(this),
        mousedown: this._onPointMouseDown.bind(this),
        click: this._onPointClick.bind(this)
      }
    };
    this._container = container;
    this._containerSelection = select_default2(this._container).attr("role", "figure");
    this._container.appendChild(this.element);
    this.g.attr("class", root17).attr("aria-hidden", true);
    if (config)
      this.setConfig(config);
    if (!this._container.clientWidth) {
      console.warn("Unovis | Leaflet Map: The width of the container is not set. Setting to 100%.");
      this._containerSelection.style("width", "100%");
    }
    if (!this._container.clientHeight) {
      console.warn(`Unovis | Leaflet Map: The height of the container is not set. Setting to ${_LeafletMap.DEFAULT_CONTAINER_HEIGHT}px.`);
      this._containerSelection.style("height", `${_LeafletMap.DEFAULT_CONTAINER_HEIGHT}px`);
    }
    this._leafletInitializationPromise = new Promise((resolve) => {
      setupMap(this.element, this.config).then((map$1) => {
        var _a, _b;
        select_default2(map$1.leaflet.getPanes().tilePane).classed(map4, true);
        if (config)
          this.setConfig(config);
        this._map = map$1;
        this._map.leaflet.on("drag", this._onMapDragLeaflet.bind(this));
        this._map.leaflet.on("move", this._onMapMove.bind(this));
        this._map.leaflet.on("movestart", this._onMapMoveStart.bind(this));
        this._map.leaflet.on("moveend", this._onMapMoveEnd.bind(this));
        this._map.leaflet.on("zoom", this._onMapZoom.bind(this));
        this._map.leaflet.on("zoomstart", this._onMapZoomStart.bind(this));
        this._map.leaflet.on("zoomend", this._onMapZoomEnd.bind(this));
        this._map.leaflet.on("mousedown", () => {
          if (!this._cancelBackgroundClick)
            this._triggerBackgroundClick = true;
        });
        this._map.leaflet.on("mouseup", (e3) => {
          if (this._triggerBackgroundClick) {
            this._triggerBackgroundClick = false;
            const originalEvent = e3.originalEvent;
            this._onBackgroundClick(originalEvent.target, originalEvent);
          }
        });
        this._map.svgOverlay.attr("class", svgOverlay).insert("rect", ":first-child").attr("class", backgroundRect).attr("width", "100%").attr("height", "100%");
        this._pointGroup = this._map.svgGroup.append("g").attr("class", points2);
        this._clusterBackground = this._pointGroup.append("g").attr("class", clusterBackground).call(createBackgroundNode);
        this._pointSelectionRing = this._pointGroup.append("g").attr("class", pointSelectionRing).call(createNodeSelectionRing);
        this._map.leaflet.setView(initialMapCenter, initialMapZoom);
        if (document.body.classList.contains("theme-dark") && config.styleDarkTheme) {
          this._isDarkThemeActive = true;
          this.setTheme(config.styleDarkTheme);
        }
        (_b = (_a = this.config).onMapInitialized) === null || _b === void 0 ? void 0 : _b.call(_a);
        resolve(this._map.leaflet);
      });
    });
    this.setData(data !== null && data !== void 0 ? data : []);
    this.resizeObserver = new ResizeObserver2(() => {
      var _a, _b, _c;
      (_b = (_a = this._map) === null || _a === void 0 ? void 0 : _a.leaflet) === null || _b === void 0 ? void 0 : _b.invalidateSize();
      (_c = this.config.tooltip) === null || _c === void 0 ? void 0 : _c.hide();
    });
    this.resizeObserver.observe(container);
    if (this.config.styleDarkTheme) {
      this.themeObserver = new MutationObserver((mutations) => {
        mutations.forEach((change) => {
          if (change.attributeName === "class") {
            const isDarkTheme = change.target.classList.contains("theme-dark");
            if (this._isDarkThemeActive !== isDarkTheme) {
              this.setTheme(isDarkTheme ? this.config.styleDarkTheme : this.config.style);
              this._isDarkThemeActive = isDarkTheme;
            }
          }
        });
      });
      this.themeObserver.observe(document.body, { attributes: true });
    }
  }
  setConfig(config) {
    super.setConfig(config);
    if (config.width)
      this._containerSelection.style("width", isString(config.width) ? config.width : `${config.width}px`);
    if (config.height)
      this._containerSelection.style("height", isString(config.height) ? config.height : `${config.height}px`);
    if (this._map && config.renderer === LeafletMapRenderer.MapLibre) {
      const layer = this._map.layer;
      const maplibreMap = layer.getMaplibreMap();
      if (maplibreMap.isStyleLoaded())
        updateTopoJson(maplibreMap, this.config);
    }
    if (this.config.tooltip) {
      this.config.tooltip.setContainer(this._container);
      this.config.tooltip.setComponents([this]);
      this.config.tooltip.update();
    }
    this._containerSelection.attr("aria-label", config.ariaLabel);
  }
  setData(data) {
    const { config, datamodel } = this;
    const dataValid = data.filter((d18) => {
      const lat = getNumber(d18, config.pointLatitude);
      const lon = getNumber(d18, config.pointLongitude);
      const valid = isFinite(lat) && isFinite(lon);
      if (!valid)
        console.warn("Unovis | Leaflet Map: Invalid point coordinates", d18);
      return valid;
    });
    datamodel.data = dataValid;
    this._clusterIndex = calculateClusterIndex(dataValid, this.config);
    if (this._expandedCluster && this._map.leaflet) {
      const expandedCluster = this._expandedCluster;
      this._resetExpandedCluster();
      const pointData = this._getPointData();
      const expandedClusterCenterPx = projectPoint(expandedCluster.cluster, this._map.leaflet);
      const expandedClusterRadiusPx = expandedCluster.cluster.radius;
      const cluster2 = pointData.find((c6) => {
        if (!c6.isCluster)
          return false;
        const pos = projectPoint(c6, this._map.leaflet);
        const r4 = c6.radius;
        const distance = Math.sqrt(Math.pow(expandedClusterCenterPx.x - pos.x, 2) + Math.pow(expandedClusterCenterPx.y - pos.y, 2));
        return distance < expandedClusterRadiusPx + r4;
      });
      if (cluster2)
        this._expandCluster(cluster2, true);
    }
    this._leafletInitializationPromise.then(() => {
      this.render();
    });
  }
  setTheme(theme) {
    var _a;
    const layer = this._map.layer;
    if (this.config.renderer === LeafletMapRenderer.MapLibre) {
      const maplibreMap = layer.getMaplibreMap();
      (_a = maplibreMap.setStyle) === null || _a === void 0 ? void 0 : _a.call(maplibreMap, theme);
      updateTopoJson(maplibreMap, this.config);
    } else {
      if (typeof theme !== "string") {
        console.warn("Unovis | Leaflet Map: Invalid style. Provide a URL string for raster rendering mode.");
        return;
      }
      layer.setUrl(theme);
    }
  }
  // We redefine the ComponentCore render function to bind event to newly created elements in this._renderData(),
  // which is being called after almost every map interaction
  render() {
    const { config } = this;
    if (!this._map)
      return;
    this._renderData();
    if (this._firstRender) {
      if (config.initialBounds)
        this.fitToBounds(config.initialBounds);
      else if (config.fitViewOnInit)
        this.fitToPoints(0, config.fitViewPadding);
    } else {
      if (config.fitViewOnUpdate)
        this.fitToPoints(0, config.fitViewPadding);
      else if (config.fitBoundsOnUpdate)
        this.fitToBounds(config.fitBoundsOnUpdate);
    }
    this._firstRender = false;
  }
  getLeafletInstancePromise() {
    return this._leafletInitializationPromise;
  }
  fitToPoints(duration = this.config.flyToDuration, padding = this.config.fitViewPadding) {
    const { config, datamodel, datamodel: { data } } = this;
    if (!this._map || !this._map.leaflet)
      return;
    if (!(data === null || data === void 0 ? void 0 : data.length))
      return;
    const bounds = datamodel.getDataLatLngBounds(config.pointLatitude, config.pointLongitude);
    this._flyToBoundsAnimationFrameId = requestAnimationFrame(() => this._flyToBounds(bounds, duration, padding));
  }
  fitToBounds(bounds, duration = this.config.flyToDuration, padding = this.config.fitViewPadding) {
    const { northEast, southWest } = bounds;
    if (isNil(northEast) || isNil(southWest))
      return;
    if (isNil(northEast.lat) || isNil(northEast.lng))
      return;
    if (isNil(southWest.lat) || isNil(southWest.lng))
      return;
    if (!this._map || !this._map.leaflet)
      return;
    this._flyToBoundsAnimationFrameId = requestAnimationFrame(() => this._flyToBounds([
      [northEast.lat, southWest.lng],
      [southWest.lat, northEast.lng]
    ], duration, padding));
  }
  /* Select a point by id and optionally center the map view.
   * This method was designed to be used mainly with the `[LeafletMap.selectors.point]` click events
   * (when the user actually clicks on a point) and the specified point is inside one of the collapsed
   * clusters it won't be selected. You can use the `zoomToPointById` method to achieve that.
   */
  selectPointById(id2, centerView = false) {
    var _a, _b, _c;
    const { config } = this;
    const pointData = this._getPointData();
    const foundPoint = pointData.find((d18) => d18.properties.id === id2);
    if (!foundPoint) {
      console.warn(`Unovis | Leaflet Map: Node with id ${id2} can not be found`);
      return;
    }
    if ((_a = foundPoint.properties) === null || _a === void 0 ? void 0 : _a.cluster) {
      console.warn("Unovis | Leaflet Map: Cluster can't be selected");
      return;
    }
    this._selectedPoint = foundPoint;
    const isPointInsideExpandedCluster = (_c = (_b = this._expandedCluster) === null || _b === void 0 ? void 0 : _b.points) === null || _c === void 0 ? void 0 : _c.find((d18) => getString(d18.properties, config.pointId) === id2);
    if (!isPointInsideExpandedCluster)
      this._resetExpandedCluster();
    if (centerView) {
      const coordinates = {
        lng: getNumber(foundPoint.properties, config.pointLongitude),
        lat: getNumber(foundPoint.properties, config.pointLatitude)
      };
      const zoomLevel = this._map.leaflet.getZoom();
      this._eventInitiatedByComponent = true;
      this._map.leaflet.flyTo(coordinates, zoomLevel, { duration: 0 });
    } else {
      this._renderData();
    }
  }
  /* Get the id of the selected point */
  getSelectedPointId() {
    var _a;
    return (_a = this._selectedPoint) === null || _a === void 0 ? void 0 : _a.id;
  }
  /* Unselect point if it was selected before */
  unselectPoint() {
    this._selectedPoint = null;
    this._externallySelectedPoint = null;
    this.render();
  }
  /** Get the currently expanded cluster */
  getExpandedCluster() {
    var _a, _b;
    if (!this._expandedCluster)
      return;
    const id2 = (_a = this._expandedCluster.cluster) === null || _a === void 0 ? void 0 : _a.id;
    const points3 = (_b = this._expandedCluster.cluster) === null || _b === void 0 ? void 0 : _b.clusterPoints.map((d18) => this.datamodel.data[d18._index]);
    return { id: id2, points: points3 };
  }
  /* Zoom to a point by id and optionally select it.
   * If the point is inside a cluster, it'll be automatically expanded to show the enclosed point.
   * You can also force set the zoom level by providing the `customZoomLevel` argument.
   */
  zoomToPointById(id2, selectPoint = false, customZoomLevel) {
    var _a, _b, _c;
    const { config, datamodel } = this;
    if (!datamodel.data.length) {
      console.warn("Unovis | Leaflet Map: There are no points on the map");
      return;
    }
    const dataBoundsAll = datamodel.getDataLatLngBounds(config.pointLatitude, config.pointLongitude);
    const bounds = [dataBoundsAll[0][1], dataBoundsAll[1][0], dataBoundsAll[1][1], dataBoundsAll[0][0]];
    const pointDataAll = this._getPointData(bounds);
    let foundPoint = pointDataAll.find((d18) => getString(d18.properties, config.pointId) === id2);
    if ((_a = foundPoint === null || foundPoint === void 0 ? void 0 : foundPoint.properties) === null || _a === void 0 ? void 0 : _a.cluster) {
      console.warn("Unovis | Leaflet Map: Cluster can't be zoomed in");
      return;
    }
    if (!foundPoint) {
      const { point: point13 } = findPointAndClusterByPointId(pointDataAll, id2, config.pointId);
      foundPoint = point13;
    }
    if (foundPoint) {
      const isPointInsideExpandedCluster = (_c = (_b = this._expandedCluster) === null || _b === void 0 ? void 0 : _b.points) === null || _c === void 0 ? void 0 : _c.find((d18) => getString(d18.properties, config.pointId) === id2);
      if (isPointInsideExpandedCluster && selectPoint) {
        this._selectedPoint = foundPoint;
        this._renderData();
        return;
      }
      this._externallySelectedPoint = foundPoint;
      this._zoomingToExternallySelectedPoint = true;
      this._forceExpandCluster = !isNil(customZoomLevel);
      if (selectPoint)
        this._selectedPoint = foundPoint;
      const zoomLevel = isNil(customZoomLevel) ? this._map.leaflet.getZoom() : customZoomLevel;
      const pointDatum = foundPoint.properties;
      const coordinates = {
        lng: getNumber(pointDatum, config.pointLongitude),
        lat: getNumber(pointDatum, config.pointLatitude)
      };
      this._eventInitiatedByComponent = true;
      this._map.leaflet.flyTo(coordinates, zoomLevel, { duration: 0 });
    } else {
      console.warn(`Unovis | Leaflet Map: Node with id ${id2} can not be found`);
    }
  }
  getNodeRelativePosition(node4) {
    return getNodeRelativePosition(node4, this._map.leaflet);
  }
  hasBeenZoomed() {
    return this._hasBeenZoomed;
  }
  hasBeenMoved() {
    return this._hasBeenMoved;
  }
  isZooming() {
    return this._isZooming;
  }
  isMoving() {
    return this._isMoving;
  }
  _flyToBounds(bounds, durationMs, paddingPx) {
    this._eventInitiatedByComponent = true;
    const duration = durationMs / 1e3;
    const padding = paddingPx ? [
      paddingPx[0] < this._container.clientWidth / 2 ? paddingPx[0] : this._container.clientWidth / 2,
      paddingPx[1] < this._container.clientHeight / 2 ? paddingPx[1] : this._container.clientHeight / 2
    ] : void 0;
    if (duration) {
      this._map.leaflet.flyToBounds(bounds, { duration, padding });
    } else {
      this._map.leaflet.fitBounds(bounds, { padding });
    }
  }
  _renderData(mapMoveZoomUpdateOnly = false) {
    var _a;
    const { config } = this;
    const pointData = this._getPointData();
    const contentBBox = pointData.length ? bBoxMerge(pointData.map((d18) => d18.bbox)) : { x: 0, y: 0, width: 0, height: 0 };
    const svgExtraPadding = 40 + this._clusterBackgroundRadius;
    const dx = contentBBox.x - svgExtraPadding;
    const dy = contentBBox.y - svgExtraPadding;
    this._map.svgOverlay.attr("width", contentBBox.width + 2 * svgExtraPadding).attr("height", contentBBox.height + 2 * svgExtraPadding).style("left", `${dx}px`).style("top", `${dy}px`);
    this._map.svgGroup.attr("transform", `translate(${-dx},${-dy})`);
    const points3 = this._pointGroup.selectAll(`.${point12}:not(.exit)`).data(pointData, (d18, i8) => `${d18.id || d18.geometry.coordinates.join("")}`);
    points3.exit().classed("exit", true).call(removeNodes2);
    const pointsEnter = points3.enter().append("g").attr("class", point12).call(createNodes2);
    const pointsMerged = points3.merge(pointsEnter);
    pointsEnter.call(updateNodes2, config, this._map.leaflet);
    points3.call(updateNodes2, config, this._map.leaflet, mapMoveZoomUpdateOnly);
    pointsMerged.call(collideLabels2, this._map.leaflet);
    this._clusterBackground.call(updateBackgroundNode, this._expandedCluster, config, this._map.leaflet, this._clusterBackgroundRadius);
    if (this._expandedCluster && config.clusterBackground) {
      pointData.forEach((d18, i8) => {
        var _a2;
        d18._zIndex = ((_a2 = d18.properties) === null || _a2 === void 0 ? void 0 : _a2.expandedClusterPoint) ? 2 : 0;
      });
      this._pointGroup.selectAll(`.${point12}, .${clusterBackground}, .${pointSelectionRing}`).sort((a7, b25) => a7._zIndex - b25._zIndex);
    }
    if (config.selectedPointId) {
      const foundPoint = pointData.find((d18) => getString(d18.properties, config.pointId) === config.selectedPointId);
      const { cluster: cluster2 } = findPointAndClusterByPointId(pointData, config.selectedPointId, config.pointId);
      if (foundPoint)
        this._selectedPoint = foundPoint;
      else
        this._selectedPoint = cluster2;
    }
    this._pointSelectionRing.call(updateNodeSelectionRing, this._selectedPoint, pointData, config, this._map.leaflet);
    this._setUpComponentEventsThrottled();
    this._setCustomAttributesThrottled();
    (_a = config.tooltip) === null || _a === void 0 ? void 0 : _a.update();
  }
  _zoomToExternallySelectedPoint() {
    const { config } = this;
    if (!this._externallySelectedPoint)
      return;
    const externallySelectedPointDatum = this._externallySelectedPoint.properties;
    const externallySelectedPointId = getString(externallySelectedPointDatum, config.pointId);
    const pointData = this._getPointData();
    const foundPoint = pointData.find((d18) => getString(d18.properties, config.pointId) === externallySelectedPointId);
    if (foundPoint) {
      this._zoomingToExternallySelectedPoint = false;
      this._currentZoomLevel = null;
    } else {
      const { cluster: cluster2 } = findPointAndClusterByPointId(pointData, externallySelectedPointId, config.pointId);
      if (!cluster2)
        return;
      const zoomLevel = this._map.leaflet.getZoom();
      if (this._forceExpandCluster || shouldClusterExpand(cluster2, zoomLevel, 8, 13)) {
        this._expandCluster(cluster2);
      } else {
        const newZoomLevel = getNextZoomLevelOnClusterClick(zoomLevel);
        const coordinates = {
          lng: getNumber(externallySelectedPointDatum, config.pointLongitude),
          lat: getNumber(externallySelectedPointDatum, config.pointLatitude)
        };
        if (this._currentZoomLevel !== newZoomLevel) {
          this._currentZoomLevel = newZoomLevel;
          this._eventInitiatedByComponent = true;
          this._map.leaflet.flyTo(coordinates, newZoomLevel, { duration: 0 });
        }
      }
    }
  }
  _expandCluster(clusterPoint, preventRender) {
    var _a;
    const { config, config: { clusterBackground: clusterBackground2 } } = this;
    const padding = 1;
    (_a = config.tooltip) === null || _a === void 0 ? void 0 : _a.hide();
    this._forceExpandCluster = false;
    if (clusterPoint) {
      const points3 = clusterPoint.clusterIndex.getLeaves(clusterPoint.properties.cluster_id, Infinity);
      const packPoints = points3.map((p13) => ({
        x: null,
        y: null,
        r: getPointRadius(p13, config.pointRadius, this._map.leaflet.getZoom()) + padding
      }));
      siblings_default(packPoints);
      points3.forEach((p13, i8) => {
        p13.properties.expandedClusterPoint = clusterPoint;
        p13.properties.r = packPoints[i8].r;
        p13.properties.dx = packPoints[i8].x;
        p13.properties.dy = packPoints[i8].y;
      });
      this._resetExpandedCluster();
      this._expandedCluster = {
        cluster: clusterPoint,
        points: points3
      };
      if (clusterBackground2)
        this._clusterBackgroundRadius = getClusterRadius(this._expandedCluster);
      if (!preventRender)
        this._renderData();
    }
    this._zoomingToExternallySelectedPoint = false;
  }
  _resetExpandedCluster() {
    var _a, _b;
    (_b = (_a = this._expandedCluster) === null || _a === void 0 ? void 0 : _a.points) === null || _b === void 0 ? void 0 : _b.forEach((d18) => {
      delete d18.properties.expandedClusterPoint;
    });
    this._expandedCluster = null;
  }
  _getPointData(customBounds) {
    const { config, datamodel: { data } } = this;
    if (!data || !this._clusterIndex)
      return [];
    let geoJSONPoints = getClustersAndPoints(this._clusterIndex, this._map.leaflet, customBounds);
    if (this._expandedCluster) {
      geoJSONPoints = geoJSONPoints.filter((c6) => c6.properties.cluster_id !== this._expandedCluster.cluster.properties.cluster_id);
      geoJSONPoints = geoJSONPoints.concat(this._expandedCluster.points);
    }
    const pointData = geoJSONPoints.map((d18, i8) => {
      return geoJsonPointToScreenPoint(d18, i8, this._map.leaflet, config);
    });
    return pointData;
  }
  _getMapZoomState() {
    const leafletBounds = this._map.leaflet.getBounds();
    const southWest = leafletBounds.getSouthWest();
    const northEast = leafletBounds.getNorthEast();
    return {
      mapCenter: this._map.leaflet.getCenter(),
      zoomLevel: this._map.leaflet.getZoom(),
      bounds: { southWest, northEast },
      userDriven: !this._eventInitiatedByComponent
    };
  }
  _onMapDragLeaflet() {
    this._cancelBackgroundClick = true;
  }
  _onMapMove() {
    var _a;
    const { config } = this;
    if (!this._map)
      return;
    this._hasBeenMoved = true;
    this._renderDataAnimationFrameId = requestAnimationFrame(() => {
      this._renderData(true);
    });
    (_a = config.onMapMoveZoom) === null || _a === void 0 ? void 0 : _a.call(config, this._getMapZoomState());
  }
  _onMapMoveStart() {
    var _a;
    const { config } = this;
    if (!this._map)
      return;
    this._isMoving = true;
    (_a = config.onMapMoveStart) === null || _a === void 0 ? void 0 : _a.call(config, this._getMapZoomState());
  }
  _onMapMoveEnd() {
    var _a, _b;
    const { config } = this;
    if (!this._map)
      return;
    (_a = this._onMapMoveEndInternal) === null || _a === void 0 ? void 0 : _a.call(this, this._map.leaflet);
    (_b = config.onMapMoveEnd) === null || _b === void 0 ? void 0 : _b.call(config, this._getMapZoomState());
    constraintMapViewThrottled(this._map.leaflet);
    const events2 = this._map.layer.getEvents();
    if (events2.zoomend) {
      const zoomEndEvent = events2.zoomend.bind(this._map.layer);
      zoomEndEvent(null);
    }
    if (this._externallySelectedPoint || this._zoomingToExternallySelectedPoint) {
      this._zoomToExternallySelectedPoint();
    }
    this._isMoving = false;
    this._eventInitiatedByComponent = false;
  }
  _onMapZoomStart() {
    var _a;
    const { config } = this;
    if (!this._map)
      return;
    this._isZooming = true;
    (_a = config.onMapZoomStart) === null || _a === void 0 ? void 0 : _a.call(config, this._getMapZoomState());
  }
  _onMapZoomEnd() {
    var _a;
    const { config } = this;
    if (!this._map)
      return;
    (_a = config.onMapZoomEnd) === null || _a === void 0 ? void 0 : _a.call(config, this._getMapZoomState());
    this._isZooming = false;
    if (!this._isMoving)
      this._eventInitiatedByComponent = false;
  }
  _onMapZoom() {
    var _a, _b;
    const { config } = this;
    if (!this._map)
      return;
    this._hasBeenZoomed = true;
    if (!this._externallySelectedPoint)
      this._resetExpandedCluster();
    else if (!this._zoomingToExternallySelectedPoint) {
      this._externallySelectedPoint = null;
    }
    (_a = config.tooltip) === null || _a === void 0 ? void 0 : _a.hide();
    (_b = config.onMapMoveZoom) === null || _b === void 0 ? void 0 : _b.call(config, this._getMapZoomState());
  }
  _onBackgroundClick(el, event) {
    var _a;
    const { config } = this;
    if (this._cancelBackgroundClick) {
      this._cancelBackgroundClick = false;
      return;
    }
    this._externallySelectedPoint = null;
    this._resetExpandedCluster();
    this._renderData();
    (_a = config.onMapClick) === null || _a === void 0 ? void 0 : _a.call(config, this._getMapZoomState());
  }
  _onPointClick(d18, event) {
    const { config: { flyToDuration, clusterExpandOnClick } } = this;
    this._externallySelectedPoint = null;
    event.stopPropagation();
    if (d18.properties.cluster) {
      const zoomLevel = this._map.leaflet.getZoom();
      const coordinates = { lng: d18.geometry.coordinates[0], lat: d18.geometry.coordinates[1] };
      if (clusterExpandOnClick && shouldClusterExpand(d18, zoomLevel))
        this._expandCluster(d18);
      else {
        const newZoomLevel = getNextZoomLevelOnClusterClick(zoomLevel);
        this._eventInitiatedByComponent = true;
        this._map.leaflet.flyTo(coordinates, newZoomLevel, { duration: flyToDuration / 1e3 });
      }
    }
  }
  _onPointMouseDown(d18, event) {
    this._cancelBackgroundClick = true;
  }
  _onPointMouseUp(d18, event) {
    this._cancelBackgroundClick = false;
  }
  zoomIn(increment = 1) {
    var _a;
    if (!((_a = this._map) === null || _a === void 0 ? void 0 : _a.leaflet))
      return;
    this.setZoom(this._map.leaflet.getZoom() + increment);
  }
  zoomOut(increment = 1) {
    var _a;
    if (!((_a = this._map) === null || _a === void 0 ? void 0 : _a.leaflet))
      return;
    this.setZoom(this._map.leaflet.getZoom() - increment);
  }
  setZoom(zoomLevel) {
    var _a;
    const leaflet = (_a = this._map) === null || _a === void 0 ? void 0 : _a.leaflet;
    if (!leaflet)
      return;
    this._eventInitiatedByComponent = true;
    leaflet.flyTo(leaflet.getCenter(), clamp(zoomLevel, leaflet.getMinZoom(), leaflet.getMaxZoom()), { duration: this.config.zoomDuration / 1e3 });
  }
  fitView() {
    this.fitToPoints();
  }
  destroy() {
    var _a, _b;
    constraintMapViewThrottled.cancel();
    cancelAnimationFrame(this._renderDataAnimationFrameId);
    cancelAnimationFrame(this._flyToBoundsAnimationFrameId);
    const map5 = (_a = this._map) === null || _a === void 0 ? void 0 : _a.leaflet;
    this._map = void 0;
    map5 === null || map5 === void 0 ? void 0 : map5.stop();
    map5 === null || map5 === void 0 ? void 0 : map5.remove();
    this.g.remove();
    this.resizeObserver.disconnect();
    (_b = this.themeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
  }
};
LeafletMap.selectors = style_exports15;
LeafletMap.cssVariables = variables9;
LeafletMap.DEFAULT_CONTAINER_HEIGHT = 600;

// node_modules/@unovis/ts/components/leaflet-flow-map/config.js
var LeafletFlowMapDefaultConfig = Object.assign(Object.assign({}, LeafletMapDefaultConfig), { sourceLongitude: (f29) => f29.sourceLongitude, sourceLatitude: (f29) => f29.sourceLatitude, targetLongitude: (f29) => f29.targetLongitude, targetLatitude: (f29) => f29.targetLatitude, sourcePointRadius: 3, sourcePointColor: "#88919f", flowParticleColor: "#949dad", flowParticleRadius: 1.1, flowParticleSpeed: 0.07, flowParticleDensity: 0.6, onSourcePointClick: void 0, onSourcePointMouseEnter: void 0, onSourcePointMouseLeave: void 0 });

// node_modules/@unovis/ts/components/leaflet-flow-map/index.js
var LeafletFlowMap = class extends ComponentCore {
  constructor(container, config, data) {
    var _a;
    super(ComponentType.HTML);
    this._defaultConfig = LeafletFlowMapDefaultConfig;
    this.config = this._defaultConfig;
    this.type = ComponentType.HTML;
    this.flows = [];
    this.points = [];
    this.onCanvasMouseMoveBound = throttle(this.onCanvasMouseMove.bind(this), 60);
    this.onCanvasClickBound = this.onCanvasClick.bind(this);
    this.panningOffset = { x: 0, y: 0 };
    this.particles = [];
    this.leafletMap = new LeafletMap(container, config, (_a = data === null || data === void 0 ? void 0 : data.points) !== null && _a !== void 0 ? _a : []);
    const rendererImportPromise = import("./renderer-6Y2WY22I.js");
    Promise.all([rendererImportPromise, this.leafletMap.getLeafletInstancePromise()]).then((imports) => {
      const [{ PointRenderer }, leaflet] = imports;
      this.leafletMapInstance = leaflet;
      const canvasContainer = this.leafletMapInstance.getPanes().overlayPane;
      const canvas = select_default2(canvasContainer).insert("canvas", ":first-child");
      this.canvasElement = canvas.node();
      this.renderer = new PointRenderer(canvasContainer, container.offsetWidth, container.offsetHeight, this.canvasElement);
      this.canvasElement.addEventListener("mousemove", this.onCanvasMouseMoveBound);
      this.canvasElement.addEventListener("click", this.onCanvasClickBound);
      this.leafletMap._onMapMoveEndInternal = this.onMapMove.bind(this);
      this.resizeObserver = new ResizeObserver2(() => {
        this.renderer.setSize(container.offsetWidth, container.offsetHeight);
      });
      this.resizeObserver.observe(container);
      if (config)
        this.setConfig(config);
      if (data)
        this.setData(data);
      this.animate();
    });
  }
  setConfig(config) {
    super.setConfig(config);
    this.leafletMap.setConfig(Object.assign(Object.assign({}, config), { clusteringDistance: 0 }));
  }
  setData(data) {
    super.setData(data);
    this.flows = data.flows;
    this.points = data.points;
    this.initParticles();
    this.leafletMap.setData(this.points);
    this.render();
  }
  render() {
    super.render();
  }
  initParticles() {
    var _a;
    this.clearParticles();
    for (const flow of this.flows) {
      const source = {
        lat: getNumber(flow, this.config.sourceLatitude),
        lon: getNumber(flow, this.config.sourceLongitude)
      };
      const target = {
        lat: getNumber(flow, this.config.targetLatitude),
        lon: getNumber(flow, this.config.targetLongitude)
      };
      const sourcePointRadius = getNumber(flow, this.config.sourcePointRadius);
      const sourcePointColor = getColor(flow, this.config.sourcePointColor);
      this.addParticle(source, source, source, 0, sourcePointRadius, sourcePointColor);
      const dist = Math.sqrt(Math.pow(target.lat - source.lat, 2) + Math.pow(target.lon - source.lon, 2));
      const numParticles = Math.round(dist * getNumber(flow, this.config.flowParticleDensity));
      const velocity = getNumber(flow, this.config.flowParticleSpeed);
      const r4 = getNumber(flow, this.config.flowParticleRadius);
      const color2 = getColor(flow, this.config.flowParticleColor);
      for (let i8 = 0; i8 < numParticles; i8 += 1) {
        const location = {
          lat: source.lat + (target.lat - source.lat) * i8 / numParticles,
          lon: source.lon + (target.lon - source.lon) * i8 / numParticles
        };
        this.addParticle(source, target, location, velocity, r4, color2);
      }
    }
    (_a = this.renderer) === null || _a === void 0 ? void 0 : _a.update(this.particles);
  }
  addParticle(source, target, location = source, velocity = 0.05, r4 = 0.75, color2) {
    const x21 = 0;
    const y25 = 0;
    this.particles.push({ x: x21, y: y25, source, target, location, velocity, r: r4, color: color2 });
  }
  clearParticles() {
    this.particles = [];
  }
  animate() {
    const map5 = this.leafletMapInstance;
    requestAnimationFrame(() => {
      const zoomLevel = map5 === null || map5 === void 0 ? void 0 : map5.getZoom();
      for (const p13 of this.particles) {
        const fullDist = Math.sqrt(Math.pow(p13.target.lat - p13.source.lat, 2) + Math.pow(p13.target.lon - p13.source.lon, 2));
        const remainedDist = Math.sqrt(Math.pow(p13.target.lat - p13.location.lat, 2) + Math.pow(p13.target.lon - p13.location.lon, 2));
        const angle = Math.atan2(p13.target.lat - p13.source.lat, p13.target.lon - p13.source.lon);
        p13.location.lat += p13.velocity * Math.sin(angle);
        p13.location.lon += p13.velocity * Math.cos(angle);
        if (p13.target.lat > p13.source.lat && p13.location.lat > p13.target.lat || p13.target.lon > p13.source.lon && p13.location.lon > p13.target.lon || (p13.target.lat < p13.source.lat && p13.location.lat < p13.target.lat || p13.target.lon < p13.source.lon && p13.location.lon < p13.target.lon)) {
          p13.location.lat = p13.source.lat;
          p13.location.lon = p13.source.lon;
        }
        const pos = map5 === null || map5 === void 0 ? void 0 : map5.latLngToLayerPoint([p13.location.lat, p13.location.lon]);
        const orthogonalArcShift = -(Math.pow(zoomLevel, 2) * fullDist / 8) * Math.cos(Math.PI / 2 * (fullDist / 2 - remainedDist) / (fullDist / 2)) || 0;
        p13.x = (pos === null || pos === void 0 ? void 0 : pos.x) - this.panningOffset.x;
        p13.y = (pos === null || pos === void 0 ? void 0 : pos.y) + orthogonalArcShift - this.panningOffset.y;
      }
      this.renderer.updatePointsPosition(this.particles);
      this.renderer.draw();
      this.animate();
    });
  }
  getPointByScreenPos(x21, y25) {
    const map5 = this.leafletMapInstance;
    for (const flow of this.flows) {
      const lat = getNumber(flow, this.config.sourceLatitude);
      const lon = getNumber(flow, this.config.sourceLongitude);
      const r4 = getNumber(flow, this.config.sourcePointRadius);
      const pos = map5 === null || map5 === void 0 ? void 0 : map5.latLngToLayerPoint([lat, lon]);
      const posX = pos.x - this.panningOffset.x;
      const posY = pos.y - this.panningOffset.y;
      if (Math.abs(x21 - posX) < r4 && Math.abs(y25 - posY) < r4) {
        return [flow, posX, posY];
      }
    }
    return [];
  }
  onCanvasMouseMove(event) {
    var _a, _b;
    const { config } = this;
    this.canvasElement.style.removeProperty("cursor");
    const [hoveredPoint, x21, y25] = this.getPointByScreenPos(event.offsetX, event.offsetY);
    if (hoveredPoint)
      this.canvasElement.style.cursor = "default";
    if (this.hoveredSourcePoint !== hoveredPoint) {
      if (hoveredPoint)
        (_a = config.onSourcePointMouseEnter) === null || _a === void 0 ? void 0 : _a.call(config, hoveredPoint, x21, y25, event);
      if (this.hoveredSourcePoint)
        (_b = config.onSourcePointMouseLeave) === null || _b === void 0 ? void 0 : _b.call(config, this.hoveredSourcePoint, event);
      this.hoveredSourcePoint = hoveredPoint;
    }
  }
  onCanvasClick(event) {
    var _a;
    const { config } = this;
    const [clickedPoint, x21, y25] = this.getPointByScreenPos(event.offsetX, event.offsetY);
    if (clickedPoint)
      (_a = config.onSourcePointClick) === null || _a === void 0 ? void 0 : _a.call(config, clickedPoint, x21, y25, event);
  }
  onMapMove(leaflet) {
    const shift = leaflet.containerPointToLayerPoint([0, 0]);
    this.panningOffset.x = shift.x;
    this.panningOffset.y = shift.y;
    this.canvasElement.style.transform = `translate(${shift.x}px, ${shift.y}px)`;
  }
  destroy() {
    var _a, _b, _c, _d;
    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.renderer) === null || _b === void 0 ? void 0 : _b.destroy();
    (_c = this.canvasElement) === null || _c === void 0 ? void 0 : _c.removeEventListener("mousemove", this.onCanvasMouseMoveBound);
    (_d = this.canvasElement) === null || _d === void 0 ? void 0 : _d.removeEventListener("click", this.onCanvasClickBound);
    super.destroy();
  }
  // Leaflet Map useful methods
  selectPointById(id2, centerPoint = false) {
    this.leafletMap.selectPointById(id2, centerPoint);
  }
  getSelectedPointId() {
    return this.leafletMap.getSelectedPointId();
  }
  unselectPoint() {
    this.leafletMap.unselectPoint();
  }
  zoomToPointById(id2, selectNode = false, customZoomLevel) {
    this.leafletMap.zoomToPointById(id2, selectNode, customZoomLevel);
  }
  zoomIn(increment = 1) {
    this.leafletMap.zoomIn(increment);
  }
  zoomOut(increment = 1) {
    this.leafletMap.zoomOut(increment);
  }
  setZoom(zoomLevel) {
    this.leafletMap.setZoom(zoomLevel);
  }
  fitView() {
    const points3 = [];
    for (const point13 of this.points) {
      points3.push({
        lat: getNumber(point13, this.config.pointLatitude),
        lon: getNumber(point13, this.config.pointLongitude)
      });
    }
    for (const flow of this.flows) {
      const source = {
        lat: getNumber(flow, this.config.sourceLatitude),
        lon: getNumber(flow, this.config.sourceLongitude)
      };
      const target = {
        lat: getNumber(flow, this.config.targetLatitude),
        lon: getNumber(flow, this.config.targetLongitude)
      };
      points3.push(source);
      points3.push(target);
    }
    const boundsArray = getDataLatLngBounds(points3, (d18) => d18.lat, (d18) => d18.lon, 0);
    const bounds = {
      northEast: { lat: boundsArray[0][0], lng: boundsArray[1][1] },
      southWest: { lat: boundsArray[1][0], lng: boundsArray[0][1] }
    };
    this.leafletMap.fitToBounds(bounds);
  }
};
LeafletFlowMap.selectors = LeafletMap.selectors;

// node_modules/@unovis/ts/components/chord-diagram/config.js
var ChordDiagramDefaultConfig = Object.assign(Object.assign({}, ComponentDefaultConfig), { duration: 800, highlightedNodeId: void 0, highlightedLinkIds: [], linkColor: void 0, linkValue: (d18) => d18.value, nodeLevels: [], nodeWidth: 15, nodeColor: (d18) => d18.color, nodeLabel: (d18) => {
  var _a;
  return (_a = d18.label) !== null && _a !== void 0 ? _a : d18.key;
}, nodeLabelColor: void 0, nodeLabelAlignment: ChordLabelAlignment.Along, padAngle: 0.02, cornerRadius: 2, angleRange: [0, 2 * Math.PI], radiusScaleExponent: 2 });

// node_modules/@unovis/ts/components/chord-diagram/modules/node.js
function createNode(selection2) {
  selection2.style("opacity", 0).each((d18, i8, els) => {
    const arcNode = els[i8];
    const angleCenter = (d18.x0 + d18.x1) / 2;
    const angleHalfWidth = (d18.x1 - d18.x0) / 2;
    arcNode._animState = {
      x0: angleCenter - angleHalfWidth * 0.8,
      x1: angleCenter + angleHalfWidth * 0.8,
      y0: d18.y0,
      y1: d18.y1
    };
  });
}
function updateNode(selection2, config, arcGen, duration) {
  const nodeColor = (d18) => getColor(d18.data, config.nodeColor, d18.height);
  selection2.attr("id", (d18) => d18.uid).style("transition", `fill ${duration}ms`).style("fill", nodeColor).style("stroke", nodeColor);
  if (duration) {
    const transition2 = smartTransition(selection2, duration).style("opacity", 1);
    transition2.attrTween("d", (d18, i8, els) => {
      const arcNode = els[i8];
      const nextAnimState = { x0: d18.x0, x1: d18.x1, y0: d18.y0, y1: d18.y1 };
      const datum2 = value_default(arcNode._animState, nextAnimState);
      return (t4) => {
        arcNode._animState = datum2(t4);
        return arcGen(arcNode._animState);
      };
    });
  } else {
    selection2.attr("d", (d18) => arcGen(d18)).style("opacity", 1);
  }
}
function removeNode(selection2, duration) {
  smartTransition(selection2, duration).style("opacity", 0).remove();
}

// node_modules/@unovis/ts/components/chord-diagram/style.js
var style_exports16 = {};
__export(style_exports16, {
  background: () => background5,
  highlightedLink: () => highlightedLink,
  highlightedNode: () => highlightedNode,
  label: () => label7,
  labelExit: () => labelExit,
  labelText: () => labelText,
  labels: () => labels3,
  link: () => link5,
  links: () => links3,
  node: () => node2,
  nodes: () => nodes2,
  root: () => root18,
  transparent: () => transparent,
  variables: () => variables10
});
var root18 = css`
  label: chord-diagram-component;
`;
var variables10 = injectGlobal`
  :root {
    --vis-chord-diagram-link-fill-color: #cad5f6;
    --vis-chord-diagram-link-stroke-color: #777777;
    --vis-chord-diagram-link-opacity: 0.5;
    --vis-chord-diagram-link-stroke-opacity: 0.15;
    --vis-chord-diagram-link-highlighted-opacity: 0.9;
    --vis-chord-diagram-link-dimmed-opacity: 0.25;

    --vis-chord-diagram-node-highlighted-opacity: 0.9;
    --vis-chord-diagram-node-dimmed-opacity: 0.25;

    --vis-chord-diagram-label-text-fill-color-bright: #ffffff;
    --vis-chord-diagram-label-text-fill-color-dark: #a5abb2;
    --vis-chord-diagram-label-text-font-size: 1em;

    --vis-dark-chord-diagram-link-fill-color: #575c65;
  }

  body.theme-dark ${`.${root18}`} {
    --vis-chord-diagram-link-fill-color: var(--vis-dark-chord-diagram-link-fill-color);
  }
`;
var background5 = css`
  label: background;
`;
var nodes2 = css`
  label: nodes;
`;
var links3 = css`
  label: links;
`;
var labels3 = css`
  label: labels;
`;
var node2 = css`
  label: node;
  stroke-width: 0;
  fill: var(--vis-color-main);
  stroke: var(--vis-color-main);
  transition: .1s fill-opacity;
`;
var highlightedNode = css`
  label: highlighted;
  fill-opacity: var(--vis-chord-diagram-node-highlighted-opacity);
  stroke-width: 1.5;
`;
var label7 = css`
  label: label;
`;
var labelText = css`
  label: label-text;

  dominant-baseline: middle;
  user-select: none;
  font-size: var(--vis-chord-diagram-label-text-font-size);
  
  > textPath {
    dominant-baseline: central;
  }
`;
var labelExit = css`
  label: label-exit;
`;
var link5 = css`
  label: link;

  fill: var(--vis-chord-diagram-link-fill-color);
  fill-opacity: var(--vis-chord-diagram-link-opacity);
  stroke: var(--vis-chord-diagram-link-stroke-color);
  stroke-opacity:  var(--vis-chord-diagram-link-stroke-opacity);
  transition: .1s fill-opacity;
`;
var highlightedLink = css`
  label: highlighted;
  fill-opacity: var(--vis-chord-diagram-link-highlighted-opacity);
`;
var transparent = css`
  label: transparent;

  ${`.${link5}`}:not(${`.${highlightedLink}`}) {
    fill-opacity: var(--vis-chord-diagram-link-dimmed-opacity);
  }

  ${`.${node2}`}:not(${`.${highlightedNode}`}) {
    fill-opacity: var(--vis-chord-diagram-node-dimmed-opacity);
  }
`;

// node_modules/@unovis/ts/components/chord-diagram/modules/label.js
var LABEL_PADDING = 3;
function getLabelFillColor(d18, config) {
  var _a;
  const nodeLabelAlignment = (_a = getValue(d18.data, config.nodeLabelAlignment)) !== null && _a !== void 0 ? _a : ChordLabelAlignment.Along;
  switch (nodeLabelAlignment) {
    case ChordLabelAlignment.Perpendicular: {
      return getColor(d18.data, config.nodeColor, d18.height);
    }
    case ChordLabelAlignment.Along: {
      const c6 = getColor(d18.data, config.nodeColor, d18.height);
      const colorParsed = color(c6);
      const brightness = colorParsed ? hexToBrightness(colorParsed.hex()) : 0;
      return brightness > 0.65 ? "var(--vis-chord-diagram-label-text-fill-color-dark)" : "var(--vis-chord-diagram-label-text-fill-color-bright)";
    }
  }
}
function getLabelTextAnchor2(d18, config) {
  var _a;
  const nodeLabelAlignment = (_a = getValue(d18.data, config.nodeLabelAlignment)) !== null && _a !== void 0 ? _a : ChordLabelAlignment.Along;
  switch (nodeLabelAlignment) {
    case ChordLabelAlignment.Perpendicular: {
      const angleCenter = (d18.x0 + d18.x1) / 2;
      const angleDegree = angleCenter * 180 / Math.PI;
      return angleDegree < 180 ? "start" : "end";
    }
    case ChordLabelAlignment.Along: {
      return null;
    }
  }
}
function getLabelTransform(d18, config, radiusScale) {
  var _a;
  const nodeLabelAlignment = (_a = getValue(d18.data, config.nodeLabelAlignment)) !== null && _a !== void 0 ? _a : ChordLabelAlignment.Along;
  switch (nodeLabelAlignment) {
    case ChordLabelAlignment.Perpendicular: {
      const r4 = radiusScale(d18.y1) + LABEL_PADDING;
      const angleCenter = (d18.x0 + d18.x1) / 2;
      const angle = angleCenter - Math.PI / 2;
      const x21 = r4 * Math.cos(angle);
      const y25 = r4 * Math.sin(angle);
      return `translate(${x21}, ${y25})`;
    }
    case ChordLabelAlignment.Along:
      return null;
  }
}
function createLabel(selection2, config, radiusScale) {
  selection2.style("opacity", 0).attr("transform", (d18) => getLabelTransform(d18, config, radiusScale));
  selection2.append("text").attr("class", labelText).style("fill", (d18) => getColor(d18.data, config.nodeColor, d18.height));
}
function updateLabel(selection2, config, width, radiusScale, duration) {
  const { nodeLabel, nodeLabelColor, nodeWidth } = config;
  smartTransition(selection2, duration).attr("transform", (d18) => getLabelTransform(d18, config, radiusScale)).style("opacity", 1);
  const label14 = selection2.select(`.${labelText}`);
  label14.selectAll("textPath").remove();
  label14.text((d18) => getString(d18.data, nodeLabel)).style("transition", `fill ${duration}ms`).style("fill", (d18) => {
    var _a;
    return (_a = getColor(d18.data, nodeLabelColor)) !== null && _a !== void 0 ? _a : getLabelFillColor(d18, config);
  }).style("text-anchor", (d18) => getLabelTextAnchor2(d18, config)).each((d18, i8, elements) => {
    var _a;
    const nodeLabelAlignment = (_a = getValue(d18.data, config.nodeLabelAlignment)) !== null && _a !== void 0 ? _a : ChordLabelAlignment.Along;
    const radianArcLength = d18.x1 - d18.x0 - getNumber(d18.data, config.padAngle) * 2;
    const radius = radiusScale(d18.y1) - getNumber(d18, config.nodeWidth) / 2;
    const arcLength = radius * radianArcLength;
    const maxWidth = nodeLabelAlignment === ChordLabelAlignment.Along ? arcLength : width - LABEL_PADDING * 2;
    const textElement = select_default2(elements[i8]).call(trimSVGText, maxWidth).attr("dx", nodeLabelAlignment === ChordLabelAlignment.Along ? LABEL_PADDING : null).attr("dy", nodeLabelAlignment === ChordLabelAlignment.Along ? getNumber(d18.data, nodeWidth) / 2 : null);
    const textWidth = textElement.node().getComputedTextLength();
    const labelText4 = textElement.text();
    if (nodeLabelAlignment === ChordLabelAlignment.Along) {
      textElement.text("");
      if (textWidth <= maxWidth) {
        textElement.append("textPath").attr("href", `#${d18.uid}`).text(labelText4);
      }
    }
  });
  smartTransition(label14, duration).attr("transform", (d18) => {
    const nodeLabelAlignment = getValue(d18.data, config.nodeLabelAlignment);
    if (nodeLabelAlignment !== ChordLabelAlignment.Perpendicular)
      return null;
    const angleCenter = (d18.x0 + d18.x1) / 2;
    const angleDegree = angleCenter * 180 / Math.PI;
    return `rotate(${angleDegree < 180 ? angleDegree - 90 : angleDegree + 90})`;
  });
}
function removeLabel(selection2, duration) {
  smartTransition(selection2, duration).style("opacity", 0).remove();
}

// node_modules/@unovis/ts/components/chord-diagram/modules/layout.js
function transformData(node4) {
  const { height, depth } = node4;
  if (height > 0) {
    const d18 = node4.data;
    const n = node4;
    n.data = { key: d18[0], values: d18[1], depth, height, ancestors: n.ancestors().map((d19) => d19.data.key) };
  }
}
function getHierarchyNodes(data, value2, levels = []) {
  const nodeLevels = levels.map((level) => (d18) => d18[level]);
  const nestedData = levels.length ? group(data, ...nodeLevels) : { key: "root", children: data };
  const root29 = hierarchy(nestedData).sum((d18) => getNumber(d18, value2)).each(transformData);
  return root29;
}
function positionChildren(node4, padding, scalingCoeff = 0.95) {
  if (!node4.children)
    return;
  const containsLinks = node4.value > 0;
  const length = node4.x1 - node4.x0;
  const scaledLength = length * (node4.y0 === 0 ? 1 : scalingCoeff);
  const delta = length - scaledLength;
  const padAngle = containsLinks ? padding : scaledLength / node4.children.length;
  const positions = pie_default().startAngle(node4.x0 + delta / 2).endAngle(node4.x1 - delta / 2).padAngle(padAngle).value((d18) => containsLinks ? d18.value : 1).sort((a7, b25) => node4.children.indexOf(a7) - node4.children.indexOf(b25))(node4.children);
  node4.children.forEach((child, i8) => {
    const x06 = positions[i8].startAngle;
    const x110 = positions[i8].endAngle;
    const childDelta = (x110 - x06) * (1 - scalingCoeff);
    const xmid = (x06 + x110) / 2;
    child.x0 = containsLinks ? x06 + childDelta / 2 : xmid - padding / 2;
    child.x1 = containsLinks ? x110 - childDelta / 2 : xmid + padding / 2;
  });
}
function getRibbons(data, links5, padding) {
  const groupedBySource = groupBy(links5, (d18) => d18.source._id);
  const groupedByTarget = groupBy(links5, (d18) => d18.target._id);
  const leafNodes = data.leaves();
  const leafNodesById = index(leafNodes, (d18) => d18.data._id);
  const getNodesInRibbon = (source, target, partitionHeight, nodes4 = []) => {
    nodes4[source.height] = source;
    nodes4[partitionHeight * 2 - target.height] = target;
    if (source.parent && target.parent)
      getNodesInRibbon(source.parent, target.parent, partitionHeight, nodes4);
    return nodes4;
  };
  const calculatePoints = (links6, type2, depth, maxDepth2) => {
    links6.forEach((link7) => {
      var _a;
      if (!link7._state.points)
        link7._state.points = [];
      const sourceLeaf = leafNodesById.get(link7.source._id);
      const targetLeaf = leafNodesById.get(link7.target._id);
      const nodesInRibbon = getNodesInRibbon(type2 === "out" ? sourceLeaf : targetLeaf, type2 === "out" ? targetLeaf : sourceLeaf, maxDepth2);
      const currNode = nodesInRibbon[depth];
      const len = currNode.x1 - currNode.x0 - padding;
      const x06 = (_a = currNode._prevX1) !== null && _a !== void 0 ? _a : currNode.x0 + padding / 2;
      const x110 = x06 + len * link7._state.value / currNode.value;
      currNode._prevX1 = x110;
      const pointIdx = type2 === "out" ? depth : maxDepth2 * 2 - 1 - depth;
      link7._state.points[pointIdx] = { a0: x06, a1: x110, r: currNode.y1 };
    });
  };
  leafNodes.forEach((leafNode) => {
    const outLinks = groupedBySource[leafNode.data._id] || [];
    const inLinks = groupedByTarget[leafNode.data._id] || [];
    for (let depth = 0; depth < leafNode.depth; depth += 1) {
      calculatePoints(outLinks, "out", depth, leafNode.depth);
      calculatePoints(inLinks, "in", depth, leafNode.depth);
    }
  });
  return links5.map((l7) => ({
    source: leafNodesById.get(l7.source._id),
    target: leafNodesById.get(l7.target._id),
    data: l7,
    points: l7._state.points,
    _state: {}
  }));
}

// node_modules/d3-chord/src/math.js
var abs6 = Math.abs;
var cos5 = Math.cos;
var sin5 = Math.sin;
var pi8 = Math.PI;
var halfPi6 = pi8 / 2;
var tau8 = pi8 * 2;
var epsilon10 = 1e-12;

// node_modules/d3-chord/src/array.js
var slice4 = Array.prototype.slice;

// node_modules/d3-chord/src/constant.js
function constant_default11(x21) {
  return function() {
    return x21;
  };
}

// node_modules/d3-chord/src/ribbon.js
function defaultSource(d18) {
  return d18.source;
}
function defaultTarget(d18) {
  return d18.target;
}
function defaultRadius(d18) {
  return d18.radius;
}
function defaultStartAngle(d18) {
  return d18.startAngle;
}
function defaultEndAngle(d18) {
  return d18.endAngle;
}
function defaultPadAngle() {
  return 0;
}
function ribbon(headRadius) {
  var source = defaultSource, target = defaultTarget, sourceRadius = defaultRadius, targetRadius = defaultRadius, startAngle = defaultStartAngle, endAngle = defaultEndAngle, padAngle = defaultPadAngle, context = null;
  function ribbon2() {
    var buffer, s12 = source.apply(this, arguments), t4 = target.apply(this, arguments), ap = padAngle.apply(this, arguments) / 2, argv = slice4.call(arguments), sr = +sourceRadius.apply(this, (argv[0] = s12, argv)), sa0 = startAngle.apply(this, argv) - halfPi6, sa1 = endAngle.apply(this, argv) - halfPi6, tr = +targetRadius.apply(this, (argv[0] = t4, argv)), ta0 = startAngle.apply(this, argv) - halfPi6, ta1 = endAngle.apply(this, argv) - halfPi6;
    if (!context) context = buffer = path();
    if (ap > epsilon10) {
      if (abs6(sa1 - sa0) > ap * 2 + epsilon10) sa1 > sa0 ? (sa0 += ap, sa1 -= ap) : (sa0 -= ap, sa1 += ap);
      else sa0 = sa1 = (sa0 + sa1) / 2;
      if (abs6(ta1 - ta0) > ap * 2 + epsilon10) ta1 > ta0 ? (ta0 += ap, ta1 -= ap) : (ta0 -= ap, ta1 += ap);
      else ta0 = ta1 = (ta0 + ta1) / 2;
    }
    context.moveTo(sr * cos5(sa0), sr * sin5(sa0));
    context.arc(0, 0, sr, sa0, sa1);
    if (sa0 !== ta0 || sa1 !== ta1) {
      if (headRadius) {
        var hr = +headRadius.apply(this, arguments), tr2 = tr - hr, ta2 = (ta0 + ta1) / 2;
        context.quadraticCurveTo(0, 0, tr2 * cos5(ta0), tr2 * sin5(ta0));
        context.lineTo(tr * cos5(ta2), tr * sin5(ta2));
        context.lineTo(tr2 * cos5(ta1), tr2 * sin5(ta1));
      } else {
        context.quadraticCurveTo(0, 0, tr * cos5(ta0), tr * sin5(ta0));
        context.arc(0, 0, tr, ta0, ta1);
      }
    }
    context.quadraticCurveTo(0, 0, sr * cos5(sa0), sr * sin5(sa0));
    context.closePath();
    if (buffer) return context = null, buffer + "" || null;
  }
  if (headRadius) ribbon2.headRadius = function(_17) {
    return arguments.length ? (headRadius = typeof _17 === "function" ? _17 : constant_default11(+_17), ribbon2) : headRadius;
  };
  ribbon2.radius = function(_17) {
    return arguments.length ? (sourceRadius = targetRadius = typeof _17 === "function" ? _17 : constant_default11(+_17), ribbon2) : sourceRadius;
  };
  ribbon2.sourceRadius = function(_17) {
    return arguments.length ? (sourceRadius = typeof _17 === "function" ? _17 : constant_default11(+_17), ribbon2) : sourceRadius;
  };
  ribbon2.targetRadius = function(_17) {
    return arguments.length ? (targetRadius = typeof _17 === "function" ? _17 : constant_default11(+_17), ribbon2) : targetRadius;
  };
  ribbon2.startAngle = function(_17) {
    return arguments.length ? (startAngle = typeof _17 === "function" ? _17 : constant_default11(+_17), ribbon2) : startAngle;
  };
  ribbon2.endAngle = function(_17) {
    return arguments.length ? (endAngle = typeof _17 === "function" ? _17 : constant_default11(+_17), ribbon2) : endAngle;
  };
  ribbon2.padAngle = function(_17) {
    return arguments.length ? (padAngle = typeof _17 === "function" ? _17 : constant_default11(+_17), ribbon2) : padAngle;
  };
  ribbon2.source = function(_17) {
    return arguments.length ? (source = _17, ribbon2) : source;
  };
  ribbon2.target = function(_17) {
    return arguments.length ? (target = _17, ribbon2) : target;
  };
  ribbon2.context = function(_17) {
    return arguments.length ? (context = _17 == null ? null : _17, ribbon2) : context;
  };
  return ribbon2;
}
function ribbon_default() {
  return ribbon();
}

// node_modules/@unovis/ts/components/chord-diagram/modules/link.js
function emptyPath() {
  return "M0,0 L0,0";
}
var ribbonGen = ribbon_default().source((d18) => d18[0]).target((d18) => d18[d18.length - 1]).startAngle((d18) => d18.a0).endAngle((d18) => d18.a1);
var areaGen = areaRadial_default().curve(Curve.catmullRom.alpha(0.5)).startAngle((d18, i8, points3) => i8 < points3.length / 2 ? d18.a1 : d18.a0).endAngle((d18, i8, points3) => i8 < points3.length / 2 ? d18.a0 : d18.a1);
function linkGen(points3, radiusScale) {
  var _a;
  const link7 = points3.length === 2 ? ribbonGen : areaGen;
  link7.radius((d18) => radiusScale(d18.r));
  const linkPath3 = link7(points3);
  if (points3.length === 2)
    return linkPath3;
  const area2 = linkPath3.slice(0, -1);
  const path3 = area2.concat(`L${(_a = area2.match(/M-?\d*\.?\d*[,\s*]-?\d*\.?\d*/)) === null || _a === void 0 ? void 0 : _a[0].slice(1)}`);
  const radius = Math.max(radiusScale(points3[0].r), 0);
  return convertLineToArc(path3, radius);
}
function createLink(selection2, radiusScale) {
  selection2.attr("d", (d18) => linkGen(d18.points, radiusScale) || emptyPath()).style("opacity", 0);
}
function updateLink(selection2, config, radiusScale, duration) {
  selection2.style("transition", `fill ${duration}ms`).style("fill", (d18) => getColor(d18.data, config.linkColor)).style("stroke", (d18) => getColor(d18.data, config.linkColor));
  const transition2 = smartTransition(selection2, duration).style("opacity", 1);
  if (duration) {
    transition2.attrTween("d", (d18, i8, el) => {
      const previous = select_default2(el[i8]).attr("d");
      const next = linkGen(d18.points, radiusScale) || emptyPath();
      return interpolatePath(previous, next);
    });
  } else {
    transition2.attr("d", (d18) => linkGen(d18.points, radiusScale) || emptyPath());
  }
}
function removeLink(selection2, duration) {
  smartTransition(selection2, duration).style("opacity", 0).remove();
}

// node_modules/@unovis/ts/components/chord-diagram/index.js
var ChordDiagram = class _ChordDiagram extends ComponentCore {
  constructor(config) {
    super();
    this._defaultConfig = ChordDiagramDefaultConfig;
    this.config = this._defaultConfig;
    this.datamodel = new GraphDataModel();
    this.arcGen = arc_default();
    this.radiusScale = pow();
    this.events = {
      [_ChordDiagram.selectors.node]: {
        mouseover: this._onNodeMouseOver.bind(this),
        mouseout: this._onNodeMouseOut.bind(this)
      },
      [_ChordDiagram.selectors.link]: {
        mouseover: this._onLinkMouseOver.bind(this),
        mouseout: this._onLinkMouseOut.bind(this)
      },
      [_ChordDiagram.selectors.label]: {
        mouseover: this._onNodeMouseOver.bind(this),
        mouseout: this._onNodeMouseOut.bind(this)
      }
    };
    this._nodes = [];
    this._links = [];
    if (config)
      this.setConfig(config);
    this.background = this.g.append("rect").attr("class", background5);
    this.linkGroup = this.g.append("g").attr("class", links3);
    this.nodeGroup = this.g.append("g").attr("class", nodes2);
    this.labelGroup = this.g.append("g").attr("class", labels3);
  }
  get _forceHighlight() {
    var _a;
    return this.config.highlightedNodeId !== void 0 || ((_a = this.config.highlightedLinkIds) === null || _a === void 0 ? void 0 : _a.length) > 0;
  }
  get bleed() {
    const { config } = this;
    const padding = LABEL_PADDING * 2;
    let top2 = 0;
    let bottom2 = 0;
    let right3 = 0;
    let left3 = 0;
    this._nodes.forEach((n) => {
      var _a;
      const nodeLabelAlignment = getValue(n.data, config.nodeLabelAlignment);
      if (n.height === 0 && nodeLabelAlignment === ChordLabelAlignment.Perpendicular) {
        const label14 = (_a = getString(n.data, config.nodeLabel)) !== null && _a !== void 0 ? _a : "";
        const fontSize = getCSSVariableValueInPixels("var(--vis-chord-diagram-label-text-font-size)", this.element);
        const labelWidth = estimateStringPixelLength(label14, fontSize);
        const [x21, y25] = this.arcGen.centroid(n);
        if (x21 < 0)
          left3 = Math.max(left3, labelWidth);
        else
          right3 = Math.max(right3, labelWidth);
        if (y25 < 0)
          top2 = Math.max(top2, labelWidth);
        else
          bottom2 = Math.max(bottom2, labelWidth);
      }
    });
    left3 += padding;
    right3 += padding;
    bottom2 += padding;
    top2 += padding;
    return { top: top2, bottom: bottom2, left: left3, right: right3 };
  }
  setSize(width, height, containerWidth, containerHeight) {
    super.setSize(width, height, containerWidth, containerHeight);
    this.radiusScale.exponent(this.config.radiusScaleExponent).range([0, Math.min(width, height) / 2]);
  }
  setData(data) {
    super.setData(data);
    this._layoutData();
  }
  _layoutData() {
    const { nodes: nodes4 } = this.datamodel;
    let { links: links5 } = this.datamodel;
    const { padAngle, linkValue, nodeLevels } = this.config;
    nodes4.forEach((n) => {
      delete n._state.value;
    });
    links5.forEach((l7) => {
      delete l7._state.points;
      l7._state.value = getNumber(l7, linkValue);
      l7.source._state.value = (l7.source._state.value || 0) + getNumber(l7, linkValue);
      l7.target._state.value = (l7.target._state.value || 0) + getNumber(l7, linkValue);
    });
    links5 = links5.filter((d18) => d18._state.value);
    const root29 = getHierarchyNodes(nodes4, (d18) => {
      var _a;
      return (_a = d18._state) === null || _a === void 0 ? void 0 : _a.value;
    }, nodeLevels);
    const partitionData = partition_default().size([this.config.angleRange[1], 1])(root29);
    partitionData.each((n, i8) => {
      positionChildren(n, padAngle);
      n.uid = `${this.uid.substr(0, 4)}-${i8}`;
      n.x0 = Number.isNaN(n.x0) ? 0 : n.x0;
      n.x1 = Number.isNaN(n.x1) ? 0 : n.x1;
      n._state = {};
    });
    const partitionDataWithRoot = partitionData.descendants();
    this._rootNode = partitionDataWithRoot.find((d18) => d18.depth === 0);
    this._nodes = partitionDataWithRoot.filter((d18) => d18.depth !== 0);
    this._links = getRibbons(partitionData, links5, padAngle);
  }
  _render(customDuration) {
    var _a;
    super._render(customDuration);
    const { config, bleed } = this;
    this._layoutData();
    const duration = isNumber(customDuration) ? customDuration : config.duration;
    const size2 = Math.min(this._width, this._height);
    const radius = size2 / 2 - max([bleed.top, bleed.bottom, bleed.left, bleed.right]);
    const numLevels = 1 + ((_a = config.nodeLevels) === null || _a === void 0 ? void 0 : _a.length);
    const maxSpace = config.nodeWidth * numLevels;
    const nodeWidth = radius > maxSpace ? config.nodeWidth : Math.max(radius / numLevels, 0);
    this.radiusScale.range([0, Math.max(radius, 0)]);
    this.arcGen.startAngle((d18) => d18.x0 + config.padAngle / 2 - (d18.value ? 0 : Math.PI / 360)).endAngle((d18) => d18.x1 - config.padAngle / 2 + (d18.value ? 0 : Math.PI / 360)).cornerRadius((d18) => getNumber(d18.data, config.cornerRadius)).innerRadius((d18) => Math.max(this.radiusScale(d18.y1) - nodeWidth, 0)).outerRadius((d18) => this.radiusScale(d18.y1));
    this.g.classed(transparent, this._forceHighlight);
    this.background.attr("width", this._width).attr("height", this._height).style("opacity", 0);
    this.nodeGroup.attr("transform", `translate(${this._width / 2},${this._height / 2})`);
    this.labelGroup.attr("transform", `translate(${this._width / 2},${this._height / 2})`);
    this.linkGroup.attr("transform", `translate(${this._width / 2},${this._height / 2})`);
    const linksSelection = this.linkGroup.selectAll(`.${link5}`).data(this._links, (d18) => String(d18.data._id));
    const linksEnter = linksSelection.enter().append("path").attr("class", link5).call(createLink, this.radiusScale);
    const linksMerged = linksSelection.merge(linksEnter).classed(highlightedLink, (l7) => {
      var _a2, _b;
      const linkId = (_a2 = l7.data.id) !== null && _a2 !== void 0 ? _a2 : l7.data._indexGlobal;
      return (_b = config.highlightedLinkIds) === null || _b === void 0 ? void 0 : _b.includes(linkId);
    });
    linksMerged.call(updateLink, config, this.radiusScale, duration);
    linksSelection.exit().call(removeLink, duration);
    const nodesSelection = this.nodeGroup.selectAll(`.${node2}`).data(this._nodes, (d18) => String(d18.uid));
    const nodesEnter = nodesSelection.enter().append("path").attr("class", node2).call(createNode, config);
    const nodesMerged = nodesSelection.merge(nodesEnter).classed(highlightedNode, (d18) => config.highlightedNodeId === d18.data._id);
    nodesMerged.call(updateNode, config, this.arcGen, duration, this.bleed);
    nodesSelection.exit().call(removeNode, duration);
    const labelWidth = size2 - radius;
    const labels4 = this.labelGroup.selectAll(`.${label7}`).data(this._nodes, (d18) => String(d18.uid));
    const labelEnter = labels4.enter().append("g").attr("class", label7).call(createLabel, config, this.radiusScale);
    const labelsMerged = labels4.merge(labelEnter);
    labelsMerged.call(updateLabel, config, labelWidth, this.radiusScale, duration);
    labels4.exit().attr("class", labelExit).call(removeLabel, duration);
  }
  _onNodeMouseOver(d18) {
    let ribbons;
    if (d18.children) {
      const leaves = d18.leaves();
      ribbons = this._links.filter((l7) => leaves.find((leaf) => l7.source.data.id === leaf.data.id || l7.target.data.id === leaf.data.id));
    } else {
      const leaf = d18;
      ribbons = this._links.filter((l7) => l7.source.data.id === leaf.data.id || l7.target.data.id === leaf.data.id);
    }
    if (!ribbons.length)
      d18._state.hovered = true;
    this._highlightOnHover(ribbons);
  }
  _onNodeMouseOut() {
    this._highlightOnHover();
  }
  _onLinkMouseOver(d18) {
    this._highlightOnHover([d18]);
  }
  _onLinkMouseOut() {
    this._highlightOnHover();
  }
  _highlightOnHover(links5) {
    if (this._forceHighlight)
      return;
    if (links5) {
      links5.forEach((l7) => {
        l7._state.hovered = true;
        const sourcePath = l7.source.path(this._rootNode);
        const targetPath = l7.target.path(this._rootNode);
        sourcePath.forEach((n) => {
          if (n.depth)
            n._state.hovered = true;
        });
        targetPath.forEach((n) => {
          if (n.depth)
            n._state.hovered = true;
        });
      });
    } else {
      this._nodes.forEach((n) => {
        delete n._state.hovered;
      });
      this._links.forEach((l7) => {
        delete l7._state.hovered;
      });
    }
    this.nodeGroup.selectAll(`.${node2}`).classed(highlightedNode, (d18) => d18._state.hovered);
    this.linkGroup.selectAll(`.${link5}`).classed(highlightedLink, (d18) => d18._state.hovered);
    this.g.classed(transparent, !!links5);
  }
};
ChordDiagram.selectors = style_exports16;

// node_modules/@unovis/ts/components/graph/config.js
var GraphDefaultConfig = Object.assign(Object.assign({}, ComponentDefaultConfig), { duration: 1e3, zoomScaleExtent: [0.35, 1.25], disableZoom: false, zoomEventFilter: void 0, disableDrag: false, disableBrush: false, zoomThrottledUpdateNodeThreshold: 100, layoutType: GraphLayoutType.Force, layoutAutofit: true, layoutAutofitTolerance: 8, layoutNonConnectedAside: false, fitViewPadding: 50, fitViewAlign: GraphFitViewAlignment.Center, layoutGroupOrder: [], layoutParallelNodeSpacing: void 0, layoutParallelSubGroupsPerRow: 1, layoutParallelNodesPerColumn: 6, layoutParallelGroupSpacing: void 0, layoutParallelSubGroupSpacing: 40, layoutParallelSortConnectionsByGroup: void 0, layoutNodeGroup: (n) => n.group, layoutParallelNodeSubGroup: (n) => n.subgroup, forceLayoutSettings: {
  linkDistance: 60,
  linkStrength: 0.45,
  charge: -500,
  forceXStrength: 0.15,
  forceYStrength: 0.25,
  numIterations: void 0,
  fixNodePositionAfterSimulation: false
}, dagreLayoutSettings: {
  rankdir: "BT",
  ranker: "longest-path"
}, layoutElkSettings: void 0, layoutElkNodeGroups: void 0, layoutElkGetNodeShape: void 0, linkFlowAnimDuration: 2e4, linkFlowParticleSize: 2, linkFlowParticleSpeed: void 0, linkWidth: 1, linkStyle: GraphLinkStyle.Solid, linkBandWidth: 0, linkArrow: void 0, linkStroke: void 0, linkFlow: false, linkLabel: void 0, linkLabelShiftFromCenter: true, linkNeighborSpacing: 8, linkDisabled: false, linkCurvature: 0, linkHighlightOnHover: true, linkSourcePointOffset: void 0, linkTargetPointOffset: void 0, selectedLinkId: void 0, nodeSize: 30, nodeStrokeWidth: 3, nodeShape: GraphNodeShape.Circle, nodeGaugeValue: 0, nodeIcon: (n) => n.icon, nodeIconSize: void 0, nodeLabel: (n) => n.label, nodeLabelTrim: true, nodeLabelTrimLength: 15, nodeLabelTrimMode: TrimMode.Middle, nodeSubLabel: "", nodeSubLabelTrim: true, nodeSubLabelTrimLength: 15, nodeSubLabelTrimMode: TrimMode.Middle, nodeSideLabels: void 0, nodeBottomIcon: void 0, nodeDisabled: false, nodeFill: (n) => n.fill, nodeGaugeFill: void 0, nodeStroke: (n) => n.stroke, nodeEnterPosition: void 0, nodeEnterScale: 0.75, nodeExitPosition: void 0, nodeExitScale: 0.75, nodeSort: void 0, nodeSelectionHighlightMode: GraphNodeSelectionHighlightMode.GreyoutNonConnected, nodeGaugeAnimDuration: 1500, selectedNodeId: void 0, selectedNodeIds: void 0, panels: void 0, onNodeDragStart: void 0, onNodeDrag: void 0, onNodeDragEnd: void 0, onZoom: void 0, onZoomStart: void 0, onZoomEnd: void 0, onLayoutCalculated: void 0, onNodeSelectionBrush: void 0, onNodeSelectionDrag: void 0, onRenderComplete: void 0, shouldDataUpdate: (prevData, nextData) => {
  return !isEqual(prevData, nextData);
} });

// node_modules/@unovis/ts/components/graph/modules/node/style.js
var style_exports17 = {};
__export(style_exports17, {
  brushable: () => brushable,
  brushed: () => brushed,
  customNode: () => customNode,
  draggable: () => draggable,
  gNode: () => gNode,
  gNodeExit: () => gNodeExit,
  greyedOutNode: () => greyedOutNode,
  label: () => label8,
  labelBackground: () => labelBackground2,
  labelText: () => labelText2,
  labelTextContent: () => labelTextContent,
  node: () => node3,
  nodeBottomIcon: () => nodeBottomIcon,
  nodeGauge: () => nodeGauge,
  nodeIcon: () => nodeIcon2,
  nodeIsDragged: () => nodeIsDragged,
  nodePolygon: () => nodePolygon,
  nodeSelection: () => nodeSelection,
  nodeSelectionActive: () => nodeSelectionActive,
  nodes: () => nodes3,
  sideLabel: () => sideLabel,
  sideLabelBackground: () => sideLabelBackground,
  sideLabelGroup: () => sideLabelGroup,
  sideLabelsGroup: () => sideLabelsGroup,
  subLabelTextContent: () => subLabelTextContent,
  variables: () => variables11
});
var nodes3 = css`
  label: nodes;
`;
var variables11 = injectGlobal`
  :root {
    /* Node Fill */
    --vis-graph-node-stroke-color: rgb(206, 211, 222);
    --vis-graph-node-fill-color: #fff;
    --vis-graph-node-gauge-color: #adb4c2;
    --vis-graph-node-selection-color: #acb3b8;

    --vis-dark-graph-node-stroke-color: rgba(30,30,30,.25);
    --vis-dark-graph-node-fill-color: #494b56;
    --vis-dark-graph-node-gauge-color: #989aa3;
    --vis-dark-graph-node-selection-color: #494b56;

    /* Node Central Icon */
    --vis-graph-node-icon-fill-color-bright: #ffffff;
    --vis-graph-node-icon-fill-color-dark: var(--vis-color-grey);
    --vis-graph-node-icon-fill-color: #9ea7b8;

    --vis-dark-graph-node-icon-fill-color: var(--vis-graph-node-icon-fill-color-bright);

    /* Node Bottom Icon */
    --vis-graph-node-bottom-icon-font-size: 14pt;
    --vis-graph-node-bottom-icon-fill-color: #a0a6ad;
    --vis-graph-node-bottom-icon-stroke-color: #fff;
    --vis-graph-node-bottom-icon-stroke-width: 2px;

    --vis-dark-graph-node-bottom-icon-fill-color: #a0a6ad;
    --vis-dark-graph-node-bottom-icon-stroke-color: #fff;

    /* Node Label */
    --vis-graph-node-label-font-size: 9pt;
    --vis-graph-node-label-background: #ffffff;
    --vis-graph-node-label-text-color: #0F1E57;
    --vis-graph-node-sublabel-text-color: #989aa3;
    --vis-graph-node-sublabel-font-size: 8pt;
    // Undefined by default to allow proper fallback to var(--vis-font-family)
    /* --vis-graph-node-label-font-family: */

    --vis-dark-graph-node-label-background: var(--vis-color-grey);
    --vis-dark-graph-node-label-text-color: #ffffff;
    --vis-dark-graph-node-sublabel-text-color: #989aa3;

    /* Node Side Labels (circular labels)*/
    --vis-graph-node-side-label-background-fill-color: #a0a9af;
    --vis-graph-node-side-label-background-stroke-color: #ffffff;
    --vis-graph-node-side-label-fill-color-bright: #ffffff;
    --vis-graph-node-side-label-fill-color-dark: #494b56;

    --vis-dark-graph-node-side-label-background-fill-color: #989aa3;
    --vis-dark-graph-node-side-label-background-stroke-color: var(--vis-color-grey);
    --vis-dark-graph-node-side-label-fill-color-bright: #f1f4f7;
    --vis-dark-graph-node-side-label-fill-color-dark: var(--vis-color-grey);

    /* Greyout */
    --vis-graph-node-greyout-opacity: 0.9;
    --vis-graph-node-greyout-filter: none;
    --vis-graph-node-greyout-color: #ebeff7;
    --vis-graph-node-icon-greyout-color: #c6cad1;
    --vis-graph-node-side-label-background-greyout-color: #f1f4f7;

    --vis-dark-graph-node-greyout-color: #494b56;
    --vis-dark-graph-node-icon-greyout-color: var(--vis-color-grey);
    --vis-dark-graph-node-side-label-background-greyout-color: #494B56;

    /* Brushed */
    --vis-graph-brushed-node-stroke-color: var(--vis-color-main);
    --vis-graph-brushed-node-label-text-color: var(--vis-color-main);
    --vis-graph-brushed-node-icon-fill-color: var(--vis-color-main);
    
    /* Misc */
    --vis-graph-node-dominant-baseline: middle;
  }

  body.theme-dark ${`.${nodes3}`} {
    --vis-graph-node-stroke-color: var(--vis-dark-graph-node-stroke-color);
    --vis-graph-node-fill-color: var(--vis-dark-graph-node-fill-color);
    --vis-graph-node-gauge-color: var(--vis-dark-graph-node-gauge-color);
    --vis-graph-node-selection-color: var(--vis-dark-graph-node-selection-color);

    --vis-graph-node-icon-fill-color: var(--vis-dark-graph-node-icon-fill-color);

    --vis-graph-node-bottom-icon-fill-color: var(--vis-dark-graph-node-bottom-icon-fill-color);
    --vis-graph-node-bottom-icon-stroke-color: var(--vis-dark-graph-node-bottom-icon-stroke-color);

    --vis-graph-node-label-background: var(--vis-dark-graph-node-label-background);
    --vis-graph-node-label-text-color: var(--vis-dark-graph-node-label-text-color);
    --vis-graph-node-sublabel-text-color: var(--vis-dark-graph-node-sublabel-text-color);

    --vis-graph-node-side-label-background-fill-color: var(--vis-dark-graph-node-side-label-background-fill-color);
    --vis-graph-node-side-label-background-stroke-color: var(--vis-dark-graph-side-label-background-stroke-color);
    --vis-graph-node-side-label-fill-color-bright: var(--vis-dark-graph-node-side-label-fill-color-bright);
    --vis-graph-node-side-label-fill-color-dark: var(vis-dark-graph-node-side-label-fill-color-dark);

    --vis-graph-node-greyout-color: var(--vis-dark-graph-node-greyout-color);
    --vis-graph-node-icon-greyout-color: var(--vis-dark-graph-node-icon-greyout-color);
    --vis-graph-node-side-label-background-greyout-color: var(--vis-dark-graph-node-side-label-background-greyout-color);
  }
`;
var brushable = css`
  label: brushable;
`;
var node3 = css`
  label: node-shape;

  stroke: var(--vis-graph-node-stroke-color);
  fill: var(--vis-graph-node-fill-color);

  :not(.${brushable}) {
    transition: .4s fill, 4s stroke;
  }
`;
var nodeIcon2 = css`
  label: icon;

  font-family: var(--vis-graph-icon-font-family), var(--vis-font-family);
  dominant-baseline: var(--vis-graph-node-dominant-baseline);
  text-anchor: middle;
  pointer-events: none;
  fill: var(--vis-graph-node-icon-fill-color);

  :not(.${brushable}) {
    transition: .4s all;
  }
`;
var nodeBottomIcon = css`
  label: node-bottom-icon;
  font-family: var(--vis-graph-icon-font-family), var(--vis-font-family);
  font-size: var(--vis-graph-node-bottom-icon-font-size);
  dominant-baseline: var(--vis-graph-node-dominant-baseline);
  text-anchor: middle;
  pointer-events: none;
  fill: var(--vis-graph-node-bottom-icon-fill-color);
  stroke: var(--vis-graph-node-bottom-icon-stroke-color);
  stroke-width: var(--vis-graph-node-bottom-icon-stroke-width);

  :not(.${brushable}) {
    transition: .4s all;
  }
`;
var nodeIsDragged = css`
  label: dragged;
`;
var label8 = css`
  label: label;

  text-anchor: middle;
  font-weight: 300;
  font-size: var(--vis-graph-node-label-font-size);
`;
var labelBackground2 = css`
  label: background;

  opacity: 0.9;
  -webkit-backdrop-filter: blur(2px);
  backdrop-filter: blur(2px);
  fill: var(--vis-graph-node-label-background);
`;
var labelText2 = css`
  label: label-text;
`;
var labelTextContent = css`
  label: label-text-content;

  fill: var(--vis-graph-node-label-text-color);
  font-family: var(--vis-graph-node-label-font-family, var(--vis-font-family));
`;
var subLabelTextContent = css`
  label: sublabel-text-content;

  fill: var(--vis-graph-node-sublabel-text-color);
  font-family: var(--vis-graph-node-label-font-family, var(--vis-font-family));
  font-size: var(--vis-graph-node-sublabel-font-size);
`;
var sideLabelsGroup = css`
  label: side-labels-group;
`;
var sideLabelBackground = css`
  label: side-label-background;

  stroke-opacity: 0.8;
  stroke: var(--vis-graph-node-side-label-background-stroke-color);
  fill: var(--vis-graph-node-side-label-background-fill-color);
`;
var sideLabel = css`
  label: side-label;

  font-family: var(--vis-graph-icon-font-family), var(--vis-font-family);
  dominant-baseline: var(--vis-graph-node-dominant-baseline);
  text-anchor: middle;
  font-size: 16px;
  fill: var(--vis-graph-node-side-label-fill-color-bright);
`;
var sideLabelGroup = css`
  label: side-label-group;
  cursor: default;
`;
var gNode = css`
  label: g-node;

  transition: .25s opacity;
`;
var draggable = css`
  label: draggable;

  &:hover {
    cursor: grab;
  }

  &${`.${nodeIsDragged}`} {
    cursor: grabbing;
  }
`;
var gNodeExit = css`
  label: g-node-exit;
  pointer-events: none;
`;
var nodeSelectionActive = css`
  label: active;
`;
var nodeSelection = css`
  label: node-selection;

  fill: none;
  stroke-width: 1;
  stroke-dasharray: 3 3;
  opacity: 0;
  transition: 350ms cubic-bezier(0.165, 0.840, 0.440, 1.000);
  transform: scale(.5);
  fill: var(--vis-graph-node-selection-color);
  fill-opacity: 0.1;
  stroke: var(--vis-graph-node-selection-color);
  stroke-opacity: 0.75;

  &${`.${nodeSelectionActive}`} {
    opacity: 1;
    transform: scale(1.2);
  }
`;
var nodeGauge = css`
  label: node-gauge;

  fill: var(--vis-graph-node-gauge-color);
  transition: .4s fill;
`;
var nodePolygon = css`
  label: polygon;

  ${`.${nodeGauge}`} {
    fill-opacity: 0;
    stroke-linecap: round;
    pointer-events: none;
  }
`;
var customNode = css`
  label: custom-node;

  stroke-width: 0;
`;
var greyedOutNode = css`
  label: greyed-out;
  opacity: var(--vis-graph-node-greyout-opacity);
  filter: var(--vis-graph-node-greyout-filter);

  ${`.${node3}`} {
    fill: var(--vis-graph-node-greyout-color) !important;
    stroke: var(--vis-graph-node-greyout-color) !important;
  }

  ${`.${nodeIcon2}`} {
     fill: var(--vis-graph-node-icon-greyout-color) !important;
  }

  ${`.${nodeGauge}`} {
    fill: var(--vis-graph-node-greyout-color) !important;
    stroke: var(--vis-graph-node-greyout-color) !important;
  }

  ${`.${label8}`} {
    opacity: 0.5;
  }

  ${`.${sideLabelBackground}`} {
     fill: var(--vis-graph-node-side-label-background-greyout-color) !important;
     stroke-opacity: 0.5;
   }

   ${`.${sideLabel}`} {
    fill: var(--vis-graph-node-side-label-fill-color-bright) !important;
    opacity: 0.25;
  }
`;
var brushed = css`
  label: brushed-node;

  ${`.${node3}`} {
    stroke: var(--vis-graph-brushed-node-stroke-color);
  }
  ${`.${nodeIcon2}`} {
    fill: var(--vis-graph-brushed-node-icon-fill-color);
  }
  ${`.${labelTextContent}`} {
    fill: var(--vis-graph-brushed-node-label-text-color);
  }
`;

// node_modules/@unovis/ts/components/graph/modules/link/style.js
var links4 = css`
  label: links;
`;
var variables12 = injectGlobal`
  :root {
    --vis-graph-link-stroke-color: #e6e9f3;
    --vis-graph-link-stroke-opacity: 1.0;
    --vis-graph-link-greyout-opacity: 0.3;
    --vis-graph-link-dashed-stroke-dasharray: 6 6;

    --vis-graph-link-label-font-size: 9pt;
    --vis-graph-link-label-background: #e6e9f3;
    --vis-graph-link-label-text-color-dark: #18181B;
    --vis-graph-link-label-text-color-bright: #fff;
    --vis-graph-link-label-text-color: var(--vis-graph-link-label-text-color-dark);

    --vis-graph-link-band-opacity: 0.35;
    --vis-graph-link-support-stroke-width: 10px;
    --vis-graph-link-flow-opacity: 1;

    --vis-dark-graph-link-stroke-color: #494b56;
    --vis-dark-graph-link-label-background: #3f3f45;
    --vis-dark-graph-link-label-text-color: var(--vis-graph-link-label-text-color-bright);


    --vis-graph-link-dominant-baseline: middle;
  }

  body.theme-dark ${`.${links4}`} {
    --vis-graph-link-stroke-color: var(--vis-dark-graph-link-stroke-color);
    --vis-graph-link-label-stroke-color: var(--vis-dark-graph-link-label-stroke-color);
    --vis-graph-link-label-text-color: var(--vis-dark-graph-link-label-text-color);
    --vis-graph-link-label-background: var(--vis-dark-graph-link-label-background);
  }
`;
var linkSupport = css`
  label: link-support;

  fill: none;
  stroke-linecap: round;
  stroke-width: var(--vis-graph-link-support-stroke-width);
  stroke-opacity: 0;
  stroke: var(--vis-graph-link-stroke-color);
  transition: stroke-opacity 0.2s;
`;
var link6 = css`
  label: link;

  fill: none;
  stroke: var(--vis-graph-link-stroke-color);
  stroke-opacity: var(--vis-graph-link-stroke-opacity);
  transition: stroke 800ms;
  stroke-linecap: round;
  pointer-events: none;
`;
var linkDashed = css`
  label: dashed;

  ${`.${link6}`} {
    stroke-dasharray: var(--vis-graph-link-dashed-stroke-dasharray);
  }
`;
var linkArrow = css`
  label: link-arrow;
  fill: var(--vis-graph-link-stroke-color);
`;
var gLink = css`
  label: g-link;
`;
var gLinkExit = css`
  label: g-link-exit;
  pointer-events: none;
`;
var greyedOutLink = css`
  label: greyed-out;
  opacity: var(--vis-graph-link-greyout-opacity);
`;
var linkBand = css`
  label: link-band;

  stroke-opacity: var(--vis-graph-link-band-opacity);
  pointer-events: none;
  stroke: var(--vis-graph-node-stroke-color);
  fill: none;
`;
var flowGroup = css`
  label: flow-group;
  
  pointer-events: none;
`;
var flowCircle = css`
  label: flow-circle;

  fill: var(--vis-graph-link-stroke-color);
  opacity: var(--vis-graph-link-flow-opacity);
`;
var linkLabelGroup = css`
  label: label-group;
`;
var linkLabelBackground = css`
  label: label-background;

  fill: var(--vis-graph-link-label-background);
`;
var linkLabelContent = css`
  label: label-content;

  font-size: var(--vis-graph-link-label-font-size);
  font-family: var(--vis-font-family);
  fill: var(--vis-graph-link-label-text-color);
  text-anchor: middle;
  dominant-baseline: var(--vis-graph-link-dominant-baseline);
  user-select: none;
`;

// node_modules/@unovis/ts/components/graph/style.js
var variables13 = injectGlobal`
  :root {
    --vis-graph-icon-font-family: ${UNOVIS_ICON_FONT_FAMILY_DEFAULT};

    /* Brush */
    --vis-graph-brush-selection-opacity: 0.2;
  }
`;
var root19 = css`
  label: graph-component;
`;
var background6 = css`
  label: background;
`;
var graphGroup = css`
  label: graph-group;
`;
var brush3 = css`
  label: brush;

  :not(.active) {
    display: none;
  }

  .active {
    .selection {
      fill-opacity: 0;
      stroke: none;
    }

    .handle {
      display: none;
    }
  }
`;
var zoomOutLevel1 = css`
  label: zoom-out-level-1;

  ${`.${label8}`} {
    rect {
      stroke: none;
    }
  }
`;
var zoomOutLevel2 = css`
  label: zoom-out-level-2;

  ${`.${label8}`} {
    visibility: visible;
  }

  ${`.${nodeGauge}`} {
    visibility: visible;
  }

  ${`.${node3}`} {
    stroke-width: 4px;
  }

  rect${`.${node3}`} {
    stroke-width: 2px;
  }

  ${`.${gLink}`} {
    animation: none;
    stroke-dasharray: none;
  }

  ${`.${flowCircle}`} {
    display: none;
  }

  ${`.${nodeSelection}`} {
    &${`.${nodeSelectionActive}`} {
      transform: scale(1.15);
    }
  }
`;

// node_modules/@unovis/ts/components/graph/modules/panel/style.js
var panels = css`
  label: panels;
`;
var variables14 = injectGlobal`
  :root {
    --vis-graph-panel-border-color: #E6E9F3;
    --vis-graph-panel-border-opacity: 0.9;
    --vis-graph-panel-fill-color: #ffffff;

    --vis-graph-panel-label-color: #6c778c;
    --vis-graph-panel-label-background: #ffffff;

    // Undefined by default to allow proper fallback to var(--vis-font-family)
    /* --vis-graph-panel-label-font-family: */
    --vis-graph-panel-label-font-size: 10pt;
    --vis-graph-panel-label-font-weight: 300;

    --vis-graph-panel-dashed-outline-color: #b7b7b7;

    --vis-graph-panel-side-icon-symbol-color: #9ea7b8;
    --vis-graph-panel-side-icon-shape-fill-color: #ffffff;

    --vis-dark-graph-panel-border-color: var(--vis-color-grey);
    --vis-dark-graph-panel-fill-color: #292b34;
    --vis-dark-graph-panel-label-color: #E6E9F3;
    --vis-dark-graph-panel-label-background: var(--vis-color-grey);
    --vis-dark-graph-panel-side-icon-symbol-color: #ffffff;
    --vis-dark-graph-panel-side-icon-shape-fill-color: #6c778c;
    --vis-dark-graph-panel-border-color: #a0a6ad;
  }

  body.theme-dark ${`.${panels}`} {
    --vis-graph-panel-border-color: var(--vis-dark-graph-panel-border-color);
    --vis-graph-panel-fill-color: var(--vis-dark-graph-panel-fill-color);
    --vis-graph-panel-label-color: var(--vis-dark-graph-panel-label-color);
    --vis-graph-panel-label-background: var(--vis-dark-graph-panel-label-background);
    --vis-graph-panel-side-icon-symbol-color: var(--vis-dark-graph-panel-side-icon-symbol-color);
    --vis-graph-panel-side-icon-shape-fill-color: var(--vis-dark-graph-panel-side-icon-shape-fill-color);
    --vis-graph-panel-border-color:  var(--vis-dark-graph-panel-border-color);
  }
`;
var gPanel = css`
  label: g-panel;
`;
var panel = css`
  label: panel;

  stroke: var(--vis-graph-panel-border-color);
  stroke-opacity: var(--vis-graph-panel-border-opacity);
  fill: var(--vis-graph-panel-fill-color);
`;
var label9 = css`
  label: label;

  fill: var(--vis-graph-panel-label-color);
`;
var background7 = css`
  label: background;

  opacity: 0.9;
  -webkit-backdrop-filter: blur(2px);
  backdrop-filter: blur(2px);
  fill: var(--vis-graph-panel-label-background);
  stroke: none;
`;
var labelText3 = css`
  label: label-text;

  text-anchor: middle;
  font-size: var(--vis-graph-panel-label-font-size);
  font-weight: var(--vis-graph-panel-label-font-weight);;
  cursor: default;
  stroke: none;
  font-family: var(--vis-graph-panel-label-font-family, var(--vis-font-family));
`;
var panelSelectionActive = css`
  label: active;
`;
var panelSelection = css`
  label: panel-selection-outline;

  opacity: 0;
  stroke-width: 1;
  stroke-dasharray: 3 3;
  fill: var(--vis-graph-node-selection-color);
  fill-opacity: 0.1;
  stroke: var(--vis-graph-panel-dashed-outline-color);
  stroke-opacity: 0;

  &${`.${panelSelectionActive}`} {
    opacity: 1;
    stroke-opacity: 0.75;
  }
`;
var greyout = css`
  label: greyout;
  opacity: 0.4;
`;
var sideIconGroup = css`
  label: side-icon-group;
`;
var sideIconShape = css`
  label: side-icon-shape;

  fill: var(--vis-graph-panel-side-icon-shape-fill-color);
  stroke-width: 2px;
`;
var customSideIcon = css`
  label: side-icon-custom;
`;
var sideIconSymbol = css`
  label: side-label-icon-text;
  font-family: var(--vis-graph-icon-font-family), var(--vis-font-family);
  fill: var(--vis-graph-panel-side-icon-symbol-color);
  stroke: none;
  dominant-baseline: middle;
  text-anchor: middle;
  pointer-events: none;
  cursor: default;
`;

// node_modules/@unovis/ts/utils/svg.js
var import_striptags2 = __toESM(require_striptags(), 1);
var allowedSvgTags = [
  "svg",
  "g",
  "path",
  "rect",
  "circle",
  "ellipse",
  "line",
  "polyline",
  "polygon",
  "defs",
  "clipPath",
  "use",
  "symbol",
  "image",
  "marker",
  "style",
  "mask",
  ...allowedSvgTextTags
];
function sanitizeSvgString(svgString, allowedTags = allowedSvgTags) {
  return (0, import_striptags2.default)(svgString, allowedTags);
}
function isStringSvg(input) {
  const svgElementsRegex = new RegExp(`<(${allowedSvgTags.join("|")})\\b`, "i");
  const svgAttributesRegex = /\b(d|fill|stroke|transform|viewBox)=/i;
  return svgElementsRegex.test(input) || svgAttributesRegex.test(input);
}

// node_modules/@unovis/ts/components/graph/modules/node/helper.js
var NODE_SIZE = 30;
var LABEL_RECT_HORIZONTAL_PADDING = 10;
var LABEL_RECT_VERTICAL_PADDING = 4;
function getNodeSize(d18, nodeSizeAccessor, index3) {
  return getNumber(d18, nodeSizeAccessor, index3) || NODE_SIZE;
}
function _setInitialAnimState(el, index3) {
  el._animState = {
    endAngle: 0,
    nodeIndex: index3
  };
}
function arcTween(d18, config, arcConstructor, el) {
  var _a;
  const { nodeStrokeWidth, nodeSize, nodeGaugeValue } = config;
  if (!el._animState)
    _setInitialAnimState(el, d18._index);
  const i8 = value_default(el._animState, {
    endAngle: 2 * Math.PI * ((_a = getNumber(d18, nodeGaugeValue, d18._index)) !== null && _a !== void 0 ? _a : 0) / 100,
    nodeIndex: d18._index,
    nodeSize: getNodeSize(d18, nodeSize, d18._index),
    borderWidth: getNumber(d18, nodeStrokeWidth, d18._index)
  });
  el._animState = i8(0);
  return (t4) => {
    el._animState = i8(t4);
    return arcConstructor(el._animState);
  };
}
function polyTween(d18, config, polygonConstructor, el) {
  var _a;
  const { nodeShape, nodeGaugeValue } = config;
  const nodeSize = getNodeSize(d18, config.nodeSize, d18._index);
  let n;
  switch (getString(d18, nodeShape, d18._index)) {
    case GraphNodeShape.Square:
      n = 4;
      break;
    case GraphNodeShape.Triangle:
      n = 3;
      break;
    case GraphNodeShape.Hexagon:
    default:
      n = 6;
  }
  if (!el._animState)
    _setInitialAnimState(el, d18._index);
  const i8 = value_default(el._animState, {
    endAngle: 2 * Math.PI * ((_a = getNumber(d18, nodeGaugeValue, d18._index)) !== null && _a !== void 0 ? _a : 0) / 100,
    nodeIndex: d18._index
  });
  el._animState = i8(0);
  return (t4) => {
    el._animState = i8(t4);
    return n === 4 ? scoreRectPath({
      x: -nodeSize / 2,
      y: -nodeSize / 2,
      w: nodeSize,
      h: nodeSize,
      r: 5,
      score: el._animState.endAngle / (2 * Math.PI)
    }) : polygonConstructor(nodeSize, n, el._animState.endAngle, true);
  };
}
function setLabelRect(labelSelection, label14, selector) {
  const labelIsEmpty = isEmpty(label14);
  const labelTextSelection = labelSelection.select(`.${selector}`);
  const labelTextBBox = labelTextSelection.node().getBBox();
  const backgroundRect2 = labelSelection.select("rect").attr("visibility", labelIsEmpty ? "hidden" : null).attr("rx", 4).attr("ry", 4).attr("x", -labelTextBBox.width / 2 - LABEL_RECT_HORIZONTAL_PADDING).attr("y", "-0.64em").attr("width", labelTextBBox.width + 2 * LABEL_RECT_HORIZONTAL_PADDING).attr("height", labelTextBBox.height + 2 * LABEL_RECT_VERTICAL_PADDING).style("transform", `translateY(${-LABEL_RECT_VERTICAL_PADDING}px)`);
  return backgroundRect2;
}
function getX2(node4) {
  return node4._state && !isNil(node4._state.fx) ? node4._state.fx : node4.x;
}
function getY2(node4) {
  return node4._state && !isNil(node4._state.fy) ? node4._state.fy : node4.y;
}
function configuredNodeSize(nodeSizeAccessor) {
  return typeof nodeSizeAccessor === "number" ? nodeSizeAccessor : NODE_SIZE;
}
function getMaxNodeSize(data, nodeSize) {
  return max(data || [], (d18, i8) => getNodeSize(d18, nodeSize, i8)) || NODE_SIZE;
}
function getAverageNodeSize(data, nodeSize) {
  return mean(data || [], (d18, i8) => getNodeSize(d18, nodeSize, i8)) || NODE_SIZE;
}
function getSideLabelTextColor(label14, context) {
  if (!label14.color)
    return null;
  const hex2 = getHexValue(label14.color, context);
  const brightness = hexToBrightness(hex2);
  return brightness > 0.65 ? "var(--vis-graph-node-side-label-fill-color-dark)" : "var(--vis-graph-node-side-label-fill-color-bright)";
}
function getNodeColor(d18, colorAccessor, index3) {
  var _a;
  return (_a = getColor(d18, colorAccessor, index3, true)) !== null && _a !== void 0 ? _a : null;
}
function getNodeIconColor(d18, colorAccessor, index3, context) {
  const nodeColor = getNodeColor(d18, colorAccessor, index3);
  if (!nodeColor)
    return null;
  const hex2 = getHexValue(nodeColor, context);
  const brightness = hexToBrightness(hex2);
  return brightness > 0.65 ? "var(--vis-graph-node-icon-fill-color-dark)" : "var(--vis-graph-node-icon-fill-color-bright)";
}
function isInternalHref(str) {
  return /^#[^]+/.test(str);
}

// node_modules/@unovis/ts/components/graph/modules/shape.js
function appendShape(selection2, shapeAccessor, shapeSelector, customShapeSelector, index3, insertSelector = ":last-child") {
  selection2.each((d18, i8, elements) => {
    const element = select_default2(elements[i8]);
    const shape = getString(d18, shapeAccessor, index3);
    let shapeElement;
    const isCustomShape = isStringSvg(shape);
    if (isCustomShape) {
      shapeElement = element.insert("g", insertSelector).html(sanitizeSvgString(shape));
    } else {
      switch (shape) {
        case GraphNodeShape.Square:
          shapeElement = element.insert("rect", insertSelector).attr("rx", 5).attr("ry", 5);
          break;
        case GraphNodeShape.Hexagon:
        case GraphNodeShape.Triangle:
          shapeElement = element.insert("path", insertSelector);
          break;
        case GraphNodeShape.Circle:
        default:
          shapeElement = element.insert("circle", insertSelector);
      }
    }
    shapeElement.classed(customShapeSelector, isCustomShape);
    return shapeElement.attr("class", shapeSelector);
  });
}
function updateShape(selection2, shape, size2, index3) {
  if (selection2.size() === 0)
    return;
  const d18 = selection2.datum();
  const nodeSize = getNodeSize(d18, size2, index3);
  selection2.filter("circle").attr("r", nodeSize / 2);
  selection2.filter("rect").attr("width", nodeSize).attr("height", nodeSize).attr("x", -nodeSize / 2).attr("y", -nodeSize / 2);
  selection2.filter("path").attr("d", () => {
    let n;
    switch (getString(d18, shape, index3)) {
      case GraphNodeShape.Square:
        n = 4;
        break;
      case GraphNodeShape.Triangle:
        n = 3;
        break;
      case GraphNodeShape.Hexagon:
      default:
        n = 6;
    }
    return polygon(nodeSize, n);
  });
  selection2.filter("g").filter(() => !isStringSvg(getString(d18, shape, index3))).html(getString(d18, shape, index3));
  selection2.filter("g").each((d19, i8, elements) => {
    const el = select_default2(elements[i8]);
    const bBox = el.node().getBBox();
    el.attr("transform", `translate(${-bBox.width / 2},${-bBox.height / 2})`);
  });
}

// node_modules/@unovis/ts/components/graph/modules/zoom-levels.js
var ZoomLevel;
(function(ZoomLevel2) {
  ZoomLevel2[ZoomLevel2["Level0"] = 1] = "Level0";
  ZoomLevel2[ZoomLevel2["Level1"] = 0.6] = "Level1";
  ZoomLevel2[ZoomLevel2["Level2"] = 0.4] = "Level2";
  ZoomLevel2[ZoomLevel2["Level3"] = 0.2] = "Level3";
})(ZoomLevel || (ZoomLevel = {}));

// node_modules/@unovis/ts/components/graph/modules/node/index.js
var SIDE_LABEL_DEFAULT_RADIUS = 10;
function createNodes3(selection2, config, duration, scale = 1) {
  selection2.each((d18, i8, elements) => {
    const element = elements[i8];
    const group3 = select_default2(element);
    group3.attr("transform", (d19, i9) => {
      var _a, _b, _c;
      const configuredPosition = getValue(d19, config.nodeEnterPosition, i9);
      const scale2 = (_a = getNumber(d19, config.nodeEnterScale, i9)) !== null && _a !== void 0 ? _a : 0;
      const x21 = (_b = configuredPosition === null || configuredPosition === void 0 ? void 0 : configuredPosition[0]) !== null && _b !== void 0 ? _b : getX2(d19);
      const y25 = (_c = configuredPosition === null || configuredPosition === void 0 ? void 0 : configuredPosition[1]) !== null && _c !== void 0 ? _c : getY2(d19);
      return `translate(${x21}, ${y25}) scale(${scale2})`;
    }).attr("opacity", 0);
    if (config.nodeEnterCustomRenderFunction) {
      config.nodeEnterCustomRenderFunction(d18, group3, config, duration, scale);
    } else {
      const shape = getString(d18, config.nodeShape, d18._index);
      element.nodeShape = shape;
      appendShape(group3, shape, node3, customNode, d18._index);
      appendShape(group3, shape, nodeSelection, customNode, d18._index);
      group3.append("path").attr("class", nodeGauge);
      group3.append("g").attr("class", nodeIcon2);
      group3.append("g").attr("class", sideLabelsGroup);
      group3.append("text").attr("class", nodeBottomIcon);
    }
    const label$1 = group3.append("g").attr("class", label8);
    label$1.append("rect").attr("class", labelBackground2);
    const labelText$1 = label$1.append("text").attr("class", labelText2).attr("dy", "0.32em");
    labelText$1.append("tspan").attr("class", labelTextContent);
    labelText$1.append("tspan").attr("class", subLabelTextContent).attr("dy", "1.1em").attr("x", "0");
  });
}
function updateNodesPartial(selection2, config, duration, scale = 1) {
  const { nodeDisabled } = config;
  if (config.nodePartialUpdateCustomRenderFunction || config.nodeEnterCustomRenderFunction) {
    selection2.each((d18, i8, elements) => {
      var _a;
      const g15 = select_default2(elements[i8]);
      (_a = config.nodePartialUpdateCustomRenderFunction) === null || _a === void 0 ? void 0 : _a.call(config, d18, g15, config, duration, scale);
    });
  } else {
    selection2.each((d18, i8, elements) => {
      const group3 = select_default2(elements[i8]);
      const isGreyout = getBoolean(d18, nodeDisabled, d18._index) || d18._state.greyout;
      group3.classed(greyedOutNode, isGreyout && !d18._state.brushed).classed(draggable, !config.disableDrag);
      const nodeSelectionOutline = group3.selectAll(`.${nodeSelection}`);
      nodeSelectionOutline.classed(nodeSelectionActive, d18._state.selected || d18._state.brushed);
      group3.selectAll(`.${sideLabel}`).style("fill", (l7) => isGreyout ? null : getSideLabelTextColor(l7, selection2.node()));
      group3.selectAll(`.${sideLabelBackground}`).style("fill", (l7) => isGreyout ? null : l7.color);
    });
  }
}
function updateNodePositions(selection2, duration) {
  return smartTransition(selection2, duration).attr("transform", (d18) => `translate(${getX2(d18)}, ${getY2(d18)}) scale(1)`).attr("opacity", 1);
}
function updateNodes3(selection2, config, duration, scale = 1) {
  const { nodeGaugeAnimDuration, nodeStrokeWidth, nodeShape, nodeSize, nodeGaugeValue, nodeGaugeFill, nodeIcon: nodeIcon$1, nodeIconSize, nodeLabel, nodeLabelTrim, nodeLabelTrimMode, nodeLabelTrimLength, nodeSubLabel, nodeSubLabelTrim, nodeSubLabelTrimMode, nodeSubLabelTrimLength, nodeSideLabels, nodeStroke, nodeFill, nodeBottomIcon: nodeBottomIcon$1 } = config;
  const nodeGroupsUpdate = updateNodePositions(selection2, duration);
  if (config.nodeUpdateCustomRenderFunction) {
    selection2.each((d18, i8, elements) => {
      const g15 = select_default2(elements[i8]);
      config.nodeUpdateCustomRenderFunction(d18, g15, config, duration, scale);
    });
    updateNodesPartial(selection2, config, duration, scale);
    return nodeGroupsUpdate;
  }
  selection2.each((d18, i8, elements) => {
    const element = elements[i8];
    const group3 = select_default2(element);
    const shape = getString(d18, nodeShape, d18._index);
    if (element.nodeShape !== shape) {
      group3.select(`.${node3}`).remove();
      appendShape(group3, nodeShape, node3, customNode, d18._index, `.${nodeSelection}`);
      group3.select(`.${nodeSelection}`).remove();
      appendShape(group3, shape, nodeSelection, null, d18._index, `.${nodeGauge}`);
      element.nodeShape = shape;
    }
  });
  selection2.each((d18, i8, elements) => {
    var _a, _b, _c;
    const groupElement = elements[i8];
    const group3 = select_default2(groupElement);
    const node$1 = group3.select(`.${node3}`);
    const nodeArc = group3.select(`.${nodeGauge}`);
    const icon = group3.select(`.${nodeIcon2}`);
    const sideLabelsGroup$1 = group3.select(`.${sideLabelsGroup}`);
    const label$1 = group3.select(`.${label8}`);
    const labelTextContent$1 = label$1.select(`.${labelTextContent}`);
    const sublabelTextContent = label$1.select(`.${subLabelTextContent}`);
    const bottomIcon = group3.select(`.${nodeBottomIcon}`);
    const nodeSelectionOutline = group3.select(`.${nodeSelection}`);
    const nodeSizeValue = getNodeSize(d18, nodeSize, d18._index);
    const arcGenerator = arc_default().innerRadius((state) => state.nodeSize / 2 - state.borderWidth / 2).outerRadius((state) => state.nodeSize / 2 + state.borderWidth / 2).startAngle(0 * (Math.PI / 180)).endAngle((a7) => a7["endAngle"]);
    group3.classed(zoomOutLevel2, scale < ZoomLevel.Level2).classed(nodeIsDragged, (d19) => d19._state.isDragged);
    group3.classed(nodePolygon, () => {
      const shape = getString(d18, nodeShape, d18._index);
      return shape === GraphNodeShape.Triangle || shape === GraphNodeShape.Hexagon || shape === GraphNodeShape.Square;
    });
    node$1.call(updateShape, nodeShape, nodeSize, d18._index).attr("stroke-width", (_a = getNumber(d18, nodeStrokeWidth, d18._index)) !== null && _a !== void 0 ? _a : 0).style("fill", getNodeColor(d18, nodeFill, d18._index)).style("stroke", (_b = getColor(d18, nodeStroke, d18._index, true)) !== null && _b !== void 0 ? _b : null);
    const nodeBBox = node$1.node().getBBox();
    nodeArc.attr("stroke-width", getNumber(d18, nodeStrokeWidth, d18._index)).style("display", !getNumber(d18, nodeGaugeValue, d18._index) ? "none" : null).style("fill", getNodeColor(d18, nodeGaugeFill, d18._index)).style("stroke", getNodeColor(d18, nodeGaugeFill, d18._index)).style("stroke-opacity", (d19) => getString(d19, nodeShape, d19._index) === GraphNodeShape.Circle ? 0 : null);
    nodeArc.transition().duration(nodeGaugeAnimDuration).attrTween("d", (d19, j6, arr) => {
      switch (getString(d19, nodeShape, d19._index)) {
        case GraphNodeShape.Circle:
          return arcTween(d19, config, arcGenerator, arr[j6]);
        case GraphNodeShape.Hexagon:
          return polyTween(d19, config, polygon, arr[j6]);
        case GraphNodeShape.Square:
          return polyTween(d19, config, polygon, arr[j6]);
        case GraphNodeShape.Triangle:
          return polyTween(d19, config, polygon, arr[j6]);
        default:
          return null;
      }
    });
    updateShape(nodeSelectionOutline, nodeShape, nodeSize, d18._index);
    const prevNodeIconValue = groupElement.nodeIcon;
    const nodeIconValue = getString(d18, nodeIcon$1, d18._index);
    const nodeIconSizeValue = (_c = getNumber(d18, nodeIconSize, d18._index)) !== null && _c !== void 0 ? _c : 2.5 * Math.sqrt(nodeSizeValue);
    const nodeIconColor = getNodeIconColor(d18, nodeFill, d18._index, selection2.node());
    const shouldRenderUseElement = isInternalHref(nodeIconValue);
    if (prevNodeIconValue !== nodeIconValue) {
      icon.selectAll("*").remove();
      icon.append(shouldRenderUseElement ? "use" : "text");
      groupElement.nodeIcon = nodeIconValue;
    }
    if (shouldRenderUseElement) {
      icon.select("use").attr("href", nodeIconValue).attr("x", -nodeIconSizeValue / 2).attr("y", -nodeIconSizeValue / 2).attr("width", nodeIconSizeValue).attr("height", nodeIconSizeValue).style("fill", nodeIconColor);
    } else {
      icon.select("text").style("font-size", `${nodeIconSizeValue}px`).attr("dy", "0.1em").style("fill", nodeIconColor).html(nodeIconValue);
    }
    const sideLabelsData = getValue(d18, nodeSideLabels, d18._index) || [];
    const sideLabels = sideLabelsGroup$1.selectAll("g").data(sideLabelsData);
    const sideLabelsEnter = sideLabels.enter().append("g").attr("class", sideLabelGroup);
    sideLabelsEnter.append("circle").attr("class", sideLabelBackground).attr("r", (l7) => {
      var _a2;
      return (_a2 = l7.radius) !== null && _a2 !== void 0 ? _a2 : SIDE_LABEL_DEFAULT_RADIUS;
    });
    sideLabelsEnter.append("text").attr("class", sideLabel);
    const sideLabelsUpdate = sideLabels.merge(sideLabelsEnter).style("cursor", (l7) => {
      var _a2;
      return (_a2 = l7.cursor) !== null && _a2 !== void 0 ? _a2 : null;
    });
    sideLabelsUpdate.select(`.${sideLabel}`).html((d19) => d19.text).attr("dy", "0.1em").style("fill", (l7) => {
      var _a2;
      return (_a2 = l7.textColor) !== null && _a2 !== void 0 ? _a2 : getSideLabelTextColor(l7, selection2.node());
    }).style("font-size", (l7) => {
      var _a2, _b2;
      return (_a2 = l7.fontSize) !== null && _a2 !== void 0 ? _a2 : `${(2 + ((_b2 = l7.radius) !== null && _b2 !== void 0 ? _b2 : SIDE_LABEL_DEFAULT_RADIUS)) / Math.pow(l7.text.toString().length, 0.3)}px`;
    });
    sideLabelsUpdate.select(`.${sideLabelBackground}`).style("fill", (l7) => l7.color);
    sideLabelsUpdate.attr("transform", (l7, j6) => {
      var _a2;
      if (sideLabelsData.length === 1)
        return `translate(${nodeSizeValue / 2.5}, ${-nodeSizeValue / 2.5})`;
      const r4 = 1.05 * nodeSizeValue / 2;
      const angle = j6 * 1.15 * 2 * Math.atan2((_a2 = l7.radius) !== null && _a2 !== void 0 ? _a2 : SIDE_LABEL_DEFAULT_RADIUS, r4) - Math.PI / 3;
      return `translate(${r4 * Math.cos(angle)}, ${r4 * Math.sin(angle)})`;
    });
    sideLabels.exit().remove();
    const labelText$1 = getString(d18, nodeLabel, d18._index);
    const sublabelText = getString(d18, nodeSubLabel, d18._index);
    const labelTextTrimmed = getBoolean(d18, nodeLabelTrim, d18._index) ? trimString(labelText$1, getNumber(d18, nodeLabelTrimLength, d18._index), getValue(d18, nodeLabelTrimMode, d18._index)) : labelText$1;
    const sublabelTextTrimmed = getBoolean(d18, nodeSubLabelTrim, d18._index) ? trimString(sublabelText, getNumber(d18, nodeSubLabelTrimLength, d18._index), getValue(d18, nodeSubLabelTrimMode, d18._index)) : sublabelText;
    labelTextContent$1.text(labelTextTrimmed);
    sublabelTextContent.text(sublabelTextTrimmed);
    group3.on("mouseenter", () => {
      labelTextContent$1.text(labelText$1);
      sublabelTextContent.text(sublabelText);
      setLabelRect(label$1, labelText$1, labelText2);
      group3.raise();
    }).on("mouseleave", () => {
      labelTextContent$1.text(labelTextTrimmed);
      sublabelTextContent.text(sublabelTextTrimmed);
      setLabelRect(label$1, labelTextTrimmed, labelText2);
    });
    const labelFontSize = parseFloat(window.getComputedStyle(groupElement).getPropertyValue("--vis-graph-node-label-font-size")) || 12;
    const labelMargin = LABEL_RECT_VERTICAL_PADDING + 1.25 * Math.pow(labelFontSize, 1.03);
    const nodeHeight = isStringSvg(getString(d18, nodeShape, d18._index)) ? nodeBBox.height : nodeSizeValue;
    label$1.attr("transform", `translate(0, ${nodeHeight / 2 + labelMargin})`);
    if (scale >= ZoomLevel.Level3)
      setLabelRect(label$1, getString(d18, nodeLabel, d18._index), labelText2);
    bottomIcon.html(getString(d18, nodeBottomIcon$1, d18._index)).attr("transform", `translate(0, ${nodeHeight / 2})`);
  });
  updateNodesPartial(selection2, config, duration, scale);
  return nodeGroupsUpdate;
}
function removeNodes3(selection2, config, duration, scale = 1) {
  smartTransition(selection2, duration / 2).attr("opacity", 0).attr("transform", (d18, i8) => {
    var _a, _b, _c;
    const configuredPosition = getValue(d18, config.nodeExitPosition, i8);
    const scale2 = (_a = getNumber(d18, config.nodeExitScale, i8)) !== null && _a !== void 0 ? _a : 0;
    const x21 = (_b = configuredPosition === null || configuredPosition === void 0 ? void 0 : configuredPosition[0]) !== null && _b !== void 0 ? _b : getX2(d18);
    const y25 = (_c = configuredPosition === null || configuredPosition === void 0 ? void 0 : configuredPosition[1]) !== null && _c !== void 0 ? _c : getY2(d18);
    return `translate(${x21}, ${y25}) scale(${scale2})`;
  }).remove();
  if (config.nodeExitCustomRenderFunction) {
    selection2.each((d18, i8, elements) => {
      const g15 = select_default2(elements[i8]);
      config.nodeExitCustomRenderFunction(d18, g15, config, duration, scale);
    });
  }
}
function setLabelBackgroundRect(selection2, config) {
  const { nodeLabel } = config;
  selection2.each((d18, i8, elements) => {
    const group3 = select_default2(elements[i8]);
    const label$1 = group3.select(`.${label8}`);
    setLabelRect(label$1, getString(d18, nodeLabel, i8), labelText2);
  });
}
var setLabelBackgroundRectThrottled = throttle(setLabelBackgroundRect, 1e3);
function zoomNodes(selection2, config, scale) {
  if (config.nodeOnZoomCustomRenderFunction || config.nodeEnterCustomRenderFunction) {
    selection2.each((d18, i8, elements) => {
      var _a;
      const g15 = select_default2(elements[i8]);
      (_a = config.nodeOnZoomCustomRenderFunction) === null || _a === void 0 ? void 0 : _a.call(config, d18, g15, config, scale);
    });
  } else {
    selection2.classed(zoomOutLevel1, scale < ZoomLevel.Level1);
    selection2.classed(zoomOutLevel2, scale < ZoomLevel.Level2);
    selection2.selectAll(`${sideLabelBackground}`).attr("transform", `scale(${1 / Math.pow(scale, 0.35)})`);
    selection2.selectAll(`.${sideLabel}`).attr("transform", `scale(${1 / Math.pow(scale, 0.45)})`);
    if (scale >= ZoomLevel.Level3)
      selection2.call(setLabelBackgroundRectThrottled, config);
  }
}
var zoomNodesThrottled = throttle(zoomNodes, 500);

// node_modules/@unovis/ts/components/graph/modules/link/index.js
var import_to_px4 = __toESM(require_browser(), 1);

// node_modules/@unovis/ts/components/graph/modules/link/helper.js
var LINK_MARKER_WIDTH = 9;
var LINK_MARKER_HEIGHT = 7;
function getLinkShift(link7, spacing) {
  const sourceNode = link7.source;
  const targetNode = link7.target;
  const angle = Math.atan2(getY2(targetNode) - getY2(sourceNode), getX2(targetNode) - getX2(sourceNode)) - Math.PI / 2;
  const dx = Math.cos(angle) * spacing * link7._direction * (link7._index - (link7._neighbours - 1) / 2);
  const dy = Math.sin(angle) * spacing * link7._direction * (link7._index - (link7._neighbours - 1) / 2);
  return { dx, dy };
}
function getLinkShiftTransform(link7, spacing) {
  const { dx, dy } = getLinkShift(link7, spacing);
  return `translate(${dx}, ${dy})`;
}
function getLinkStrokeWidth(d18, scale, config) {
  const m30 = getNumber(d18, config.linkWidth, d18._indexGlobal);
  return m30 / Math.pow(scale, 0.5);
}
function getLinkBandWidth(d18, scale, config) {
  const { nodeSize, linkBandWidth } = config;
  const sourceNodeSize = getNumber(d18.source, nodeSize, d18.source._index);
  const targetNodeSize = getNumber(d18.target, nodeSize, d18.target._index);
  const minNodeSize = Math.min(sourceNodeSize, targetNodeSize);
  return Math.min(minNodeSize, getNumber(d18, linkBandWidth, d18._indexGlobal) / Math.pow(scale || 1, 0.5)) || 0;
}
function getLinkColor(link7, config) {
  var _a;
  const { linkStroke } = config;
  const c6 = (_a = getColor(link7, linkStroke, link7._indexGlobal, true)) !== null && _a !== void 0 ? _a : "var(--vis-graph-link-stroke-color)";
  return c6 || null;
}
function getLinkArrowStyle(d18, config) {
  const linkArrowValue = getValue(d18, config.linkArrow, d18._indexGlobal);
  if (!linkArrowValue)
    return void 0;
  else if (linkArrowValue === GraphLinkArrowStyle.Double)
    return linkArrowValue;
  else
    return GraphLinkArrowStyle.Single;
}
function getArrowPath() {
  return `M${-LINK_MARKER_WIDTH / 2},${-LINK_MARKER_HEIGHT / 2} V${LINK_MARKER_HEIGHT / 2} L${LINK_MARKER_WIDTH / 2},0 Z`;
}
function getDoubleArrowPath() {
  return `M${-LINK_MARKER_WIDTH / 2},0 L${LINK_MARKER_WIDTH / 2},${-LINK_MARKER_HEIGHT / 2} L${LINK_MARKER_WIDTH * 1.5},0 L${LINK_MARKER_WIDTH / 2},${LINK_MARKER_HEIGHT / 2} Z`;
}
function getLinkLabelTextColor(label14) {
  if (!label14.color)
    return null;
  const hex2 = color(label14.color).hex();
  const brightness = hexToBrightness(hex2);
  return brightness > 0.65 ? "var(--vis-graph-link-label-text-color-dark)" : "var(--vis-graph-link-label-text-color-bright)";
}

// node_modules/@unovis/ts/components/graph/modules/link/index.js
function createLinks2(selection2) {
  selection2.attr("opacity", 0);
  selection2.append("path").attr("class", linkSupport);
  selection2.append("path").attr("class", link6);
  selection2.append("path").attr("class", linkBand);
  selection2.append("use").attr("class", linkArrow);
  selection2.append("g").attr("class", flowGroup).style("opacity", 0).selectAll(`.${flowCircle}`).data(range(0, 6)).enter().append("circle").attr("class", flowCircle);
}
function updateLinksPartial(selection2, config, scale) {
  const isGreyedOut = (d18, i8) => getBoolean(d18, config.linkDisabled, i8) || d18._state.greyout;
  selection2.classed(greyedOutLink, (d18, i8) => isGreyedOut(d18, i8));
  selection2.each((d18, i8, elements) => {
    const element = elements[i8];
    const group3 = select_default2(element);
    group3.select(`.${link6}`);
    group3.select(`.${linkBand}`);
    const linkSupport$1 = group3.select(`.${linkSupport}`);
    linkSupport$1.style("stroke-opacity", d18._state.hovered || d18._state.selected ? 0.2 : 0).style("stroke-width", d18._state.selected ? getLinkBandWidth(d18, scale, config) + 5 : d18._state.hovered ? getLinkBandWidth(d18, scale, config) + 10 : null);
  });
}
function updateLinkLines(selection2, config, duration, scale = 1, getLinkArrowDefId, linkPathLengthMap) {
  return selection2.each((d18, i8, elements) => {
    var _a;
    const element = elements[i8];
    const linkGroup = select_default2(element);
    const link$1 = linkGroup.select(`.${link6}`);
    const linkBand$1 = linkGroup.select(`.${linkBand}`);
    const linkSupport$1 = linkGroup.select(`.${linkSupport}`);
    const linkArrow$1 = linkGroup.select(`.${linkArrow}`);
    const linkColor = getLinkColor(d18, config);
    const linkShiftTransform = getLinkShiftTransform(d18, config.linkNeighborSpacing);
    const linkLabelData = ensureArray(getValue(d18, config.linkLabel, d18._indexGlobal));
    const offsetSource = getValue(d18, config.linkSourcePointOffset, i8);
    const offsetTarget = getValue(d18, config.linkTargetPointOffset, i8);
    const x110 = getX2(d18.source) + ((offsetSource === null || offsetSource === void 0 ? void 0 : offsetSource[0]) || 0);
    const y110 = getY2(d18.source) + ((offsetSource === null || offsetSource === void 0 ? void 0 : offsetSource[1]) || 0);
    const x22 = getX2(d18.target) + ((offsetTarget === null || offsetTarget === void 0 ? void 0 : offsetTarget[0]) || 0);
    const y25 = getY2(d18.target) + ((offsetTarget === null || offsetTarget === void 0 ? void 0 : offsetTarget[1]) || 0);
    const curvature = (_a = getNumber(d18, config.linkCurvature, i8)) !== null && _a !== void 0 ? _a : 0;
    const cp1x = x110 + (x22 - x110) * 0.5 * curvature;
    const cp1y = y110 + (y25 - y110) * 0 * curvature;
    const cp2x = x110 + (x22 - x110) * 0.5 * curvature;
    const cp2y = y110 + (y25 - y110) * 1 * curvature;
    const pathData = `M${x110},${y110} C${cp1x},${cp1y} ${cp2x},${cp2y} ${x22},${y25}`;
    const linkPathElement = linkSupport$1.attr("d", pathData).node();
    const cachedLinkPathLength = linkPathLengthMap.get(pathData);
    const pathLength = cachedLinkPathLength !== null && cachedLinkPathLength !== void 0 ? cachedLinkPathLength : linkPathElement.getTotalLength();
    if (!cachedLinkPathLength)
      linkPathLengthMap.set(pathData, pathLength);
    linkSupport$1.style("stroke", linkColor).attr("transform", linkShiftTransform);
    link$1.attr("class", link6).style("stroke-width", getLinkStrokeWidth(d18, scale, config)).style("stroke", linkColor).attr("transform", linkShiftTransform);
    smartTransition(link$1, duration).attr("d", pathData);
    linkBand$1.attr("class", linkBand).attr("transform", linkShiftTransform).style("stroke-width", getLinkBandWidth(d18, scale, config)).style("stroke", linkColor);
    smartTransition(linkBand$1, duration).attr("d", pathData);
    const linkArrowStyle = getLinkArrowStyle(d18, config);
    if (linkArrowStyle) {
      const arrowPos = pathLength * (linkLabelData.length ? 0.65 : 0.5);
      const p1 = linkPathElement.getPointAtLength(arrowPos);
      const p22 = linkPathElement.getPointAtLength(arrowPos + 1);
      const angle = Math.atan2(p22.y - p1.y, p22.x - p1.x) * (180 / Math.PI);
      const arrowWasShownBefore = linkArrow$1.attr("href");
      linkArrow$1.attr("href", `#${getLinkArrowDefId(linkArrowStyle)}`);
      smartTransition(linkArrow$1, arrowWasShownBefore ? duration : 0).attr("fill", linkColor).attr("transform", `translate(${p1.x}, ${p1.y}) rotate(${angle})`);
    } else {
      linkArrow$1.attr("href", null);
    }
  });
}
function updateLinks2(selection2, config, duration, scale = 1, getLinkArrowDefId, linkPathLengthMap) {
  const { linkStyle, linkFlow, linkLabel, linkLabelShiftFromCenter } = config;
  if (!selection2.size())
    return;
  selection2.classed(linkDashed, (d18) => getValue(d18, linkStyle, d18._indexGlobal) === GraphLinkStyle.Dashed);
  updateLinkLines(selection2, config, duration, scale, getLinkArrowDefId, linkPathLengthMap);
  selection2.each((d18, i8, elements) => {
    const element = elements[i8];
    const linkGroup = select_default2(element);
    const flowGroup$1 = linkGroup.select(`.${flowGroup}`);
    const linkSupport$1 = linkGroup.select(`.${linkSupport}`);
    const linkPathElement = linkSupport$1.node();
    const linkColor = getLinkColor(d18, config);
    const linkShiftTransform = getLinkShiftTransform(d18, config.linkNeighborSpacing);
    const linkLabelData = ensureArray(getValue(d18, linkLabel, d18._indexGlobal));
    const linkFlowParticleSize = getNumber(d18, config.linkFlowParticleSize, d18._indexGlobal);
    flowGroup$1.attr("transform", linkShiftTransform).style("display", getBoolean(d18, linkFlow, d18._indexGlobal) ? null : "none");
    flowGroup$1.selectAll(`.${flowCircle}`).attr("r", linkFlowParticleSize / Math.sqrt(scale)).style("fill", linkColor);
    smartTransition(flowGroup$1, duration).style("opacity", scale < ZoomLevel.Level2 ? 0 : 1);
    const linkLabelsDataPrepared = linkLabelData.map((linkLabelDatum) => {
      var _a, _b, _c;
      const text = ((_a = linkLabelDatum.text) === null || _a === void 0 ? void 0 : _a.toString()) || "";
      const shouldRenderUseElement = isInternalHref(text);
      const fontSizePx = (_b = (0, import_to_px4.default)(linkLabelDatum.fontSize)) !== null && _b !== void 0 ? _b : getCSSVariableValueInPixels("var(--vis-graph-link-label-font-size)", linkGroup.node());
      const shouldBeRenderedAsCircle = text.length <= 2 || shouldRenderUseElement;
      const paddingVertical = 4;
      const paddingHorizontal = shouldBeRenderedAsCircle ? paddingVertical : 8;
      const estimatedWidthPx = estimateStringPixelLength(text, fontSizePx);
      return Object.assign(Object.assign({}, linkLabelDatum), { _shouldRenderUseElement: shouldRenderUseElement, _fontSizePx: fontSizePx, _shouldBeRenderedAsCircle: shouldBeRenderedAsCircle, _paddingVertical: paddingVertical, _paddingHorizontal: paddingHorizontal, _estimatedWidthPx: estimatedWidthPx, _borderRadius: (_c = linkLabelDatum.radius) !== null && _c !== void 0 ? _c : shouldBeRenderedAsCircle ? fontSizePx : 4, _backgroundWidth: (shouldBeRenderedAsCircle ? fontSizePx : estimatedWidthPx) + paddingHorizontal * 2, _backgroundHeight: fontSizePx + paddingVertical * 2 });
    });
    const linkLabelGroups = linkGroup.selectAll(`.${linkLabelGroup}`).data(linkLabelsDataPrepared, (d19) => d19.text);
    const linkLabelGroupsEnter = linkLabelGroups.enter().append("g").attr("class", linkLabelGroup);
    linkLabelGroupsEnter.each((linkLabelDatum, i9, elements2) => {
      var _a;
      const linkLabelGroup2 = select_default2(elements2[i9]);
      linkLabelGroup2.append("rect").attr("class", linkLabelBackground);
      const linkLabelText = linkLabelDatum ? (_a = linkLabelDatum.text) === null || _a === void 0 ? void 0 : _a.toString() : void 0;
      const shouldRenderUseElement = isInternalHref(linkLabelText);
      linkLabelGroup2.select(`.${linkLabelContent}`).remove();
      linkLabelGroup2.append(shouldRenderUseElement ? "use" : "text").attr("class", linkLabelContent);
    });
    linkLabelGroupsEnter.style("opacity", 0);
    const linkLabelGroupsMerged = linkLabelGroups.merge(linkLabelGroupsEnter);
    const linkLabelMargin = 1;
    let linkLabelShiftCumulative = -sum(linkLabelsDataPrepared, (d19) => d19._backgroundWidth + linkLabelMargin) / 2;
    const cachedLinkPathLength = linkPathLengthMap.get(linkPathElement.getAttribute("d"));
    const pathLength = cachedLinkPathLength !== null && cachedLinkPathLength !== void 0 ? cachedLinkPathLength : linkPathElement.getTotalLength();
    const linkArrowStyle = getLinkArrowStyle(d18, config);
    linkLabelGroupsMerged.each((linkLabelDatum, i9, elements2) => {
      var _a, _b;
      const element2 = elements2[i9];
      const linkLabelGroup2 = select_default2(element2);
      const linkLabelText = (_a = linkLabelDatum.text) === null || _a === void 0 ? void 0 : _a.toString();
      const linkLabelContent$1 = linkLabelGroup2.select(`.${linkLabelContent}`);
      const linkMarkerWidth = linkArrowStyle ? LINK_MARKER_WIDTH * 2 : 0;
      const linkLabelShift = getBoolean(d18, linkLabelShiftFromCenter, d18._indexGlobal) ? -linkMarkerWidth + 4 : 0;
      const linkLabelPos = linkPathElement.getPointAtLength(pathLength / 2 + linkLabelShift + linkLabelShiftCumulative + linkLabelDatum._backgroundWidth / 2);
      const linkLabelTranslate = `translate(${linkLabelPos.x}, ${linkLabelPos.y})`;
      const linkLabelBackground$1 = linkLabelGroup2.select(`.${linkLabelBackground}`);
      if (!linkLabelGroup2.attr("transform")) {
        linkLabelGroup2.attr("transform", `${linkLabelTranslate} scale(0)`);
      }
      const linkLabelColor = (_b = linkLabelDatum.textColor) !== null && _b !== void 0 ? _b : getLinkLabelTextColor(linkLabelDatum);
      if (linkLabelDatum._shouldRenderUseElement) {
        linkLabelContent$1.attr("href", linkLabelText).attr("x", -linkLabelDatum._fontSizePx / 2).attr("y", -linkLabelDatum._fontSizePx / 2).attr("width", linkLabelDatum._fontSizePx).attr("height", linkLabelDatum._fontSizePx).style("fill", linkLabelColor);
      } else {
        linkLabelContent$1.text(linkLabelText).attr("dy", "0.1em").style("font-size", linkLabelDatum._fontSizePx).style("fill", linkLabelColor);
      }
      linkLabelGroup2.attr("hidden", null).style("cursor", linkLabelDatum.cursor);
      smartTransition(linkLabelGroup2, duration).attr("transform", `${linkLabelTranslate} scale(1)`).style("opacity", 1);
      linkLabelBackground$1.attr("x", -linkLabelDatum._backgroundWidth / 2).attr("y", -linkLabelDatum._backgroundHeight / 2).attr("width", linkLabelDatum._backgroundWidth).attr("height", linkLabelDatum._backgroundHeight).attr("rx", linkLabelDatum._borderRadius).style("fill", linkLabelDatum.color);
      linkLabelShiftCumulative += linkLabelDatum._backgroundWidth + linkLabelMargin;
    });
    smartTransition(linkLabelGroups.exit(), duration).style("opacity", 0).remove();
  });
  if (duration > 0) {
    selection2.attr("pointer-events", "none");
    const t4 = smartTransition(selection2, duration);
    t4.attr("opacity", 1).on("end interrupt", (d18, i8, elements) => {
      select_default2(elements[i8]).attr("pointer-events", "stroke").attr("opacity", 1);
    });
  } else {
    selection2.attr("opacity", 1);
  }
  updateLinksPartial(selection2, config, scale);
}
function removeLinks2(selection2, config, duration) {
  smartTransition(selection2, duration / 2).attr("opacity", 0).remove();
}
function animateLinkFlow(selection2, config, scale, linkPathLengthMap) {
  const { linkFlow } = config;
  if (scale < ZoomLevel.Level2)
    return;
  selection2.each((d18, i8, elements) => {
    const element = elements[i8];
    const linkGroup = select_default2(element);
    const flowGroup$1 = linkGroup.select(`.${flowGroup}`);
    const linkPathElement = linkGroup.select(`.${link6}`).node();
    const cachedLinkPathLength = linkPathLengthMap.get(linkPathElement.getAttribute("d"));
    const pathLength = cachedLinkPathLength !== null && cachedLinkPathLength !== void 0 ? cachedLinkPathLength : linkPathElement.getTotalLength();
    if (!getBoolean(d18, linkFlow, d18._indexGlobal) || !pathLength)
      return;
    const t4 = d18._state.flowAnimDistanceRelative;
    const circles = flowGroup$1.selectAll(`.${flowCircle}`);
    circles.attr("transform", (index3) => {
      const tt = (t4 + +index3 / (circles.size() - 1)) % 1;
      const p13 = linkPathElement.getPointAtLength(tt * pathLength);
      return `translate(${p13.x}, ${p13.y})`;
    });
  });
}
function zoomLinks(selection2, config, scale) {
  selection2.classed(zoomOutLevel2, scale < ZoomLevel.Level2);
  selection2.select(`.${flowGroup}`).style("opacity", scale < ZoomLevel.Level2 ? 0 : 1);
  selection2.each((l7, i8, els) => {
    const r4 = getNumber(l7, config.linkFlowParticleSize, l7._indexGlobal) / Math.sqrt(scale);
    select_default2(els[i8]).selectAll(`.${flowCircle}`).attr("r", r4);
  });
  const linkElements = selection2.selectAll(`.${link6}`);
  linkElements.style("stroke-width", (d18) => getLinkStrokeWidth(d18, scale, config));
  const linkBandElements = selection2.selectAll(`.${linkBand}`);
  linkBandElements.style("stroke-width", (d18) => getLinkBandWidth(d18, scale, config));
}
var zoomLinksThrottled = throttle(zoomLinks, 500);

// node_modules/@unovis/ts/components/graph/modules/panel/helper.js
var DEFAULT_PADDING = 15;
var DEFAULT_LABEL_MARGIN = 16;
var OUTLINE_SELECTION_PADDING = 5;
var DEFAULT_SIDE_LABEL_SIZE = 25;
function getPanelPadding(padding) {
  var _a, _b, _c, _d;
  const isPaddingAnObject = isPlainObject(padding);
  return {
    left: (_a = isPaddingAnObject ? padding.left : padding) !== null && _a !== void 0 ? _a : DEFAULT_PADDING,
    right: (_b = isPaddingAnObject ? padding.right : padding) !== null && _b !== void 0 ? _b : DEFAULT_PADDING,
    top: (_c = isPaddingAnObject ? padding.top : padding) !== null && _c !== void 0 ? _c : DEFAULT_PADDING,
    bottom: (_d = isPaddingAnObject ? padding.bottom : padding) !== null && _d !== void 0 ? _d : DEFAULT_PADDING
  };
}
function initPanels(panelsConfig) {
  const panels2 = (panelsConfig !== null && panelsConfig !== void 0 ? panelsConfig : []).map((p13) => Object.assign(Object.assign({}, p13), { _padding: getPanelPadding(p13.padding) }));
  return panels2;
}
function setPanelForNodes(panels2, nodes4, config) {
  if (!panels2)
    return;
  nodes4.forEach((node4) => {
    const nodePanels = panels2.filter((panel2) => panel2.nodes && panel2.nodes.includes(node4._id));
    node4._panels = nodePanels;
  });
}
function setPanelBBox(panelConfig, panelNodes, nodeSizeAccessor, nodeDisabledAccessor) {
  const selection2 = panelNodes.select(`.${node3}`);
  if (selection2.empty())
    return;
  const labelApprxHeight = 40;
  const labelApprxWidth = 110;
  const labelMargin = 10;
  let box;
  selection2.each((d18, i8) => {
    const nodeSize = getNodeSize(d18, nodeSizeAccessor, i8);
    const w14 = Math.max(nodeSize, labelApprxWidth);
    const h17 = nodeSize + labelMargin + labelApprxHeight;
    const yShift = 10;
    const coords = {
      x1: getX2(d18) - w14 / 2,
      y1: getY2(d18) - h17 / 2 + yShift,
      x2: getX2(d18) + w14 / 2,
      y2: getY2(d18) + h17 / 2 + yShift
    };
    if (!box) {
      box = Object.assign({}, coords);
    } else {
      if (box.x1 > coords.x1)
        box.x1 = coords.x1;
      if (box.y1 > coords.y1)
        box.y1 = coords.y1;
      if (box.x2 < coords.x2)
        box.x2 = coords.x2;
      if (box.y2 < coords.y2)
        box.y2 = coords.y2;
    }
  });
  panelConfig._x = box.x1 - panelConfig._padding.left;
  panelConfig._y = box.y1 - panelConfig._padding.top;
  panelConfig._width = box.x2 - box.x1 + panelConfig._padding.left + panelConfig._padding.right;
  panelConfig._height = box.y2 - box.y1 + panelConfig._padding.top + panelConfig._padding.bottom;
  panelConfig._disabled = selection2.data().map((node4, i8) => getBoolean(node4, nodeDisabledAccessor, node4._index) || node4._state.greyout).every((d18) => d18);
}
function setPanelNumNodes(panelConfig, panelNodes) {
  panelConfig._numNodes = panelNodes.size();
}
function updatePanelBBoxSize(nodesSelection, panels2, config) {
  const { layoutNonConnectedAside } = config;
  if (!panels2)
    return;
  panels2.forEach((panelConfig) => {
    const panelNodes = nodesSelection.filter((node4) => {
      return (!layoutNonConnectedAside || node4._isConnected) && panelConfig.nodes.includes(node4._id);
    });
    setPanelBBox(panelConfig, panelNodes, config.nodeSize, config.nodeDisabled);
  });
}
function updatePanelNumNodes(nodesSelection, panels2, config) {
  const { layoutNonConnectedAside } = config;
  if (!panels2)
    return;
  panels2.forEach((panelConfig) => {
    const panelNodes = nodesSelection.filter((node4) => {
      return (!layoutNonConnectedAside || node4._isConnected) && panelConfig.nodes.includes(node4._id);
    });
    setPanelNumNodes(panelConfig, panelNodes);
  });
}
function getLabelTranslateTransform(panel2) {
  const x21 = panel2._width / 2;
  const dy = DEFAULT_LABEL_MARGIN + (panel2.dashedOutline ? OUTLINE_SELECTION_PADDING : 0);
  const y25 = panel2.labelPosition === Position.Bottom ? panel2._height + dy : -dy;
  return `translate(${x21}, ${y25})`;
}

// node_modules/@unovis/ts/components/graph/modules/panel/index.js
function createPanels(selection2) {
  selection2.attr("transform", (d18) => `translate(${d18._x}, ${d18._y})`).style("opacity", 0);
  selection2.append("rect").attr("class", panelSelection).attr("rx", 9).attr("ry", 9).attr("width", (d18) => d18._width).attr("height", (d18) => d18._height);
  selection2.append("rect").attr("class", panel).attr("rx", 7).attr("ry", 7).attr("width", (d18) => d18._width).attr("height", (d18) => d18._height);
  const panelLabel = selection2.append("g").attr("class", label9).attr("transform", getLabelTranslateTransform);
  panelLabel.append("rect").attr("class", background7);
  panelLabel.append("text").attr("class", labelText3).attr("dy", "0.32em");
  const sideIcon = selection2.append("g").attr("class", sideIconGroup).attr("transform", (d18, i8, elements) => {
    const dx = -OUTLINE_SELECTION_PADDING;
    const dy = -OUTLINE_SELECTION_PADDING;
    return `translate(${d18._width + dx}, ${-dy})`;
  });
  appendShape(sideIcon, (d18) => d18.sideIconShape, sideIconShape, customSideIcon);
  sideIcon.append("text").attr("class", sideIconSymbol);
}
function updatePanels(selection2, config, duration) {
  smartTransition(selection2, duration).attr("transform", (d18) => `translate(${d18._x}, ${d18._y})`).style("opacity", (d18) => d18._disabled ? 0.4 : 1);
  const panels2 = selection2.selectAll(`.${panel}`).data((d18) => [d18]);
  smartTransition(panels2, duration).attr("width", (d18) => d18._width).attr("height", (d18) => d18._height).style("stroke", (d18) => d18.borderColor).style("fill", (d18) => d18.fillColor).style("stroke-width", (d18) => d18.borderWidth);
  const panelSelection$1 = selection2.select(`.${panelSelection}`).classed(panelSelectionActive, (d18) => d18.dashedOutline);
  smartTransition(panelSelection$1, duration).attr("x", (d18) => -OUTLINE_SELECTION_PADDING).attr("y", (d18) => -OUTLINE_SELECTION_PADDING).attr("width", (d18) => d18._width + OUTLINE_SELECTION_PADDING * 2).attr("height", (d18) => d18._height + OUTLINE_SELECTION_PADDING * 2);
  const sideIcon = selection2.select(`.${sideIconGroup}`);
  sideIcon.select(`.${sideIconShape}`).call(updateShape, (d18) => d18.sideIconShape, (d18) => {
    var _a;
    return (_a = d18.sideIconShapeSize) !== null && _a !== void 0 ? _a : DEFAULT_SIDE_LABEL_SIZE;
  }).style("stroke", (d18) => d18.sideIconShapeStroke).style("cursor", (d18) => {
    var _a;
    return (_a = d18.sideIconCursor) !== null && _a !== void 0 ? _a : null;
  }).style("opacity", (d18) => d18.sideIconShape ? 1 : 0);
  sideIcon.select(`.${sideIconSymbol}`).html((d18) => d18.sideIconSymbol).attr("dy", 1).style("fill", (d18) => d18.sideIconSymbolColor).style("font-size", (d18) => {
    var _a, _b;
    return (_a = d18.sideIconFontSize) !== null && _a !== void 0 ? _a : ((_b = d18.sideIconShapeSize) !== null && _b !== void 0 ? _b : DEFAULT_SIDE_LABEL_SIZE) / 2.5;
  });
  smartTransition(sideIcon, duration).attr("transform", (d18) => {
    const dx = -OUTLINE_SELECTION_PADDING;
    const dy = -OUTLINE_SELECTION_PADDING;
    return `translate(${d18._width + dx}, ${-dy})`;
  });
  const panelLabel = selection2.select(`.${label9}`);
  panelLabel.select(`.${labelText3}`).text((d18) => trimString(d18.label, d18.labelTrimLength, d18.labelTrimMode));
  smartTransition(panelLabel, duration).attr("transform", getLabelTranslateTransform);
  panelLabel.on("mouseover", (event, d18) => {
    const label14 = select_default2(event.currentTarget);
    const labelContent = d18.label;
    label14.select("text").text(labelContent);
    setLabelRect(label14, labelContent, labelText3);
  }).on("mouseleave", (event, d18) => {
    const label14 = select_default2(event.currentTarget);
    const labelContent = trimString(d18.label, d18.labelTrimLength, d18.labelTrimMode);
    label14.select("text").text(labelContent);
    setLabelRect(label14, labelContent, labelText3);
  });
}
function removePanels(selection2, config, duration) {
  smartTransition(selection2, duration / 2).style("opacity", 0).remove();
}

// node_modules/@unovis/ts/components/graph/modules/layout-helpers.js
var DEFAULT_ELK_SETTINGS = {
  hierarchyHandling: "INCLUDE_CHILDREN",
  "nodePlacement.strategy": "NETWORK_SIMPLEX",
  "elk.padding": "[top=15.0,left=15.0,bottom=15.0,right=15.0]",
  "spacing.nodeNodeBetweenLayers": "50",
  "spacing.edgeNodeBetweenLayers": "50",
  "spacing.nodeNode": "10"
};
function positionNonConnectedNodes(nodes4, y25, spacing, width, xStart = 0) {
  nodes4.forEach((d18, i8) => {
    const x21 = spacing / 2 + i8 * spacing;
    const rowIdx = width ? Math.floor(x21 / width) : 0;
    d18.y = y25 + rowIdx * spacing || 0;
    d18.x = width ? x21 % width + xStart : x21 + xStart;
  });
}
function toElkHierarchy(d18, layoutOptions) {
  if (!(d18 instanceof Map))
    return d18;
  const hierarchyNode = Array.from(d18.entries()).map(([key, value2]) => {
    const children2 = toElkHierarchy(value2, layoutOptions);
    if (key) {
      const layoutOps = isPlainObject(layoutOptions) ? merge2(DEFAULT_ELK_SETTINGS, layoutOptions) : merge2(DEFAULT_ELK_SETTINGS, getValue(key, layoutOptions));
      return {
        id: key,
        layoutOptions: layoutOps,
        children: children2
      };
    } else {
      return children2;
    }
  }).flat();
  return hierarchyNode;
}
function adjustElkHierarchyCoordinates(node4) {
  var _a, _b;
  const parentX = node4.x;
  const parentY = node4.y;
  (_a = node4.edges) === null || _a === void 0 ? void 0 : _a.forEach((edge) => {
    var _a2, _b2;
    (_a2 = edge.sections) === null || _a2 === void 0 ? void 0 : _a2.forEach((section) => {
      var _a3;
      section.startPoint.x += parentX;
      section.startPoint.y += parentY;
      section.endPoint.x += parentX;
      section.endPoint.y += parentY;
      (_a3 = section.bendPoints) === null || _a3 === void 0 ? void 0 : _a3.forEach((bendPoint) => {
        bendPoint.x += parentX;
        bendPoint.y += parentY;
      });
    });
    (_b2 = edge.labels) === null || _b2 === void 0 ? void 0 : _b2.forEach((label14) => {
      label14.x += parentX;
      label14.y += parentY;
    });
  });
  (_b = node4.children) === null || _b === void 0 ? void 0 : _b.forEach((child) => {
    child.x += parentX;
    child.y += parentY;
    adjustElkHierarchyCoordinates(child);
  });
}

// node_modules/@unovis/ts/components/graph/modules/layout.js
function applyLayoutCircular(datamodel, config, width, height) {
  const { nonConnectedNodes, connectedNodes, nodes: nodes4 } = datamodel;
  const { layoutNonConnectedAside, nodeSize } = config;
  const activeWidth = width;
  const activeHeight = height;
  const layoutNodes = layoutNonConnectedAside ? connectedNodes : nodes4;
  const maxNodeSize = getMaxNodeSize(layoutNodes, nodeSize);
  const yRatio = activeHeight / maxNodeSize;
  const yScaling = yRatio < layoutNodes.length / 2 ? layoutNodes.length / 2 / yRatio : 1;
  const xRatio = activeWidth / maxNodeSize;
  const xScaling = xRatio < layoutNodes.length / 2 ? layoutNodes.length / 2 / xRatio : 1;
  const scaling = Math.max(xScaling, yScaling);
  layoutNodes.forEach((d18, i8) => {
    const rX = scaling * activeWidth / 2;
    const rY = scaling * activeHeight / 2;
    const angle = 2 * i8 * Math.PI / layoutNodes.length;
    d18.x = activeWidth / 2 + rX * Math.cos(angle);
    d18.y = activeHeight / 2 + rY * Math.sin(angle);
  });
  if (layoutNonConnectedAside) {
    const maxSize = getMaxNodeSize(nonConnectedNodes, nodeSize);
    const maxY = max(connectedNodes.map((d18) => d18.y));
    const maxX = max(connectedNodes.map((d18) => d18.x));
    const minX = min(connectedNodes.map((d18) => d18.x));
    const graphWidth = maxX - minX;
    positionNonConnectedNodes(nonConnectedNodes, maxY + maxSize * 3, maxSize * 2.25, Math.max(graphWidth, width), minX);
  }
}
function applyLayoutParallel(datamodel, config, width, height, orientation) {
  var _a, _b, _c, _d;
  const { nonConnectedNodes, connectedNodes, nodes: nodes4 } = datamodel;
  const { layoutNonConnectedAside, layoutGroupOrder, layoutParallelSortConnectionsByGroup, layoutParallelNodesPerColumn, layoutParallelSubGroupsPerRow, nodeSize, layoutNodeGroup, layoutParallelNodeSubGroup, layoutParallelGroupSpacing, layoutParallelNodeSpacing, layoutParallelSubGroupSpacing } = config;
  const activeWidth = width - configuredNodeSize(nodeSize);
  const activeHeight = height - configuredNodeSize(nodeSize) - (nonConnectedNodes.length ? configuredNodeSize(nodeSize) * 5 : 0);
  const layoutNodes = layoutNonConnectedAside ? connectedNodes : nodes4;
  const groupNames = unique(layoutNodes.map((d18) => getString(d18, layoutNodeGroup, d18._index)));
  const groupNamesSorted = sortBy(groupNames, (d18) => layoutGroupOrder.indexOf(d18));
  const groups2 = groupNamesSorted.map((groupName) => {
    const groupNodes = layoutNodes.filter((d18) => getString(d18, layoutNodeGroup, d18._index) === groupName);
    const groupedBySubgroup = groupBy(groupNodes, (d18) => getString(d18, layoutParallelNodeSubGroup, d18._index));
    const subgroups = Object.keys(groupedBySubgroup).map((name2) => ({
      nodes: groupedBySubgroup[name2],
      name: name2
    }));
    return {
      name: groupName,
      nodes: groupNodes,
      subgroups
    };
  });
  const group3 = groups2.find((g15) => g15.name === layoutParallelSortConnectionsByGroup);
  if (group3) {
    const sortMap = {};
    let idx = 0;
    group3.subgroups.forEach((subgroup) => {
      subgroup.nodes.forEach((node4) => {
        node4.links.forEach((link7) => {
          const linkTargetId = link7 === null || link7 === void 0 ? void 0 : link7.target._id;
          sortMap[linkTargetId] = idx;
          idx = idx + 1;
        });
      });
    });
    without(groups2, group3).forEach((g15) => {
      g15.subgroups.forEach((subgroup) => {
        subgroup.nodes.sort((a7, b25) => {
          return (sortMap[a7._id] || 0) - (sortMap[b25._id] || 0);
        });
      });
    });
  }
  const maxN = max(groups2, (d18) => {
    var _a2;
    return (_a2 = d18.nodes) === null || _a2 === void 0 ? void 0 : _a2.length;
  });
  const labelApprxHeight = 40;
  const labelMargin = 10;
  const subgroupSpacing = layoutParallelSubGroupSpacing !== null && layoutParallelSubGroupSpacing !== void 0 ? layoutParallelSubGroupSpacing : 0;
  const maxNodeSize = getMaxNodeSize(layoutNodes, nodeSize);
  const configuredNodeSpacing = isArray(layoutParallelNodeSpacing) ? layoutParallelNodeSpacing : [layoutParallelNodeSpacing, layoutParallelNodeSpacing];
  if (orientation === "horizontal") {
    const minHorizontalSpacing = 2 * maxNodeSize + labelMargin;
    const maxHorizontalSpacing = 3.5 * maxNodeSize + labelMargin;
    const horizontalNodeSpacing = (_a = configuredNodeSpacing[0]) !== null && _a !== void 0 ? _a : clamp(activeWidth / (maxN - 1), minHorizontalSpacing, maxHorizontalSpacing);
    const maxVerticalStep = maxNodeSize * 4 + labelApprxHeight;
    const minVerticalStep = maxNodeSize * 1.5 + labelApprxHeight;
    const groupSpacing = layoutParallelGroupSpacing !== null && layoutParallelGroupSpacing !== void 0 ? layoutParallelGroupSpacing : clamp(activeHeight / (groups2.length - 1), minVerticalStep, maxVerticalStep);
    const verticalNodeSpacing = (_b = configuredNodeSpacing[1]) !== null && _b !== void 0 ? _b : maxNodeSize + labelApprxHeight + labelMargin;
    let y06 = groups2.length < 2 ? height / 2 : 0;
    groups2.forEach((group4) => {
      let x06 = 0;
      let dy = 0;
      let subgroupMaxWidth = 0;
      let groupWidth = 0;
      let groupHeight = 0;
      let k17 = 0;
      group4.subgroups.forEach((subgroup) => {
        const subgroupRows = Math.ceil(subgroup.nodes.length / layoutParallelNodesPerColumn);
        let n = 0;
        let x21 = x06;
        let y25 = y06 + dy;
        subgroup.nodes.forEach((d18) => {
          x21 = x21 + horizontalNodeSpacing;
          d18.x = x21;
          d18.y = y25;
          groupWidth = Math.max(groupWidth, x21);
          n = n + 1;
          if (n >= layoutParallelNodesPerColumn) {
            n = 0;
            y25 += verticalNodeSpacing;
            x21 = x06;
          }
        });
        const subgroupWidth = Math.min(subgroup.nodes.length, layoutParallelNodesPerColumn) * horizontalNodeSpacing;
        const subgroupHeight = subgroupRows * verticalNodeSpacing;
        subgroupMaxWidth = Math.max(subgroupMaxWidth, subgroupWidth);
        dy = dy + subgroupHeight + subgroupSpacing;
        k17 = k17 + 1;
        if (k17 >= layoutParallelSubGroupsPerRow) {
          k17 = 0;
          dy = 0;
          x06 = x06 + subgroupMaxWidth + subgroupSpacing;
          subgroupMaxWidth = 0;
        }
        groupHeight = Math.max(groupHeight, y25);
      });
      group4.subgroups.forEach((subgroup) => {
        subgroup.nodes.forEach((d18) => {
          d18.x -= groupWidth / 2;
        });
      });
      groupWidth = 0;
      y06 = groupHeight + groupSpacing;
    });
  } else {
    const groupSpacingMin = 6 * maxNodeSize + labelMargin;
    const groupSpacingMax = 10 * maxNodeSize + labelMargin;
    const groupSpacing = layoutParallelGroupSpacing !== null && layoutParallelGroupSpacing !== void 0 ? layoutParallelGroupSpacing : clamp(activeWidth / (maxN - 1), groupSpacingMin, groupSpacingMax);
    const minVerticalSpacing = maxNodeSize * 2 + labelApprxHeight;
    const maxVerticalSpacing = maxNodeSize * 1.5 + labelApprxHeight;
    const verticalNodeSpacing = (_c = configuredNodeSpacing[1]) !== null && _c !== void 0 ? _c : clamp(activeHeight / (groups2.length - 1), maxVerticalSpacing, minVerticalSpacing);
    const horizontalNodeSpacing = (_d = configuredNodeSpacing[0]) !== null && _d !== void 0 ? _d : maxNodeSize * 2;
    let x06 = groups2.length < 2 ? width / 2 : 0;
    groups2.forEach((group4) => {
      let y06 = 0;
      let dx = 0;
      let subgroupMaxHeight = 0;
      let groupWidth = 0;
      let groupHeight = 0;
      let k17 = 0;
      group4.subgroups.forEach((subgroup) => {
        const subgroupColumns = Math.ceil(subgroup.nodes.length / layoutParallelNodesPerColumn);
        let n = 0;
        let y25 = y06;
        let x21 = x06 + dx;
        subgroup.nodes.forEach((d18) => {
          y25 = y25 + verticalNodeSpacing;
          d18.x = x21;
          d18.y = y25;
          groupHeight = Math.max(groupHeight, y25);
          n = n + 1;
          if (n >= layoutParallelNodesPerColumn) {
            n = 0;
            x21 += horizontalNodeSpacing;
            y25 = y06;
          }
        });
        const subgroupHeight = Math.min(subgroup.nodes.length, layoutParallelNodesPerColumn) * verticalNodeSpacing;
        const subgroupWidth = subgroupColumns * horizontalNodeSpacing;
        subgroupMaxHeight = Math.max(subgroupMaxHeight, subgroupHeight);
        dx = dx + subgroupWidth + subgroupSpacing;
        k17 = k17 + 1;
        if (k17 >= layoutParallelSubGroupsPerRow) {
          k17 = 0;
          dx = 0;
          y06 = y06 + subgroupMaxHeight + subgroupSpacing;
          subgroupMaxHeight = 0;
        }
        groupWidth = Math.max(groupWidth, x21);
      });
      group4.subgroups.forEach((subgroup) => {
        subgroup.nodes.forEach((d18) => {
          d18.y -= groupHeight / 2;
        });
      });
      groupHeight = 0;
      x06 = groupWidth + groupSpacing;
    });
  }
  if (layoutNonConnectedAside) {
    const maxSize = getMaxNodeSize(nonConnectedNodes, nodeSize);
    const maxY = max(connectedNodes.map((d18) => d18.y)) || 0;
    const maxX = max(connectedNodes.map((d18) => d18.x)) || 0;
    const minX = min(connectedNodes.map((d18) => d18.x)) || 0;
    const graphWidth = maxX - minX || width;
    positionNonConnectedNodes(nonConnectedNodes, maxY + maxSize * 3, maxSize * 2.25, Math.max(graphWidth, width));
  }
}
function applyLayoutDagre(datamodel, config, width) {
  return __awaiter(this, void 0, void 0, function* () {
    const { nonConnectedNodes, connectedNodes, nodes: nodes4, links: links5 } = datamodel;
    const { nodeSize, layoutNonConnectedAside, dagreLayoutSettings, nodeStrokeWidth, nodeLabel } = config;
    const { Graph: Graph2 } = yield import("./dist-ZOAYXENX.js");
    const { layout } = yield import("./dist-4ROF6NWW.js");
    const dagreGraph = new Graph2();
    dagreGraph.setGraph(dagreLayoutSettings);
    dagreGraph.setDefaultEdgeLabel(() => ({}));
    const labelApprxHeight = 40;
    const nds = layoutNonConnectedAside ? connectedNodes : nodes4;
    nds.forEach((node4) => {
      dagreGraph.setNode(`${node4._index}`, {
        label: getString(node4, nodeLabel, node4._index),
        width: getNumber(node4, nodeSize, node4._index) * 1.5 + getNumber(node4, nodeStrokeWidth, node4._index),
        height: labelApprxHeight + getNumber(node4, nodeSize, node4._index) * 1.5,
        originalNode: node4
      });
    });
    links5.forEach((link7) => {
      dagreGraph.setEdge(`${link7.source._index}`, `${link7.target._index}`);
    });
    layout(dagreGraph);
    dagreGraph.nodes().forEach((d18) => {
      const node4 = dagreGraph.node(d18);
      node4.originalNode.x = node4.x;
      node4.originalNode.y = node4.y;
    });
    if (layoutNonConnectedAside) {
      const maxNodeSize = getMaxNodeSize(nonConnectedNodes, nodeSize);
      const maxY = max(connectedNodes.map((d18) => d18.y));
      const maxX = max(connectedNodes.map((d18) => d18.x));
      const minX = min(connectedNodes.map((d18) => d18.x));
      const graphWidth = maxX - minX;
      positionNonConnectedNodes(nonConnectedNodes, maxY + maxNodeSize * 3, maxNodeSize * 2.25, Math.max(graphWidth, width), 0);
    }
  });
}
function applyLayoutConcentric(datamodel, config, width, height) {
  var _a, _b;
  const { nonConnectedNodes, connectedNodes, nodes: nodes4 } = datamodel;
  const { layoutNonConnectedAside, layoutGroupOrder, nodeSize, layoutNodeGroup } = config;
  const layoutNodes = layoutNonConnectedAside ? connectedNodes : nodes4;
  const groupNames = unique(layoutNodes.map((d18) => getString(d18, layoutNodeGroup, d18._index)));
  const groupNamesSorted = sortBy(groupNames, (d18) => layoutGroupOrder.indexOf(d18));
  const groups2 = groupNamesSorted.map((groupName) => ({
    name: groupName,
    nodes: layoutNodes.filter((d18) => getString(d18, layoutNodeGroup, d18._index) === groupName)
  }));
  let r4 = 2 * getAverageNodeSize((_b = (_a = groups2[0]) === null || _a === void 0 ? void 0 : _a.nodes) !== null && _b !== void 0 ? _b : [], nodeSize);
  const widthToHeightRatio = width / height;
  groups2.forEach((group3, i8) => {
    const avgNodeSize = getAverageNodeSize(group3.nodes, nodeSize);
    const requiredRadius = 1.1 * avgNodeSize * group3.nodes.length / Math.PI;
    if (r4 < requiredRadius)
      r4 = requiredRadius;
    group3.nodes.forEach((node4, j6) => {
      if (i8 === 0 && group3.nodes.length === 1) {
        node4.x = width / 2;
        node4.y = height / 2;
      } else {
        let dAngle = 0;
        if (i8 === 0 && group3.nodes.length === 3)
          dAngle = Math.PI / 6;
        if (i8 === 0 && group3.nodes.length === 4)
          dAngle = Math.PI / 4;
        const angle = 2 * j6 * Math.PI / group3.nodes.length + i8 * Math.PI / 12 + dAngle;
        node4.x = width / 2 + r4 * Math.cos(angle) * widthToHeightRatio;
        node4.y = height / 2 + r4 * Math.sin(angle);
      }
    });
    const groupSpacing = avgNodeSize * 3;
    r4 += groupSpacing;
  });
  if (layoutNonConnectedAside) {
    const maxSize = getMaxNodeSize(nonConnectedNodes, nodeSize);
    const maxY = max(connectedNodes.map((d18) => d18.y));
    const maxX = max(connectedNodes.map((d18) => d18.x));
    const minX = min(connectedNodes.map((d18) => d18.x));
    const graphWidth = maxX - minX;
    positionNonConnectedNodes(nonConnectedNodes, maxY + maxSize * 3, maxSize * 2.25, graphWidth, minX);
  }
}
function applyLayoutForce(datamodel, config, width) {
  var _a;
  return __awaiter(this, void 0, void 0, function* () {
    const { layoutNonConnectedAside, forceLayoutSettings, nodeSize } = config;
    const { forceSimulation, forceLink, forceManyBody, forceX, forceY, forceCollide } = yield import("./src-2B6UQUK6.js");
    const { nonConnectedNodes, connectedNodes, nodes: nodes4, links: links5 } = datamodel;
    if (forceLayoutSettings.fixNodePositionAfterSimulation) {
      nodes4.forEach((d18) => {
        d18.fx = isNil(d18._state.fx) ? void 0 : d18._state.fx;
        d18.fy = isNil(d18._state.fy) ? void 0 : d18._state.fy;
      });
    } else {
      nodes4.forEach((d18) => {
        delete d18._state.fx;
        delete d18._state.fy;
      });
    }
    const simulation = forceSimulation(layoutNonConnectedAside ? connectedNodes : nodes4).force("link", forceLink(links5).id((d18) => String(d18._id)).distance((l7, i8) => isFunction(forceLayoutSettings.linkDistance) ? forceLayoutSettings.linkDistance(l7, i8) : forceLayoutSettings.linkDistance).strength((l7, i8) => isFunction(forceLayoutSettings.linkStrength) ? forceLayoutSettings.linkStrength(l7, i8) : forceLayoutSettings.linkStrength)).force("charge", forceManyBody().strength((d18, i8) => {
      if (isFunction(forceLayoutSettings.charge)) {
        return forceLayoutSettings.charge(d18, i8);
      } else {
        const linkCount = links5.reduce((count3, l7) => count3 + Number(l7.source === d18 || l7.target === d18), 0);
        return forceLayoutSettings.charge * Math.sqrt(linkCount);
      }
    })).force("x", forceX().strength(forceLayoutSettings.forceXStrength)).force("y", forceY().strength(forceLayoutSettings.forceYStrength)).force("collide", forceCollide().radius((d18, i8) => getNodeSize(d18, nodeSize, i8)).iterations(1)).stop();
    const numIterations = (_a = forceLayoutSettings.numIterations) !== null && _a !== void 0 ? _a : Math.ceil(Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay()));
    for (let i8 = 0, n = numIterations; i8 < n; ++i8) {
      simulation.tick();
    }
    if (forceLayoutSettings.fixNodePositionAfterSimulation) {
      nodes4.forEach((d18) => {
        delete d18.fx;
        delete d18.fy;
        d18._state.fx = d18.x;
        d18._state.fy = d18.y;
      });
    }
    if (layoutNonConnectedAside) {
      const maxSize = getMaxNodeSize(nonConnectedNodes, nodeSize);
      const maxY = max(connectedNodes.map((d18) => d18.y));
      const maxX = max(connectedNodes.map((d18) => d18.x));
      const minX = min(connectedNodes.map((d18) => d18.x));
      const graphWidth = maxX - minX;
      positionNonConnectedNodes(nonConnectedNodes, maxY + maxSize * 6, maxSize * 2.25, Math.max(graphWidth, width), minX);
    }
  });
}
function applyELKLayout(datamodel, config, width) {
  return __awaiter(this, void 0, void 0, function* () {
    const ELK = (yield import("./elk.bundled-C7IF4DNY.js")).default;
    const elk = new ELK();
    const labelApprxHeight = 30;
    const nodes4 = datamodel.nodes.map((n, i8) => Object.assign(Object.assign(Object.assign({}, n), { id: n._id, width: getNumber(n, config.nodeSize, n._index) + getNumber(n, config.nodeStrokeWidth, n._index), height: getNumber(n, config.nodeSize, n._index) + labelApprxHeight }), config.layoutElkGetNodeShape ? config.layoutElkGetNodeShape(n, i8) : {}));
    let elkNodes;
    if (config.layoutElkNodeGroups) {
      const groupingFunctions = config.layoutElkNodeGroups.map((accessor) => (d18) => getString(d18, accessor, d18._index));
      const grouped = group(nodes4, ...groupingFunctions);
      elkNodes = toElkHierarchy(grouped, config.layoutElkSettings);
    } else {
      elkNodes = nodes4;
    }
    const rootNodeId = "root";
    const elkGraph = {
      id: rootNodeId,
      layoutOptions: merge2(DEFAULT_ELK_SETTINGS, getValue(rootNodeId, config.layoutElkSettings)),
      children: elkNodes,
      edges: datamodel.links.map((l7) => ({
        id: l7._id,
        sources: [l7.source._id],
        targets: [l7.target._id]
      }))
    };
    const layout = yield elk.layout(elkGraph);
    adjustElkHierarchyCoordinates(layout);
    nodes4.forEach((node4, i8) => {
      const found = datamodel.nodes.find((n) => n._id === node4.id);
      if (!found)
        return;
      found.x = node4.x + node4.width / 2;
      found.y = node4.y + node4.height / 2;
    });
    if (config.layoutNonConnectedAside) {
      const maxSize = getMaxNodeSize(datamodel.nonConnectedNodes, config.nodeSize);
      const maxY = max(datamodel.connectedNodes.map((d18) => d18.y)) || 0;
      const maxX = max(datamodel.connectedNodes.map((d18) => d18.x)) || 0;
      const minX = min(datamodel.connectedNodes.map((d18) => d18.x)) || 0;
      const graphWidth = maxX - minX || width;
      positionNonConnectedNodes(datamodel.nonConnectedNodes, maxY + maxSize * 3, maxSize * 2.25, Math.max(graphWidth, width));
    }
  });
}

// node_modules/@unovis/ts/components/graph/index.js
var Graph = class _Graph extends ComponentCore {
  constructor(config) {
    super();
    this._defaultConfig = GraphDefaultConfig;
    this.config = this._defaultConfig;
    this.datamodel = new GraphDataModel();
    this._isFirstRender = true;
    this._shouldRecalculateLayout = false;
    this._shouldSetPanels = false;
    this._isAutoFitDisabled = false;
    this._isDragging = false;
    this._linkPathLengthMap = /* @__PURE__ */ new Map();
    this._linkFlowFrameElapsed = 0;
    this.events = {
      [_Graph.selectors.background]: {
        click: this._onBackgroundClick.bind(this)
      },
      [_Graph.selectors.node]: {
        click: this._onNodeClick.bind(this),
        mouseover: this._onNodeMouseOver.bind(this),
        mouseout: this._onNodeMouseOut.bind(this)
      },
      [_Graph.selectors.link]: {
        click: this._onLinkClick.bind(this),
        mouseover: this._onLinkMouseOver.bind(this),
        mouseout: this._onLinkMouseOut.bind(this)
      }
    };
    if (config)
      this.setConfig(config);
    this._backgroundRect = this.g.append("rect").attr("class", background6);
    this._graphGroup = this.g.append("g").attr("class", graphGroup);
    this._brush = this.g.append("g").attr("class", brush3);
    this._zoomBehavior = zoom_default2().scaleExtent(this.config.zoomScaleExtent).on("zoom", (e3) => this._onZoom(e3.transform, e3)).on("start", (e3) => this._onZoomStart(e3.transform, e3)).on("end", (e3) => this._onZoomEnd(e3.transform, e3));
    this._brushBehavior = brush_default().on("start brush end", this._onBrush.bind(this)).filter((event) => event.shiftKey).keyModifiers(false);
    this._panelsGroup = this._graphGroup.append("g").attr("class", panels);
    this._linksGroup = this._graphGroup.append("g").attr("class", links4);
    this._nodesGroup = this._graphGroup.append("g").attr("class", nodes3);
    this._defs = this._graphGroup.append("defs");
    this._getLinkArrowDefId = this._getLinkArrowDefId.bind(this);
  }
  get selectedNode() {
    var _a;
    return (_a = this._selectedNodes) === null || _a === void 0 ? void 0 : _a[0];
  }
  get selectedNodes() {
    return this._selectedNodes;
  }
  get selectedLink() {
    return this._selectedLink;
  }
  setData(data) {
    const { config } = this;
    if (!config.shouldDataUpdate(this.datamodel.data, data, this.datamodel))
      return;
    this.datamodel.nodeSort = config.nodeSort;
    this.datamodel.data = data;
    this._shouldRecalculateLayout = true;
    if (config.layoutAutofit)
      this._shouldFitLayout = true;
    this._shouldSetPanels = true;
    this._addSVGDefs();
  }
  setConfig(config) {
    super.setConfig(config);
    const hasLayoutConfigurationChanged = this._shouldLayoutRecalculate();
    this._shouldRecalculateLayout = this._shouldRecalculateLayout || hasLayoutConfigurationChanged;
    this._shouldFitLayout = this._shouldFitLayout || hasLayoutConfigurationChanged;
    if (this._shouldFitLayout)
      this._isAutoFitDisabled = false;
    this._shouldSetPanels = true;
  }
  get bleed() {
    const padding = this.config.fitViewPadding;
    return isNumber(padding) ? { top: padding, bottom: padding, left: padding, right: padding } : padding;
  }
  _render(customDuration) {
    const { config: { disableBrush, disableZoom, duration, layoutAutofit, zoomEventFilter }, datamodel } = this;
    if (!datamodel.nodes && !datamodel.links)
      return;
    const animDuration = isNumber(customDuration) ? customDuration : duration;
    this._backgroundRect.attr("width", this._width).attr("height", this._height).attr("opacity", 0);
    if ((this._prevWidth !== this._width || this._prevHeight !== this._height) && layoutAutofit) {
      this._shouldFitLayout = true;
      this._prevWidth = this._width;
      this._prevHeight = this._height;
    }
    if (!disableBrush) {
      this._brushBehavior.extent([[0, 0], [this._width, this._height]]);
      this._brush.call(this._brushBehavior);
      select_default2(window).on("keydown.unovis-graph", (e3) => e3.key === "Shift" && this._activateBrush()).on("keyup.unovis-graph", (e3) => e3.key === "Shift" && this._clearBrush());
      this._zoomBehavior.filter((event) => !event.shiftKey);
    } else {
      this._brush.on(".brush", null);
      select_default2(window).on("keydown.unovis-graph", null).on("keyup.unovis-graph", null);
      if (this._brush.classed("active"))
        this._clearBrush();
    }
    if (this._shouldRecalculateLayout || !this._layoutCalculationPromise) {
      this._layoutCalculationPromise = this._calculateLayout();
      this._layoutCalculationPromise.then(() => {
        var _a, _b;
        (_b = (_a = this.config).onLayoutCalculated) === null || _b === void 0 ? void 0 : _b.call(_a, datamodel.nodes, datamodel.links);
      });
    }
    this._zoomBehavior.filter(isFunction(zoomEventFilter) ? zoomEventFilter : (e3) => (!e3.ctrlKey || e3.type === "wheel") && !e3.button && !e3.shiftKey);
    this._layoutCalculationPromise.then(() => {
      var _a, _b, _c;
      if (this.isDestroyed())
        return;
      this._initPanelsData();
      if (this._isFirstRender) {
        this._fit();
        this._shouldFitLayout = false;
      } else if (this._shouldFitLayout && !this._isAutoFitDisabled) {
        this._fit(duration);
        this._shouldFitLayout = false;
      }
      this._resetSelectionGreyoutState();
      if (this.config.selectedNodeId || this.config.selectedNodeIds) {
        const selectedIds = (_a = this.config.selectedNodeIds) !== null && _a !== void 0 ? _a : [this.config.selectedNodeId];
        const selectedNodes = selectedIds.map((id2) => datamodel.getNodeById(id2));
        this._setNodeSelectionState(selectedNodes);
      }
      if (this.config.selectedLinkId) {
        const selectedLink = datamodel.links.find((link7) => link7.id === this.config.selectedLinkId);
        this._setLinkSelectionState(selectedLink);
      }
      this._drawNodes(animDuration);
      this._drawLinks(animDuration);
      if (!this._timer) {
        const refreshRateMs = 35;
        this._timer = interval_default(this._onLinkFlowTimerFrame.bind(this), refreshRateMs);
      }
      if (disableZoom)
        this.g.on(".zoom", null);
      else
        this.g.call(this._zoomBehavior).on("dblclick.zoom", null);
      this._setUpComponentEventsThrottled();
      this._setCustomAttributesThrottled();
      (_c = (_b = this.config).onRenderComplete) === null || _c === void 0 ? void 0 : _c.call(_b, this.g, datamodel.nodes, datamodel.links, this.config, animDuration, this._scale, this._containerWidth, this._containerHeight);
      this._isFirstRender = false;
    });
  }
  _drawNodes(duration) {
    const { config, datamodel } = this;
    const nodes4 = datamodel.nodes;
    const nodeGroups = this._nodesGroup.selectAll(`.${gNode}:not(.${gNodeExit})`).data(nodes4, (d18) => String(d18._id));
    const nodeGroupsEnter = nodeGroups.enter().append("g").attr("class", gNode).call(createNodes3, config, duration, this._scale);
    const nodeGroupsMerged = nodeGroups.merge(nodeGroupsEnter);
    const nodeUpdateSelection = updateNodes3(nodeGroupsMerged, config, duration, this._scale);
    this._drawPanels(nodeUpdateSelection, duration);
    const nodesGroupExit = nodeGroups.exit();
    nodesGroupExit.classed(gNodeExit, true).call(removeNodes3, config, duration, this._scale);
    const thisRef = this;
    if (!config.disableDrag) {
      const dragBehaviour = drag_default().on("start drag end", function(event, d18) {
        thisRef._handleDrag(d18, event, select_default2(this));
      });
      nodeGroupsMerged.call(dragBehaviour);
    } else {
      nodeGroupsMerged.on(".drag", null);
    }
  }
  _drawLinks(duration) {
    const { config, datamodel: { links: links5 } } = this;
    const linkGroups = this._linksGroup.selectAll(`.${gLink}:not(.${gLinkExit}`).data(links5, (d18) => String(d18._id));
    const linkGroupsEnter = linkGroups.enter().append("g").attr("class", gLink).call(createLinks2, config, duration);
    const linkGroupsMerged = linkGroups.merge(linkGroupsEnter);
    linkGroupsMerged.call(updateLinks2, config, duration, this._scale, this._getLinkArrowDefId, this._linkPathLengthMap);
    const linkGroupsExit = linkGroups.exit();
    linkGroupsExit.attr("class", gLinkExit).call(removeLinks2, config, duration);
  }
  _drawPanels(nodeUpdateSelection, duration) {
    var _a;
    const { config } = this;
    smartTransition(this._panelsGroup, duration / 2).style("opacity", ((_a = config.panels) === null || _a === void 0 ? void 0 : _a.length) ? 1 : 0);
    if (!this._panels)
      return;
    const selection2 = nodeUpdateSelection.duration ? nodeUpdateSelection.selection() : nodeUpdateSelection;
    updatePanelNumNodes(selection2, this._panels, config);
    updatePanelBBoxSize(selection2, this._panels, config);
    const panelData = this._panels.filter((p13) => p13._numNodes);
    const panelGroup = this._panelsGroup.selectAll(`.${gPanel}`).data(panelData, (p13) => p13.label);
    const panelGroupExit = panelGroup.exit();
    panelGroupExit.call(removePanels, config, duration);
    const panelGroupEnter = panelGroup.enter().append("g").attr("class", gPanel).call(createPanels, selection2);
    const panelGroupMerged = panelGroup.merge(panelGroupEnter);
    this._updatePanels(panelGroupMerged, duration);
  }
  _updatePanels(panelToUpdate, duration) {
    const { config } = this;
    if (!this._panels)
      return;
    panelToUpdate.call(updatePanels, config, duration);
  }
  _calculateLayout() {
    return __awaiter(this, void 0, void 0, function* () {
      const { config, datamodel } = this;
      if (this._currentLayoutType !== config.layoutType) {
        for (const node4 of datamodel.nodes) {
          delete node4._state.fx;
          delete node4._state.fy;
        }
      }
      switch (config.layoutType) {
        case GraphLayoutType.Precalculated:
          break;
        case GraphLayoutType.Parallel:
          applyLayoutParallel(datamodel, config, this._width, this._height);
          break;
        case GraphLayoutType.ParallelHorizontal:
          applyLayoutParallel(datamodel, config, this._width, this._height, "horizontal");
          break;
        case GraphLayoutType.Dagre:
          yield applyLayoutDagre(datamodel, config, this._width);
          break;
        case GraphLayoutType.Force:
          yield applyLayoutForce(datamodel, config, this._width);
          break;
        case GraphLayoutType.Concentric:
          applyLayoutConcentric(datamodel, config, this._width, this._height);
          break;
        case GraphLayoutType.Elk:
          yield applyELKLayout(datamodel, config, this._width);
          break;
        case GraphLayoutType.Circular:
        default:
          applyLayoutCircular(datamodel, config, this._width, this._height);
          break;
      }
      this._initPanelsData();
      this._shouldRecalculateLayout = false;
      this._currentLayoutType = config.layoutType;
    });
  }
  _initPanelsData() {
    const { config, datamodel } = this;
    if (this._shouldSetPanels) {
      this._panels = initPanels(config.panels);
      setPanelForNodes(this._panels, datamodel.nodes, this.config);
      this._shouldSetPanels = false;
    }
  }
  _fit(duration = 0, nodeIds, alignment = this.config.fitViewAlign) {
    const { datamodel: { nodes: nodes4 } } = this;
    const fitViewNodes = (nodeIds === null || nodeIds === void 0 ? void 0 : nodeIds.length) ? nodes4.filter((n) => nodeIds.includes(n.id)) : nodes4;
    const transform2 = this._getTransform(fitViewNodes, alignment);
    smartTransition(this.g, duration).call(this._zoomBehavior.transform, transform2);
    this._onZoom(transform2);
  }
  _getTransform(nodes4, alignment) {
    const { nodeSize, zoomScaleExtent } = this.config;
    const { left: left3, top: top2, right: right3, bottom: bottom2 } = this.bleed;
    const maxNodeSize = getMaxNodeSize(nodes4, nodeSize);
    const w14 = this._width;
    const h17 = this._height;
    const xExtent = [
      min(nodes4, (d18) => getX2(d18) - maxNodeSize / 2 - (max((d18._panels || []).map((p13) => p13._padding.left)) || 0)),
      max(nodes4, (d18) => getX2(d18) + maxNodeSize / 2 + (max((d18._panels || []).map((p13) => p13._padding.right)) || 0))
    ];
    const yExtent = [
      min(nodes4, (d18) => getY2(d18) - maxNodeSize / 2 - (max((d18._panels || []).map((p13) => p13._padding.top)) || 0)),
      max(nodes4, (d18) => getY2(d18) + maxNodeSize / 2 + (max((d18._panels || []).map((p13) => p13._padding.bottom)) || 0))
    ];
    if (xExtent.some((item4) => item4 === void 0) || yExtent.some((item4) => item4 === void 0)) {
      console.warn("Unovis | Graph: Some of the node coordinates are undefined. This can happen if you try to fit the graph before the layout has been calculated.");
      return identity4;
    }
    const xScale = w14 / (xExtent[1] - xExtent[0] + (left3 || 0) + (right3 || 0));
    const yScale = h17 / (yExtent[1] - yExtent[0] + (top2 || 0) + (bottom2 || 0));
    const clampedScale = clamp(min([xScale, yScale]), zoomScaleExtent[0], zoomScaleExtent[1]);
    let translateX2;
    let translateY2;
    switch (alignment) {
      case GraphFitViewAlignment.Left:
        translateX2 = left3 - xExtent[0] * clampedScale;
        translateY2 = this._height / 2 - (yExtent[0] + (yExtent[1] - yExtent[0]) / 2) * clampedScale;
        break;
      case GraphFitViewAlignment.Right:
        translateX2 = this._width - (xExtent[1] - xExtent[0]) * clampedScale - right3;
        translateY2 = this._height / 2 - (yExtent[0] + (yExtent[1] - yExtent[0]) / 2) * clampedScale;
        break;
      case GraphFitViewAlignment.Top:
        translateX2 = this._width / 2 - (xExtent[0] + (xExtent[1] - xExtent[0]) / 2) * clampedScale;
        translateY2 = top2 - yExtent[0] * clampedScale;
        break;
      case GraphFitViewAlignment.Bottom:
        translateX2 = this._width / 2 - (xExtent[0] + (xExtent[1] - xExtent[0]) / 2) * clampedScale;
        translateY2 = this._height - (yExtent[1] - yExtent[0]) * clampedScale - bottom2;
        break;
      case GraphFitViewAlignment.Center:
      default:
        translateX2 = this._width / 2 - (xExtent[0] + (xExtent[1] - xExtent[0]) / 2) * clampedScale;
        translateY2 = this._height / 2 - (yExtent[0] + (yExtent[1] - yExtent[0]) / 2) * clampedScale;
    }
    const transform2 = identity4.translate(translateX2, translateY2).scale(clampedScale);
    return transform2;
  }
  _setNodeSelectionState(nodesToSelect) {
    const { config, datamodel } = this;
    for (const n of datamodel.nodes) {
      n._state.selected = false;
      if (config.nodeSelectionHighlightMode !== GraphNodeSelectionHighlightMode.None) {
        n._state.greyout = true;
      }
    }
    for (const l7 of datamodel.links) {
      l7._state.selected = false;
      if (config.nodeSelectionHighlightMode !== GraphNodeSelectionHighlightMode.None) {
        l7._state.greyout = true;
      }
    }
    this._selectedNodes = nodesToSelect.filter((n) => {
      const doesNodeExist = Boolean(n);
      if (!doesNodeExist)
        console.warn("Unovis | Graph: Select Node: Not found");
      return doesNodeExist;
    });
    for (const n of this._selectedNodes) {
      n._state.selected = true;
      n._state.greyout = false;
    }
    if (config.nodeSelectionHighlightMode === GraphNodeSelectionHighlightMode.GreyoutNonConnected) {
      const connectedLinks = datamodel.links.filter((l7) => this._selectedNodes.includes(l7.source) || this._selectedNodes.includes(l7.target));
      connectedLinks.forEach((l7) => {
        l7.source._state.greyout = false;
        l7.target._state.greyout = false;
        l7._state.greyout = false;
      });
    }
  }
  _setLinkSelectionState(link7) {
    const { datamodel: { nodes: nodes4, links: links5 } } = this;
    if (!link7)
      console.warn("Unovis: Graph: Select Link: Not found");
    this._selectedLink = link7;
    const selectedLinkSource = link7 === null || link7 === void 0 ? void 0 : link7.source;
    const selectedLinkTarget = link7 === null || link7 === void 0 ? void 0 : link7.target;
    nodes4.forEach((n) => {
      n._state.selected = false;
      n._state.greyout = true;
      if ((selectedLinkTarget === null || selectedLinkTarget === void 0 ? void 0 : selectedLinkTarget._id) === n._id || (selectedLinkSource === null || selectedLinkSource === void 0 ? void 0 : selectedLinkSource._id) === n._id) {
        link7._state.greyout = false;
      }
    });
    links5.forEach((l7) => {
      l7._state.greyout = true;
      const source = l7.source;
      const target = l7.target;
      if (source._id === (selectedLinkSource === null || selectedLinkSource === void 0 ? void 0 : selectedLinkSource._id) && target._id === (selectedLinkTarget === null || selectedLinkTarget === void 0 ? void 0 : selectedLinkTarget._id)) {
        source._state.greyout = false;
        target._state.greyout = false;
        l7._state.greyout = false;
      }
    });
    links5.forEach((l7) => {
      delete l7._state.selected;
    });
    if (link7)
      link7._state.selected = true;
  }
  _resetSelectionGreyoutState() {
    const { datamodel: { nodes: nodes4, links: links5 } } = this;
    this._selectedNodes = [];
    this._selectedLink = void 0;
    nodes4.forEach((n) => {
      delete n._state.selected;
      delete n._state.greyout;
    });
    links5.forEach((l7) => {
      delete l7._state.greyout;
      delete l7._state.selected;
    });
  }
  _updateNodesLinksPartial() {
    const { config } = this;
    const linkElements = this._linksGroup.selectAll(`.${gLink}`);
    linkElements.call(updateLinksPartial, config, this._scale);
    const nodeElements = this._nodesGroup.selectAll(`.${gNode}`);
    nodeElements.call(updateNodesPartial, config, config.duration, this._scale);
  }
  _onBackgroundClick() {
    this._resetSelectionGreyoutState();
    this._updateNodesLinksPartial();
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  _onNodeClick(d18) {
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  _onNodeMouseOut(d18) {
    this._updateNodesLinksPartial();
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  _onNodeMouseOver(d18) {
    this._updateNodesLinksPartial();
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  _onLinkClick(d18) {
  }
  _onLinkMouseOver(d18) {
    if (this._isDragging)
      return;
    if (this.config.linkHighlightOnHover)
      d18._state.hovered = true;
    this._updateNodesLinksPartial();
  }
  _onLinkMouseOut(d18) {
    if (this._isDragging)
      return;
    delete d18._state.hovered;
    this._updateNodesLinksPartial();
  }
  _onLinkFlowTimerFrame(elapsed = 0) {
    const { config, datamodel: { links: links5 } } = this;
    const hasLinksWithFlow = links5.some((d18, i8) => getBoolean(d18, config.linkFlow, i8));
    if (!hasLinksWithFlow)
      return;
    const deltaTime = elapsed - this._linkFlowFrameElapsed;
    const linkGroups = this._linksGroup.selectAll(`.${gLink}`);
    linkGroups.each((l7, i8, els) => {
      var _a;
      const linkFlowParticleSpeed = getNumber(l7, config.linkFlowParticleSpeed, l7._indexGlobal);
      const pathElement = els[i8].querySelector(`.${linkSupport}`);
      const pathLength = pathElement ? (_a = this._linkPathLengthMap.get(pathElement.getAttribute("d"))) !== null && _a !== void 0 ? _a : pathElement.getTotalLength() : 0;
      if (pathLength <= 0)
        return;
      const speed = linkFlowParticleSpeed || pathLength / getNumber(l7, config.linkFlowAnimDuration, l7._indexGlobal) * 1e3;
      l7._state.flowAnimDistancePx = (l7._state.flowAnimDistancePx || 0) + deltaTime / 1e3 * speed;
      l7._state.flowAnimDistanceRelative = l7._state.flowAnimDistancePx % pathLength / pathLength;
    });
    this._linkFlowFrameElapsed = elapsed;
    animateLinkFlow(linkGroups, this.config, this._scale, this._linkPathLengthMap);
  }
  _onZoom(t4, event) {
    const { config, datamodel: { nodes: nodes4 } } = this;
    const transform2 = t4 || event.transform;
    this._scale = transform2.k;
    this._graphGroup.attr("transform", transform2.toString());
    if (isFunction(config.onZoom))
      config.onZoom(this._scale, config.zoomScaleExtent, event, transform2);
    if (!this._initialTransform)
      this._initialTransform = transform2;
    if (event === null || event === void 0 ? void 0 : event.sourceEvent) {
      const diff = Object.keys(transform2).reduce((acc, prop) => {
        const propVal = transform2[prop];
        const initialPropVal = this._initialTransform[prop];
        const dVal = Math.abs(propVal - initialPropVal);
        const scaledDVal = prop === "k" ? 20 * dVal : dVal / 15;
        acc += scaledDVal;
        return acc;
      }, 0);
      if (diff > config.layoutAutofitTolerance)
        this._isAutoFitDisabled = true;
      else
        this._isAutoFitDisabled = false;
    }
    this._nodesGroup.selectAll(`.${gNode}`).call(nodes4.length > config.zoomThrottledUpdateNodeThreshold ? zoomNodesThrottled : zoomNodes, config, this._scale);
    this._linksGroup.selectAll(`.${gLink}`).call(nodes4.length > config.zoomThrottledUpdateNodeThreshold ? zoomLinksThrottled : zoomLinks, config, this._scale, this._getLinkArrowDefId);
  }
  _onZoomStart(t4, event) {
    const { config } = this;
    const transform2 = t4 || event.transform;
    this._scale = transform2.k;
    if (isFunction(config.onZoomStart))
      config.onZoomStart(this._scale, config.zoomScaleExtent, event, transform2);
  }
  _onZoomEnd(t4, event) {
    const { config } = this;
    const transform2 = t4 || event.transform;
    this._scale = transform2.k;
    if (isFunction(config.onZoomEnd))
      config.onZoomEnd(this._scale, config.zoomScaleExtent, event, transform2);
  }
  _updateNodePosition(d18, x21, y25) {
    var _a, _b;
    const transform2 = transform(this.g.node());
    const scale = transform2.k;
    const panels2 = (_b = (_a = this._panels) === null || _a === void 0 ? void 0 : _a.filter((p13) => p13.nodes.includes(d18._id))) !== null && _b !== void 0 ? _b : [];
    const nodeSizeValue = getNodeSize(d18, this.config.nodeSize, d18._index);
    const maxY = min([(this._height - transform2.y) / scale, ...panels2.map((p13) => p13._y + p13._height)]) - nodeSizeValue / 2;
    const maxX = min([(this._width - transform2.x) / scale, ...panels2.map((p13) => p13._x + p13._width)]) - nodeSizeValue / 2;
    const minY = max([-transform2.y / scale, ...panels2.map((p13) => p13._y)]) + nodeSizeValue / 2;
    const minX = max([-transform2.x / scale, ...panels2.map((p13) => p13._x)]) + nodeSizeValue / 2;
    if (y25 < minY)
      y25 = minY;
    else if (y25 > maxY)
      y25 = maxY;
    if (x21 < minX)
      x21 = minX;
    else if (x21 > maxX)
      x21 = maxX;
    if (Math.sqrt(Math.pow(x21 - d18.x, 2) + Math.pow(y25 - d18.y, 2)) < 15) {
      x21 = d18.x;
      y25 = d18.y;
    }
    d18._state.fx = x21;
    d18._state.fy = y25;
    if (d18._state.fx === d18.x)
      delete d18._state.fx;
    if (d18._state.fy === d18.y)
      delete d18._state.fy;
  }
  _onBrush(event) {
    var _a;
    if (!event.selection || !event.sourceEvent)
      return;
    const { config } = this;
    const transform2 = transform(this._graphGroup.node());
    const [xMin, yMin] = transform2.invert(event.selection[0]);
    const [xMax, yMax] = transform2.invert(event.selection[1]);
    this._nodesGroup.selectAll(`.${gNode}`).each((n) => {
      const x21 = getX2(n);
      const y25 = getY2(n);
      n._state.brushed = x21 >= xMin && x21 <= xMax && y25 >= yMin && y25 <= yMax;
    }).classed(brushed, (n) => n._state.brushed);
    const brushedNodes = this._nodesGroup.selectAll(`.${brushed}`).call(updateNodesPartial, config, 0, this._scale);
    this._brush.classed("active", event.type !== "end");
    (_a = config.onNodeSelectionBrush) === null || _a === void 0 ? void 0 : _a.call(config, brushedNodes.data(), event);
  }
  _handleDrag(d18, event, nodeSelection2) {
    if (event.sourceEvent.shiftKey && d18._state.brushed) {
      this._dragSelectedNodes(event);
    } else if (!event.sourceEvent.shiftKey) {
      switch (event.type) {
        case "start":
          this._onDragStarted(d18, event, nodeSelection2);
          break;
        case "drag":
          this._onDragged(d18, event);
          break;
        case "end":
          this._onDragEnded(d18, event, nodeSelection2);
          break;
      }
    }
  }
  _onDragStarted(d18, event, nodeSelection2) {
    var _a;
    const { config } = this;
    this._isDragging = true;
    d18._state.isDragged = true;
    nodeSelection2.call(updateNodes3, config, 0, this._scale);
    (_a = config.onNodeDragStart) === null || _a === void 0 ? void 0 : _a.call(config, d18, event);
  }
  _onDragged(d18, event) {
    var _a;
    const { config } = this;
    const transform2 = transform(this.g.node());
    const scale = transform2.k;
    const [x21, y25] = pointer_default(event, this._graphGroup.node());
    this._updateNodePosition(d18, x21, y25);
    const nodeSelection2 = this._nodesGroup.selectAll(`.${gNode}`);
    const nodeToUpdate = nodeSelection2.filter((n) => n._id === d18._id);
    nodeToUpdate.call(updateNodes3, config, 0, scale);
    const linkSelection = this._linksGroup.selectAll(`.${gLink}`);
    const linksToUpdate = linkSelection.filter((l7) => {
      const source = l7.source;
      const target = l7.target;
      return source._id === d18._id || target._id === d18._id;
    });
    linksToUpdate.call(updateLinks2, config, 0, scale, this._getLinkArrowDefId, this._linkPathLengthMap);
    const linksToAnimate = linksToUpdate.filter((d19) => d19._state.greyout);
    if (linksToAnimate.size())
      animateLinkFlow(linksToAnimate, config, this._scale, this._linkPathLengthMap);
    (_a = config.onNodeDrag) === null || _a === void 0 ? void 0 : _a.call(config, d18, event);
  }
  _onDragEnded(d18, event, nodeSelection2) {
    var _a;
    const { config } = this;
    this._isDragging = false;
    d18._state.isDragged = false;
    nodeSelection2.call(updateNodes3, config, 0, this._scale);
    (_a = config.onNodeDragEnd) === null || _a === void 0 ? void 0 : _a.call(config, d18, event);
  }
  _dragSelectedNodes(event) {
    var _a, _b;
    const { config } = this;
    const curr = pointer_default(event, this._graphGroup.node());
    const selectedNodes = smartTransition(this._nodesGroup.selectAll(`.${brushed}`));
    if (event.type === "start") {
      this._groupDragInit = curr;
      this._isDragging = true;
      selectedNodes.each((n) => {
        n.x = getX2(n);
        n.y = getY2(n);
        n._state.isDragged = true;
      });
    } else if (event.type === "drag") {
      const dx = curr[0] - this._groupDragInit[0];
      const dy = curr[1] - this._groupDragInit[1];
      selectedNodes.each((n) => this._updateNodePosition(n, n.x + dx, n.y + dy));
      const connectedLinks = smartTransition(this._linksGroup.selectAll(`.${gLink}`).filter((l7) => {
        var _a2, _b2, _c, _d;
        return ((_b2 = (_a2 = l7.source) === null || _a2 === void 0 ? void 0 : _a2._state) === null || _b2 === void 0 ? void 0 : _b2.isDragged) || ((_d = (_c = l7.target) === null || _c === void 0 ? void 0 : _c._state) === null || _d === void 0 ? void 0 : _d.isDragged);
      }));
      connectedLinks.call(updateLinks2, this.config, 0, this._scale, this._getLinkArrowDefId, this._linkPathLengthMap);
    } else {
      this._isDragging = false;
      selectedNodes.each((n) => {
        n._state.isDragged = false;
      });
    }
    selectedNodes.call(updateNodes3, config, 0, this._scale);
    (_b = (_a = this.config).onNodeSelectionDrag) === null || _b === void 0 ? void 0 : _b.call(_a, selectedNodes.data(), event);
  }
  _activateBrush() {
    this._brush.classed("active", true);
    this._nodesGroup.selectAll(`.${gNode}`).classed(brushable, true);
  }
  _clearBrush() {
    var _a;
    this._brush.classed("active", false).call((_a = this._brushBehavior) === null || _a === void 0 ? void 0 : _a.clear);
    this._nodesGroup.selectAll(`.${gNode}`).classed(brushable, false).classed(brushed, false).each((n) => {
      n._state.brushed = false;
    }).call(updateNodesPartial, this.config, 0, this._scale);
  }
  _shouldLayoutRecalculate() {
    const { prevConfig, config } = this;
    if (prevConfig.layoutType !== config.layoutType)
      return true;
    if (prevConfig.layoutNonConnectedAside !== config.layoutNonConnectedAside)
      return true;
    if (prevConfig.layoutType === GraphLayoutType.Force) {
      const forceSettingsDiff = shallowDiff(prevConfig.forceLayoutSettings, config.forceLayoutSettings);
      if (Object.keys(forceSettingsDiff).length)
        return true;
    }
    if (prevConfig.layoutType === GraphLayoutType.Dagre) {
      const dagreSettingsDiff = shallowDiff(prevConfig.dagreLayoutSettings, config.dagreLayoutSettings);
      if (Object.keys(dagreSettingsDiff).length)
        return true;
    }
    if (prevConfig.layoutType === GraphLayoutType.Elk) {
      if (isPlainObject(prevConfig.layoutElkSettings) && isPlainObject(config.layoutElkSettings)) {
        const elkSettingsDiff = shallowDiff(prevConfig.layoutElkSettings, config.layoutElkSettings);
        return Boolean(Object.keys(elkSettingsDiff).length);
      } else {
        return prevConfig.layoutElkSettings !== config.layoutElkSettings;
      }
    }
    if (prevConfig.layoutType === GraphLayoutType.Parallel || prevConfig.layoutType === GraphLayoutType.ParallelHorizontal || prevConfig.layoutType === GraphLayoutType.Concentric) {
      if (!isEqual(prevConfig.layoutGroupOrder, config.layoutGroupOrder))
        return true;
      if (prevConfig.layoutParallelNodesPerColumn !== config.layoutParallelNodesPerColumn)
        return true;
      if (prevConfig.layoutParallelSortConnectionsByGroup !== config.layoutParallelSortConnectionsByGroup)
        return true;
    }
    return false;
  }
  _getLinkArrowDefId(arrow3) {
    return arrow3 ? `${this.uid}-${arrow3}` : null;
  }
  _addSVGDefs() {
    this._defs.selectAll("*").remove();
    this._defs.append("path").attr("d", getArrowPath()).attr("id", this._getLinkArrowDefId(GraphLinkArrowStyle.Single));
    this._defs.append("path").attr("d", getDoubleArrowPath()).attr("id", this._getLinkArrowDefId(GraphLinkArrowStyle.Double));
  }
  zoomIn(increment = 0.3) {
    const scaleBy = 1 + increment;
    smartTransition(this.g, this.config.duration / 2).call(this._zoomBehavior.scaleBy, scaleBy);
  }
  zoomOut(increment = 0.3) {
    const scaleBy = 1 - increment;
    smartTransition(this.g, this.config.duration / 2).call(this._zoomBehavior.scaleBy, scaleBy);
  }
  setZoom(zoomLevel) {
    smartTransition(this.g, this.config.duration / 2).call(this._zoomBehavior.scaleTo, zoomLevel);
  }
  getZoom() {
    return transform(this.g.node()).k;
  }
  fitView(duration = this.config.duration, nodeIds, alignment) {
    var _a;
    (_a = this._layoutCalculationPromise) === null || _a === void 0 ? void 0 : _a.then(() => {
      this._fit(duration, nodeIds, alignment);
    });
  }
  /** Enable automatic fitting to container if it was disabled due to previous zoom / pan interactions */
  resetAutofitState() {
    this._isAutoFitDisabled = false;
  }
  /** Get current coordinates of the nodes as an array of { id: string; x: number; y: number } objects */
  getNodesCoordinates() {
    const { datamodel: { nodes: nodes4 } } = this;
    return nodes4.map((n) => ({
      id: n._id,
      x: n.x,
      y: n.y
    }));
  }
  /** Get node coordinates by id as { id: string; x: number; y: number } */
  getNodeCoordinatesById(id2) {
    const { datamodel: { nodes: nodes4 } } = this;
    const node4 = nodes4.find((n) => n._id === id2);
    if (!node4) {
      console.warn(`Unovis | Graph: Node ${id2} not found`);
      return void 0;
    } else {
      return {
        id: node4._id,
        x: node4.x,
        y: node4.y
      };
    }
  }
  /** Set the node state by id */
  setNodeStateById(nodeId, state) {
    this.datamodel.setNodeStateById(nodeId, state);
  }
  /** Call a partial render to update the positions of the nodes and their links.
    * This can be useful when you've changed the node positions manually outside
    * of the component and want to update the graph.
  */
  updateNodePositions(duration) {
    const { config } = this;
    const animDuration = isNumber(duration) ? duration : config.duration;
    const linkElements = this._linksGroup.selectAll(`.${gLink}:not(.${gLinkExit}`);
    updateLinkLines(linkElements, config, animDuration, this._scale, this._getLinkArrowDefId, this._linkPathLengthMap);
    const nodeElements = this._nodesGroup.selectAll(`.${gNode}:not(.${gNodeExit})`);
    updateNodePositions(nodeElements, animDuration);
  }
};
Graph.selectors = {
  root: root19,
  graphGroup,
  background: background6,
  node: gNode,
  nodeShape: node3,
  nodeGauge,
  nodeSideLabel: sideLabelGroup,
  nodeLabel: label8,
  dimmedNode: greyedOutNode,
  link: gLink,
  linkLine: link6,
  linkLabel: linkLabelGroup,
  dimmedLink: greyedOutLink,
  panel: gPanel,
  panelRect: panel,
  panelSelection,
  panelLabel: label9,
  panelLabelText: labelText3,
  panelSideIcon: sideIconGroup,
  panelSideIconShape: sideIconShape,
  panelSideIconSymbol: sideIconSymbol
};
Graph.nodeSelectors = style_exports17;

// node_modules/@unovis/ts/components/vis-controls/config.js
var VisControlsDefaultConfig = {
  items: [],
  orientation: VisControlsOrientation.Horizontal
};

// node_modules/@unovis/ts/components/vis-controls/style.js
var root20 = css`
  label: vis-controls-component;
`;
var variables15 = injectGlobal`
  :root {
    --vis-controls-buttons-border-color: rgba(108, 119, 140, 0.15);
    --vis-controls-buttons-background-color: rgba(255, 255, 255, 1);
    --vis-controls-button-color: #6c778c;
    --vis-controls-button-icon-font: ${UNOVIS_ICON_FONT_FAMILY_DEFAULT};

    --vis-dark-controls-buttons-border-color:  #6c778c;
    --vis-dark-controls-buttons-background-color: var(--vis-color-grey);
    --vis-dark-controls-button-color: #fff;
  }

  body.theme-dark ${`.${root20}`} {
    --vis-controls-buttons-border-color: var(--vis-dark-controls.buttons-border-color);
    --vis-controls-buttons-background-color: var(--vis-dark-controls-buttons-background-color);
    --vis-controls-button-color: var(--vis-dark-controls-button-color);
  }
`;
var items = css`
  label: items;
  background-color: var(--vis-controls-buttons-background-color);
  border: 1px solid var(--vis-controls-buttons-border-color);
  border-radius: 4px;
  opacity: 1;
  transition: all 300ms;
`;
var horizontalItems = css`
  label: horizontal;
  display: inline-flex;
`;
var item3 = css`
  label: item;
`;
var itemButton = css`
  label: item-button;
  font-family: var(--vis-controls-button-icon-font);
  display: block;
  cursor: pointer;
  user-select: none;
  outline: none;
  width: 30px;
  height: 30px;
  line-height: 28px;
  border: none;
  border-radius: inherit;
  box-sizing: border-box;
  color: var(--vis-controls-button-color);
  background-color: inherit;
`;
var borderLeft = css`
  border-left: 1px solid var(--vis-controls-buttons-border-color);
`;
var borderTop = css`
  border-top: 1px solid var(--vis-controls-buttons-border-color);
`;
var borderRight = css`
  border-right: 1px solid var(--vis-controls-buttons-border-color);
`;
var borderBottom = css`
  border-bottom: 1px solid var(--vis-controls-buttons-border-color);
`;
var disabled = css`
  label: disabled;
  opacity: 0.4;
  pointer-events: none;
`;

// node_modules/@unovis/ts/components/donut/config.js
var DonutDefaultConfig = Object.assign(Object.assign({}, ComponentDefaultConfig), { id: (d18, i8) => {
  var _a;
  return (_a = d18.id) !== null && _a !== void 0 ? _a : i8;
}, value: void 0, angleRange: [0, 2 * Math.PI], padAngle: 0, sortFunction: void 0, cornerRadius: 0, color: void 0, radius: void 0, arcWidth: 20, centralLabel: void 0, centralSubLabel: void 0, centralSubLabelWrap: true, showEmptySegments: false, emptySegmentAngle: 0.5 * Math.PI / 180, showBackground: true, backgroundAngleRange: void 0, centralLabelOffsetX: void 0, centralLabelOffsetY: void 0 });

// node_modules/@unovis/ts/components/donut/modules/arc.js
function createArc(selection2, config) {
  selection2.style("fill", (d18) => getColor(d18.data, config.color, d18.index)).style("opacity", 0).each((d18, i8, els) => {
    const arcNode = els[i8];
    const angleCenter = (d18.startAngle + d18.endAngle) / 2;
    const angleHalfWidth = (d18.endAngle - d18.startAngle) / 2;
    arcNode._animState = {
      startAngle: angleCenter - angleHalfWidth,
      endAngle: angleCenter + angleHalfWidth,
      innerRadius: d18.innerRadius,
      outerRadius: d18.outerRadius,
      padAngle: d18.padAngle
    };
  });
}
function updateArc(selection2, config, arcGen, duration) {
  selection2.style("transition", `fill ${duration}ms`).style("fill", (d18) => getColor(d18.data, config.color, d18.index));
  const setOpacity = (d18) => config.showEmptySegments || d18.value ? 1 : 0;
  if (duration) {
    const transition2 = smartTransition(selection2, duration).style("opacity", setOpacity);
    transition2.attrTween("d", (d18, i8, els) => {
      const arcNode = els[i8];
      const nextAnimState = {
        startAngle: d18.startAngle,
        endAngle: d18.endAngle,
        innerRadius: d18.innerRadius,
        outerRadius: d18.outerRadius,
        padAngle: d18.padAngle
      };
      const datum2 = value_default(arcNode._animState, nextAnimState);
      return (t4) => {
        arcNode._animState = datum2(t4);
        return arcGen(arcNode._animState);
      };
    });
  } else {
    selection2.attr("d", arcGen).style("opacity", setOpacity);
  }
}
function removeArc(selection2, duration) {
  smartTransition(selection2, duration).style("opacity", 0).remove();
}

// node_modules/@unovis/ts/components/donut/constants.js
var DONUT_HALF_ANGLE_RANGES = Array.from({ length: 4 }, (_17, i8) => {
  const offset = -Math.PI / 2 + i8 * Math.PI / 2;
  return [offset, offset + Math.PI];
});
var [DONUT_HALF_ANGLE_RANGE_TOP, DONUT_HALF_ANGLE_RANGE_RIGHT, DONUT_HALF_ANGLE_RANGE_BOTTOM, DONUT_HALF_ANGLE_RANGE_LEFT] = DONUT_HALF_ANGLE_RANGES;

// node_modules/@unovis/ts/components/donut/style.js
var style_exports18 = {};
__export(style_exports18, {
  background: () => background8,
  centralLabel: () => centralLabel,
  centralSubLabel: () => centralSubLabel,
  root: () => root21,
  segment: () => segment,
  segmentExit: () => segmentExit,
  variables: () => variables16
});
var root21 = css`
  label: donut-component;
`;
var variables16 = injectGlobal`
  :root {
    --vis-donut-central-label-font-size: 16px;
    --vis-donut-central-label-text-color: #5b5f6d;
    // Undefined by default to allow proper fallback to var(--vis-font-family)
    /* --vis-donut-central-label-font-family: */
    --vis-donut-central-label-font-weight: 600;

    --vis-donut-central-sub-label-font-size: 12px;
    --vis-donut-central-sub-label-text-color: #5b5f6d;
    // Undefined by default to allow proper fallback to var(--vis-font-family)
    /* --vis-donut-central-sub-label-font-family: */
    --vis-donut-central-sub-label-font-weight: 500;

    --vis-donut-background-color: #E7E9F3;
    --vis-donut-segment-stroke-width: 0;
    // The line segment color variable is not defined by default
    // to allow it to fallback to the donut background color
    /* --vis-donut-segment-stroke-color: none; */

    --vis-dark-donut-central-label-text-color: #C2BECE;
    --vis-dark-donut-central-sub-label-text-color: #C2BECE;
    --vis-dark-donut-background-color: #18160C;
  }

  body.theme-dark ${`.${root21}`} {
    --vis-donut-central-label-text-color: var(--vis-dark-donut-central-label-text-color);
    --vis-donut-central-sub-label-text-color: var(--vis-dark-donut-central-sub-label-text-color);
    --vis-donut-background-color: var(--vis-dark-donut-background-color);
  }
`;
var background8 = css`
  label: background;
  fill: var(--vis-donut-background-color);
`;
var segment = css`
  label: segment;
  stroke-width: var(--vis-donut-segment-stroke-width);
  stroke: var(--vis-donut-segment-stroke-color, var(--vis-donut-background-color));
`;
var segmentExit = css`
  label: segment-exit;
`;
var centralLabel = css`
  label: central-label;
  text-anchor: middle;
  dominant-baseline: middle;
  font-size: var(--vis-donut-central-label-font-size);
  font-family: var(--vis-donut-central-label-font-family, var(--vis-font-family));
  font-weight: var(--vis-donut-central-label-font-weight);
  fill: var(--vis-donut-central-label-text-color);
`;
var centralSubLabel = css`
  label: central-label;
  text-anchor: middle;
  dominant-baseline: middle;
  font-size: var(--vis-donut-central-sub-label-font-size);
  font-family: var(--vis-donut-central-sub-label-font-family, var(--vis-font-family));
  font-weight: var(--vis-donut-central-sub-label-font-weight);
  fill: var(--vis-donut-central-sub-label-text-color);
`;

// node_modules/@unovis/ts/components/donut/index.js
var Donut = class extends ComponentCore {
  constructor(config) {
    super();
    this._defaultConfig = DonutDefaultConfig;
    this.config = this._defaultConfig;
    this.datamodel = new SeriesDataModel();
    this.arcGen = arc_default();
    this.events = {};
    if (config)
      this.setConfig(config);
    this.arcBackground = this.g.append("path");
    this.arcGroup = this.g.append("g");
    this.centralLabel = this.g.append("text").attr("class", centralLabel);
    this.centralSubLabel = this.g.append("text").attr("class", centralSubLabel);
  }
  get bleed() {
    return { top: 0, bottom: 0, left: 0, right: 0 };
  }
  _render(customDuration) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    const { config, datamodel, bleed } = this;
    const data = datamodel.data.map((d18, i8) => ({
      index: i8,
      datum: d18
    })).filter((d18) => config.showEmptySegments || getNumber(d18.datum, config.value, d18.index));
    const duration = isNumber(customDuration) ? customDuration : config.duration;
    const [isHalfDonutTop, isHalfDonutRight, isHalfDonutBottom, isHalfDonutLeft] = DONUT_HALF_ANGLE_RANGES.map((angleRange) => config.angleRange && (config.angleRange[0] === angleRange[0] && config.angleRange[1] === angleRange[1]));
    const isVerticalHalfDonut = isHalfDonutTop || isHalfDonutBottom;
    const isHorizontalHalfDonut = isHalfDonutRight || isHalfDonutLeft;
    const width = this._width * (isHorizontalHalfDonut ? 2 : 1);
    const height = this._height * (isVerticalHalfDonut ? 2 : 1);
    const outerRadius = config.radius || Math.min(width - bleed.left - bleed.right, height - bleed.top - bleed.bottom) / 2;
    const innerRadius = config.arcWidth === 0 ? 0 : clamp(outerRadius - config.arcWidth, 0, outerRadius - 1);
    const translateY2 = this._height / 2 + (isHalfDonutTop ? outerRadius / 2 : isHalfDonutBottom ? -outerRadius / 2 : 0);
    const translateX2 = this._width / 2 + (isHalfDonutLeft ? outerRadius / 2 : isHalfDonutRight ? -outerRadius / 2 : 0);
    const translate = `translate(${translateX2},${translateY2})`;
    this.arcGroup.attr("transform", translate);
    this.arcGen.startAngle((d18) => d18.startAngle).endAngle((d18) => d18.endAngle).innerRadius((d18) => d18.innerRadius).outerRadius((d18) => d18.outerRadius).padAngle((d18) => d18.padAngle).cornerRadius(config.cornerRadius);
    const pieGen = pie_default().startAngle((_b = (_a = config.angleRange) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 0).endAngle((_d = (_c = config.angleRange) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : 2 * Math.PI).padAngle(config.padAngle).value((d18) => getNumber(d18.datum, config.value, d18.index) || 0).sort((a7, b25) => {
      var _a2;
      return (_a2 = config.sortFunction) === null || _a2 === void 0 ? void 0 : _a2.call(config, a7.datum, b25.datum);
    });
    const arcData = pieGen(data).map((d18) => {
      const arc2 = Object.assign(Object.assign({}, d18), {
        data: d18.data.datum,
        index: d18.data.index,
        innerRadius,
        outerRadius
      });
      if (config.showEmptySegments && d18.endAngle - d18.startAngle - d18.padAngle <= Number.EPSILON) {
        arc2.endAngle = d18.startAngle + Math.max(config.emptySegmentAngle, config.padAngle);
        arc2.padAngle = d18.padAngle / 2;
      }
      return arc2;
    });
    const arcsSelection = this.arcGroup.selectAll(`.${segment}`).data(arcData, (d18) => config.id(d18.data, d18.index));
    const arcsEnter = arcsSelection.enter().append("path").attr("class", segment).call(createArc, config);
    const arcsMerged = arcsSelection.merge(arcsEnter);
    arcsMerged.call(updateArc, config, this.arcGen, duration);
    arcsMerged.sort((a7, b25) => b25.value - a7.value);
    arcsSelection.exit().attr("class", segmentExit).call(removeArc, duration);
    const labelTextAnchor = isHalfDonutRight ? "start" : isHalfDonutLeft ? "end" : "middle";
    this.centralLabel.attr("dy", config.centralSubLabel ? "-0.55em" : null).style("text-anchor", labelTextAnchor).text((_e = config.centralLabel) !== null && _e !== void 0 ? _e : null);
    this.centralSubLabel.attr("dy", config.centralLabel ? "0.55em" : null).style("text-anchor", labelTextAnchor).text((_f = config.centralSubLabel) !== null && _f !== void 0 ? _f : null);
    if (config.centralSubLabelWrap)
      wrapSVGText(this.centralSubLabel, innerRadius * 1.9);
    const labelTranslateX = (config.centralLabelOffsetX || 0) + translateX2;
    let labelTranslateY = (config.centralLabelOffsetY || 0) + translateY2;
    if (isVerticalHalfDonut && config.centralLabelOffsetX === void 0 && config.centralLabelOffsetY === void 0) {
      const halfDonutLabelOffsetY = isHalfDonutTop ? -this.centralSubLabel.node().getBoundingClientRect().height : isHalfDonutBottom ? this.centralLabel.node().getBoundingClientRect().height : 0;
      labelTranslateY = halfDonutLabelOffsetY + translateY2;
    }
    const labelTranslate = `translate(${labelTranslateX},${labelTranslateY})`;
    this.centralLabel.attr("transform", labelTranslate);
    this.centralSubLabel.attr("transform", labelTranslate);
    this.arcBackground.attr("class", background8).attr("visibility", config.showBackground ? null : "hidden").attr("transform", translate);
    smartTransition(this.arcBackground, duration).attr("d", this.arcGen({
      startAngle: (_k = (_h = (_g = config.backgroundAngleRange) === null || _g === void 0 ? void 0 : _g[0]) !== null && _h !== void 0 ? _h : (_j = config.angleRange) === null || _j === void 0 ? void 0 : _j[0]) !== null && _k !== void 0 ? _k : 0,
      endAngle: (_p = (_m = (_l = config.backgroundAngleRange) === null || _l === void 0 ? void 0 : _l[1]) !== null && _m !== void 0 ? _m : (_o = config.angleRange) === null || _o === void 0 ? void 0 : _o[1]) !== null && _p !== void 0 ? _p : 2 * Math.PI,
      innerRadius,
      outerRadius
    }));
  }
};
Donut.selectors = style_exports18;

// node_modules/@unovis/ts/components/free-brush/config.js
var FreeBrushDefaultConfig = Object.assign(Object.assign({}, XYComponentDefaultConfig), {
  /* eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function */
  onBrush: (s12, e3, userDriven) => {
  },
  /* eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function */
  onBrushStart: (s12, e3, userDriven) => {
  },
  /* eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function */
  onBrushMove: (s12, e3, userDriven) => {
  },
  /* eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function */
  onBrushEnd: (s12, e3, userDriven) => {
  },
  handleWidth: 1,
  selection: void 0,
  selectionMinLength: void 0,
  mode: FreeBrushMode.X,
  autoHide: true
});

// node_modules/@unovis/ts/components/free-brush/style.js
var style_exports19 = {};
__export(style_exports19, {
  brush: () => brush4,
  hide: () => hide,
  root: () => root22,
  variables: () => variables17
});
var root22 = css`
  label: free-brush-component;
`;
var variables17 = injectGlobal`
  :root {
    --vis-free-brush-selection-fill-color: #0b1640;
    --vis-free-brush-selection-fill-opacity: 0.4;
    --vis-free-brush-selection-stroke-color: #acb2b9;
    --vis-free-brush-handle-fill-color: #6d778c;
    --vis-free-brush-handle-stroke-color: none;

    --vis-dark-free-brush-selection-fill-color: #344174;
    --vis-dark-free-brush-selection-stroke-color: #0b1640;
    --vis-dark-free-brush-handle-fill-color: #6d778c;
  }

  body.theme-dark ${`.${root22}`} {
    --vis-free-brush-selection-fill-color: var(--vis-dark-free-brush-selection-fill-color);
    --vis-free-brush-selection-stroke-color: var(--vis-dark-free-brush-selection-stroke-color);
    --vis-free-brush-handle-fill-color: var(--vis-dark-free-brush-selection-fill-color);
  }
`;
var brush4 = css`
  label: brush;
  fill: none;
  stroke: none;

  .selection {
    fill: var(--vis-free-brush-selection-fill-color);
    fill-opacity: var(--vis-free-brush-selection-fill-opacity);
    stroke: var(--vis-free-brush-selection-stroke-color);
    stroke-width: 0;
    stroke-opacity: 0;
  }

  .handle {
    fill: var(--vis-free-brush-handle-fill-color);
    stroke: var(--vis-free-brush-handle-stroke-color);
  }
`;
var hide = css`
  .selection, .handle {
    display: none;
  }
`;

// node_modules/@unovis/ts/components/free-brush/index.js
var FreeBrush = class extends XYComponentCore {
  constructor(config) {
    super();
    this._defaultConfig = FreeBrushDefaultConfig;
    this.config = this._defaultConfig;
    this._firstRender = true;
    if (config)
      this.setConfig(config);
    this.brush = this.g.append("g").attr("class", brush4);
  }
  _render(customDuration) {
    const { config } = this;
    const xScale = this.xScale;
    const yScale = this.yScale;
    const duration = isNumber(customDuration) ? customDuration : config.duration;
    if (this._firstRender)
      this.brush.classed(hide, this._firstRender && config.autoHide);
    if (this.brush.node().__brush)
      this.brush.node().__brush.emitter = void 0;
    this.brushBehaviour = this._getBrushBehaviour(config.mode);
    this.brushBehaviour.handleSize(config.handleWidth).extent([[0, 0], [this._width, this._height]]).on("start", this._onBrushStart.bind(this)).on("brush", this._onBrushMove.bind(this)).on("end", this._onBrushEnd.bind(this));
    this.brush.call(this.brushBehaviour);
    let brushRange;
    switch (config.mode) {
      case FreeBrushMode.XY: {
        const selection2 = config.selection;
        const xSelectionRange = this._dataRangeToPixelRange([selection2 === null || selection2 === void 0 ? void 0 : selection2[0][0], selection2 === null || selection2 === void 0 ? void 0 : selection2[0][1]], xScale);
        const ySelectionRange = this._dataRangeToPixelRange([selection2 === null || selection2 === void 0 ? void 0 : selection2[1][0], selection2 === null || selection2 === void 0 ? void 0 : selection2[1][1]], yScale, true);
        brushRange = xSelectionRange && ySelectionRange ? [[xSelectionRange[0], ySelectionRange[0]], [xSelectionRange[1], ySelectionRange[1]]] : null;
        break;
      }
      case FreeBrushMode.X:
      case FreeBrushMode.Y:
      default: {
        const scale = config.mode === FreeBrushMode.Y ? yScale : xScale;
        brushRange = this._dataRangeToPixelRange(config.selection, scale, config.mode === FreeBrushMode.Y);
      }
    }
    smartTransition(this.brush, duration).call(this.brushBehaviour.move, brushRange).on("end interrupt", () => {
      this._firstRender = false;
    });
    if (!duration)
      this._firstRender = false;
  }
  _onBrush(event) {
    const { config } = this;
    const userDriven = !!(event === null || event === void 0 ? void 0 : event.sourceEvent);
    const s12 = event === null || event === void 0 ? void 0 : event.selection;
    if (!this._isSelectionValid(s12)) {
      config.selection = null;
      return;
    }
    let selectedDomain;
    switch (config.mode) {
      case FreeBrushMode.XY: {
        const selection2 = s12;
        const xSelection = this._pixelRangeToDataRange([selection2[0][0], selection2[1][0]], this.xScale, isArray(config.selectionMinLength) ? config.selectionMinLength[0] : config.selectionMinLength);
        const ySelection = this._pixelRangeToDataRange([selection2[0][1], selection2[1][1]], this.yScale, isArray(config.selectionMinLength) ? config.selectionMinLength[1] : config.selectionMinLength, true);
        selectedDomain = xSelection && ySelection ? [
          [xSelection === null || xSelection === void 0 ? void 0 : xSelection[0], xSelection === null || xSelection === void 0 ? void 0 : xSelection[1]],
          [ySelection === null || ySelection === void 0 ? void 0 : ySelection[0], ySelection === null || ySelection === void 0 ? void 0 : ySelection[1]]
        ] : null;
        break;
      }
      case FreeBrushMode.Y: {
        selectedDomain = this._pixelRangeToDataRange(s12, this.yScale, isArray(config.selectionMinLength) ? config.selectionMinLength[1] : config.selectionMinLength, true);
        break;
      }
      case FreeBrushMode.X:
      default: {
        selectedDomain = this._pixelRangeToDataRange(s12, this.xScale, isArray(config.selectionMinLength) ? config.selectionMinLength[0] : config.selectionMinLength);
        break;
      }
    }
    if (selectedDomain === null || selectedDomain[0] === null || selectedDomain[1] === null) {
      this.brush.call(this.brushBehaviour.move, null);
      return;
    }
    config.selection = selectedDomain;
    if (!this._firstRender)
      config.onBrush(selectedDomain, event, userDriven);
  }
  _pixelRangeToDataRange(selectionInPixels, scale, constraint, reversed) {
    const selectedDomain = selectionInPixels.map((n) => scale.invert(n));
    if (reversed)
      selectedDomain.reverse();
    const domain = scale.domain();
    const domainLength = Math.abs(domain[1] - domain[0]);
    const selectionLength = Math.abs(selectedDomain[1] - selectedDomain[0]);
    if (constraint >= domainLength) {
      console.warn("Unovis | FreeBrush: Configured domain constraint is bigger than the brush domain");
    }
    if (selectionLength < constraint && constraint < domainLength)
      return null;
    else
      return selectedDomain;
  }
  _dataRangeToPixelRange(selectionInDataUnits, scale, reversed) {
    var _a, _b;
    if (!selectionInDataUnits)
      return null;
    const range3 = scale.range();
    const s12 = [...selectionInDataUnits];
    if (reversed) {
      range3.reverse();
      s12.reverse();
    }
    const selectionMin = clamp((_a = scale(s12[0])) !== null && _a !== void 0 ? _a : 0, range3[0], range3[1]);
    const selectionMax = clamp((_b = scale(s12[1])) !== null && _b !== void 0 ? _b : 0, range3[0], range3[1]);
    return selectionMax - selectionMin ? [selectionMin, selectionMax] : null;
  }
  _isSelectionValid(s12) {
    const { config } = this;
    if (config.mode === FreeBrushMode.XY) {
      return s12 && Array.isArray(s12[0]) && Array.isArray(s12[1]);
    } else {
      return s12 && isNumber(s12[0]) && isNumber(s12[1]);
    }
  }
  _getBrushBehaviour(mode) {
    switch (mode) {
      case FreeBrushMode.X:
        return brushX();
      case FreeBrushMode.Y:
        return brushY();
      default:
        return brush_default();
    }
  }
  _onBrushStart(event) {
    var _a;
    const { config } = this;
    const userDriven = !!(event === null || event === void 0 ? void 0 : event.sourceEvent);
    this._onBrush(event);
    if (config.autoHide && userDriven)
      this.brush.classed(hide, false);
    if (!this._firstRender)
      (_a = config.onBrushStart) === null || _a === void 0 ? void 0 : _a.call(config, config.selection, event, userDriven);
  }
  _onBrushMove(event) {
    var _a;
    const { config } = this;
    this._onBrush(event);
    if (!this._firstRender)
      (_a = config.onBrushMove) === null || _a === void 0 ? void 0 : _a.call(config, config.selection, event, !!(event === null || event === void 0 ? void 0 : event.sourceEvent));
  }
  _onBrushEnd(event) {
    var _a;
    const { config } = this;
    this._onBrush(event);
    if (config.autoHide)
      this.brush.classed(hide, true);
    if (!this._firstRender)
      (_a = config.onBrushEnd) === null || _a === void 0 ? void 0 : _a.call(config, config.selection, event, !!(event === null || event === void 0 ? void 0 : event.sourceEvent));
  }
};
FreeBrush.selectors = style_exports19;

// node_modules/@unovis/ts/components/xy-labels/config.js
var XYLabelsDefaultConfig = Object.assign(Object.assign({}, XYComponentDefaultConfig), { color: (d18) => d18.color, y: void 0, xPositioning: XYLabelPositioning.DataSpace, yPositioning: XYLabelPositioning.DataSpace, labelFontSize: void 0, label: void 0, backgroundColor: void 0, cursor: null, labelTextBrightnessRatio: 0.65, clustering: true, clusterLabel: (records) => records.length.toString(), clusterFontSize: void 0, clusterBackgroundColor: void 0, clusterCursor: void 0, clusterLabelColor: null });

// node_modules/@unovis/ts/components/xy-labels/modules/label.js
function createLabels(selection2) {
  selection2.attr("transform", (d18) => `translate(${d18._screen.x},${d18._screen.y})`);
  selection2.append("rect").style("fill", (d18) => d18._screen.backgroundColor);
  selection2.append("text").style("text-anchor", "middle").style("dominant-baseline", "central").style("fill", (d18) => d18._screen.backgroundColor).style("pointer-events", "none");
  selection2.attr("transform", (d18) => `translate(${d18._screen.x},${d18._screen.y}) scale(0)`);
}
function updateLabels(selection2, config, duration) {
  selection2.each((d18, i8, elements) => {
    var _a, _b;
    const group3 = select_default2(elements[i8]);
    const text = group3.select("text");
    const rect2 = group3.select("rect");
    const backgroundColor = d18._screen.backgroundColor;
    const labelText4 = (_a = d18._screen.labelText) !== null && _a !== void 0 ? _a : "";
    const labelFontSize = d18._screen.fontSize;
    let labelColor = d18._screen.labelColor;
    const backgroundHeight = labelFontSize * 1.7;
    let backgroundWidth = labelFontSize * labelText4.length * 0.7;
    if (backgroundWidth < backgroundHeight)
      backgroundWidth = backgroundHeight;
    smartTransition(rect2, duration).attr("width", backgroundWidth).attr("height", backgroundHeight).attr("x", -backgroundWidth / 2).attr("y", -backgroundHeight / 2).attr("rx", labelFontSize).attr("ry", labelFontSize).style("fill", backgroundColor);
    if (!labelColor) {
      const hex2 = (_b = color(isStringCSSVariable(backgroundColor) ? getCSSVariableValue(backgroundColor, group3.node()) : backgroundColor)) === null || _b === void 0 ? void 0 : _b.hex();
      const brightness = hexToBrightness(hex2);
      labelColor = brightness > config.labelTextBrightnessRatio ? "var(--vis-xy-label-text-color-dark)" : "var(--vis-xy-label-text-color-light)";
    }
    text.html(labelText4).attr("font-size", labelFontSize);
    smartTransition(text, duration).style("fill", labelColor);
    rect2.style("cursor", d18._screen.cursor);
  });
  smartTransition(selection2, duration).attr("transform", (d18) => `translate(${d18._screen.x},${d18._screen.y}) scale(1)`);
}
function removeLabels(selection2, duration) {
  smartTransition(selection2, duration).attr("transform", (d18) => `translate(${d18._screen.x},${d18._screen.y}) scale(0)`).remove();
}
function getLabelPosition(value2, positioning, scale) {
  var _a;
  switch (positioning) {
    case XYLabelPositioning.DataSpace:
      return (_a = scale(value2)) !== null && _a !== void 0 ? _a : 0;
    case XYLabelPositioning.AbsolutePx:
      return value2;
    case XYLabelPositioning.AbsolutePercentage: {
      const scaleRange = scale.range();
      return scaleRange[0] + (scaleRange[1] - scaleRange[0]) * value2 / 100;
    }
  }
}
function getLabelRenderProps(data, el, config, xScale, yScale) {
  var _a, _b;
  const isCluster = Array.isArray(data);
  const fontSize = isCluster ? (_a = getNumber(data, config.clusterFontSize)) !== null && _a !== void 0 ? _a : getCSSVariableValueInPixels("var(--vis-xy-label-cluster-font-size)", el) : (_b = getNumber(data, config.labelFontSize)) !== null && _b !== void 0 ? _b : getCSSVariableValueInPixels("var(--vis-xy-label-font-size)", el);
  const labelText4 = (isCluster ? getString(data, config.clusterLabel) : getString(data, config.label)) || "";
  const backgroundHeight = fontSize * 1.7;
  let backgroundWidth = fontSize * labelText4.length * 0.7;
  if (backgroundWidth < backgroundHeight)
    backgroundWidth = backgroundHeight;
  const x21 = isCluster ? mean(data, (d18) => d18._screen.x) : getLabelPosition(getNumber(data, config.x), getValue(data, config.xPositioning), xScale);
  const y25 = isCluster ? mean(data, (d18) => d18._screen.y) : getLabelPosition(getNumber(data, config.y), getValue(data, config.yPositioning), yScale);
  return {
    x: x21,
    y: y25,
    fontSize,
    labelText: labelText4,
    labelColor: isCluster ? getColor(data, config.clusterLabelColor) : getColor(data, config.color),
    backgroundColor: isCluster ? getColor(data, config.clusterBackgroundColor) : getColor(data, config.backgroundColor),
    cursor: isCluster ? getString(data, config.clusterCursor) : getString(data, config.cursor),
    width: backgroundWidth,
    height: backgroundHeight
  };
}

// node_modules/@unovis/ts/components/xy-labels/style.js
var style_exports20 = {};
__export(style_exports20, {
  cluster: () => cluster,
  globalStyles: () => globalStyles9,
  label: () => label10,
  labelGroup: () => labelGroup2,
  root: () => root23
});
var globalStyles9 = injectGlobal`
  :root {
    --vis-xy-label-cursor: default;
    // Undefined by default to allow proper fallback to var(--vis-color-main)
    /* --vis-xy-label-fill-color */
    --vis-xy-label-stroke-color: none;
    --vis-xy-label-stroke-width: 0px;
    --vis-xy-label-fill-opacity: 1;
    --vis-xy-label-stroke-opacity: 1;
    --vis-xy-label-hover-stroke-width: 1px;
    --vis-xy-label-font-size: 12px;
    --vis-xy-label-cluster-font-size: 14px;

    --vis-xy-label-text-color-dark: #5b5f6d;
    --vis-xy-label-text-color-light: #fff;
    --vis-xy-label-text-font-weight: 500;
  }
`;
var root23 = css`
  label: xy-labels-component;
`;
var labelGroup2 = css`
  label: label-g;

  > rect, text {
    cursor: var(--vis-xy-label-cursor);
    fill: var(--vis-xy-label-fill-color, var(--vis-color-main));
    fill-opacity: var(--vis-xy-label-fill-opacity);
    stroke-opacity: var(--vis-xy-label-stroke-opacity);
  }

  > text {
    font-weight: var(--vis-xy-label-text-font-weight);
    user-select: none;
  }

  > rect {
    stroke-width: var(--vis-xy-label-stroke-width);
    stroke: var(--vis-xy-label-stroke-color);

    &:hover {
        stroke-width: var(--vis-xy-label-hover-stroke-width);
    }
  }
`;
var cluster = css`
  label: cluster;
`;
var label10 = css`
  label: label;
`;

// node_modules/@unovis/ts/components/xy-labels/index.js
var XYLabels = class _XYLabels extends XYComponentCore {
  constructor(config) {
    super();
    this.clippable = false;
    this._defaultConfig = XYLabelsDefaultConfig;
    this.config = this._defaultConfig;
    this.events = {
      [_XYLabels.selectors.label]: {}
    };
    if (config)
      this.setConfig(config);
  }
  _render(customDuration) {
    const { config } = this;
    const duration = isNumber(customDuration) ? customDuration : config.duration;
    const labelGroups = this.g.selectAll(`.${labelGroup2}`).data(this._getDataToRender());
    const labelGroupsExit = labelGroups.exit();
    removeLabels(labelGroupsExit, duration);
    const labelGroupsEnter = labelGroups.enter().append("g").attr("class", labelGroup2).call(createLabels);
    const labelGroupsMerged = labelGroupsEnter.merge(labelGroups).classed(cluster, (d18) => !!d18.records).classed(label10, (d18) => !d18.records);
    labelGroupsMerged.call(updateLabels, config, duration);
  }
  _getDataToRender() {
    var _a, _b;
    const { config, datamodel } = this;
    const xRange = this.xScale.range();
    const yRange = this.yScale.range();
    const labels4 = (_b = (_a = datamodel.data) === null || _a === void 0 ? void 0 : _a.reduce((acc, d18) => {
      const xPositioning = getValue(d18, config.xPositioning);
      const yPositioning = getValue(d18, config.yPositioning);
      const props = getLabelRenderProps(d18, this.element, config, this.xScale, this.yScale);
      if ((xPositioning !== XYLabelPositioning.DataSpace || isNumberWithinRange(props.x, xRange)) && (yPositioning !== XYLabelPositioning.DataSpace || isNumberWithinRange(props.y, yRange))) {
        acc.push(Object.assign(Object.assign({}, d18), { _screen: props }));
      }
      return acc;
    }, [])) !== null && _b !== void 0 ? _b : [];
    return config.clustering ? this._getClusteredLabels(labels4) : labels4;
  }
  _getClusteredLabels(labels4) {
    const labelsNonOverlapping = [...labels4];
    const clusterMap = /* @__PURE__ */ new Map();
    for (let i8 = 0; i8 < labelsNonOverlapping.length; i8 += 1) {
      const label1 = labelsNonOverlapping[i8];
      for (let j6 = i8 + 1; j6 < labelsNonOverlapping.length; j6 += 1) {
        const label22 = labelsNonOverlapping[j6];
        const isIntersecting = rectIntersect(label1._screen, label22._screen);
        if (isIntersecting) {
          if (!clusterMap.has(label1))
            clusterMap.set(label1, [label1]);
          clusterMap.get(label1).push(label22);
          labelsNonOverlapping.splice(j6, 1);
          j6 -= 1;
        }
      }
      if (clusterMap.has(label1)) {
        labelsNonOverlapping.splice(i8, 1);
        i8 -= 1;
      }
    }
    const clusters = Array.from(clusterMap.values()).map((records) => ({
      _screen: getLabelRenderProps(records, this.element, this.config, this.xScale, this.yScale),
      records
    }));
    return [...labelsNonOverlapping, ...clusters];
  }
};
XYLabels.selectors = style_exports20;

// node_modules/@unovis/ts/components/nested-donut/config.js
var NestedDonutDefaultConfig = Object.assign(Object.assign({}, ComponentDefaultConfig), { angleRange: [0, 2 * Math.PI], centralLabel: void 0, centralSubLabel: void 0, centralSubLabelWrap: true, cornerRadius: 0, direction: NestedDonutDirection.Inwards, emptySegmentAngle: Math.PI / 180, hideOverflowingSegmentLabels: true, layers: [], layerPadding: 0, layerSettings: void 0, segmentColor: void 0, segmentLabel: void 0, segmentLabelColor: void 0, showBackground: false, showEmptySegments: false, showSegmentLabels: true, sort: void 0, value: void 0 });

// node_modules/@unovis/ts/components/nested-donut/modules/arc.js
function createArc2(selection2, config) {
  selection2.style("fill", (d18) => {
    var _a, _b;
    return (_a = getColor(d18, config.segmentColor)) !== null && _a !== void 0 ? _a : (_b = d18._state) === null || _b === void 0 ? void 0 : _b.fill;
  }).style("opacity", 0).each((d18, i8, els) => {
    const arcNode = els[i8];
    const angleCenter = (d18.x0 + d18.x1) / 2;
    const angleHalfWidth = (d18.x1 - d18.x0) / 2;
    arcNode._animState = {
      x0: angleCenter - angleHalfWidth,
      x1: angleCenter + angleHalfWidth,
      y0: d18.y0,
      y1: d18.y1
    };
  });
}
function updateArc2(selection2, config, arcGen, duration) {
  selection2.style("transition", `fill ${duration}ms`).style("fill", (d18) => d18._state.fill).style("fill-opacity", (d18) => d18._state.fillOpacity);
  if (duration) {
    const transition2 = smartTransition(selection2, duration).style("opacity", 1);
    transition2.attrTween("d", (d18, i8, els) => {
      const arcNode = els[i8];
      const nextAnimState = { x0: d18.x0, x1: d18.x1, y0: d18.y0, y1: d18.y1 };
      const datum2 = value_default(arcNode._animState, nextAnimState);
      return (t4) => {
        arcNode._animState = datum2(t4);
        return arcGen(arcNode._animState);
      };
    });
  } else {
    selection2.attr("d", arcGen).style("opacity", 1);
  }
}
function removeArc2(selection2, duration) {
  smartTransition(selection2, duration).style("opacity", 0).remove();
}

// node_modules/@unovis/ts/components/nested-donut/style.js
var style_exports21 = {};
__export(style_exports21, {
  background: () => background9,
  centralLabel: () => centralLabel2,
  centralSubLabel: () => centralSubLabel2,
  root: () => root24,
  segment: () => segment2,
  segmentArc: () => segmentArc,
  segmentExit: () => segmentExit2,
  segmentLabel: () => segmentLabel,
  segmentsGroup: () => segmentsGroup,
  variables: () => variables18
});
var cssVarDefaults5 = {
  // Undefined by default to allow proper fallback to var(--vis-font-family)
  "--vis-nested-donut-font-family": void 0,
  // Background
  "--vis-nested-donut-background-color": "#E7E9F3",
  // Central label
  "--vis-nested-donut-central-label-font-size": "16px",
  "--vis-nested-donut-central-label-font-weight": 600,
  "--vis-nested-donut-central-label-text-color": "#5b5f6d",
  // Central sub-label
  "--vis-nested-donut-central-sublabel-font-size": "12px;",
  "--vis-nested-donut-central-sublabel-font-weight": 500,
  "--vis-nested-donut-central-sublabel-text-color": "#5b5f6d",
  // Segments
  "--vis-nested-donut-segment-stroke-width": "1px",
  "--vis-nested-donut-segment-stroke-color": "var(--vis-nested-donut-background-color)",
  "--vis-nested-donut-segment-label-text-color-light": "#5b5f6d",
  "--vis-nested-donut-segment-label-text-color-dark": "#fff",
  "--vis-nested-donut-segment-label-font-size": "1em",
  /* Dark theme */
  "--vis-dark-nested-donut-background-color": "#18160C",
  "--vis-dark-nested-donut-central-label-text-color": "#fff",
  "--vis-dark-nested-donut-central-sublabel-text-color": "#fff"
};
var root24 = css`
  label: nested-donut-component;
`;
var segmentsGroup = css`
  label: nested-donut-segments-group;
`;
var variables18 = getCssVarNames(cssVarDefaults5);
injectGlobalCssVariables(cssVarDefaults5, root24);
var background9 = css`
  label: background;
  fill: var(--vis-nested-donut-background-color);
  stroke-width: var(--vis-nested-donut-segment-stroke-width);
  stroke: var(--vis-nested-donut-segment-stroke-color);
`;
var segment2 = css`
  label: segment;
 `;
var segmentExit2 = css`
  label: segment-exit;
`;
var segmentArc = css`
  label: segment-arc;
  stroke-width: var(--vis-nested-donut-segment-stroke-width);
  stroke: var(--vis-nested-donut-segment-stroke-color);
`;
var segmentLabel = css`
  label: segment-label;
  text-anchor: middle;
  dominant-baseline: middle;
  user-select: none;
  font-size: var(--vis-nested-donut-segment-label-font-size);
`;
var centralLabel2 = css`
  label: central-label;
  text-anchor: middle;
  dominant-baseline: middle;
  font-size: var(--vis-nested-donut-central-label-font-size);
  font-family: var(--vis-nested-donut-central-label-font-family, var(--vis-font-family));
  font-weight: var(--vis-nested-donut-central-label-font-weight);
  fill: var(--vis-nested-donut-central-label-text-color);
`;
var centralSubLabel2 = css`
  label: central-sub-label;
  text-anchor: middle;
  dominant-baseline: middle;
  font-size: var(--vis-nested-donut-central-sublabel-font-size);
  font-family: var(--vis-nested-donut-central-sublabel-font-family, var(--vis-font-family));
  font-weight: var(--vis-nested-donut-central-sublabel-font-weight);
  fill: var(--vis-nested-donut-central-sublabel-text-color);
`;

// node_modules/@unovis/ts/components/nested-donut/modules/label.js
function getLabelFillColor2(d18, element) {
  var _a;
  const c6 = (_a = color(d18._state.fill)) !== null && _a !== void 0 ? _a : color(getHexValue(d18._state.fill, element));
  const rgb2 = c6 === null || c6 === void 0 ? void 0 : c6.rgb();
  const colorParsed = rgb2 && d18._state.fillOpacity ? rgbaToRgb(`rgba(${rgb2.r},${rgb2.g},${rgb2.b},${d18._state.fillOpacity})`, getHexValue(cssvar(variables18.nestedDonutBackgroundColor), element)) : rgb2;
  const brightness = colorParsed ? rgbToBrightness(colorParsed) : 0;
  return cssvar(brightness > 0.65 ? variables18.nestedDonutSegmentLabelTextColorLight : variables18.nestedDonutSegmentLabelTextColorDark);
}
function getLabelTransform2(d18, arcGen) {
  const translate = `translate(${arcGen.centroid(d18)})`;
  const degree = 180 / Math.PI * (arcGen.startAngle()(d18) + arcGen.endAngle()(d18)) / 2 - 90;
  switch (d18._layer.labelAlignment) {
    case NestedDonutSegmentLabelAlignment.Along:
      return `${translate} rotate(${degree + 90})`;
    case NestedDonutSegmentLabelAlignment.Perpendicular:
      return `${translate} rotate(${degree > 90 ? degree - 180 : degree})`;
    default:
      return `${translate}`;
  }
}
function getLabelBounds(d18) {
  const arcWidth = d18.y1 - d18.y0;
  const arcLength = d18._layer._innerRadius * (d18.x1 - d18.x0);
  const bandwidth = Math.max(Math.abs(Math.cos(d18.x0 + (d18.x1 - d18.x0) / 2 - Math.PI / 2) * arcWidth), arcWidth);
  switch (d18._layer.labelAlignment) {
    case NestedDonutSegmentLabelAlignment.Perpendicular:
      return { width: arcWidth, height: arcLength };
    case NestedDonutSegmentLabelAlignment.Along:
      return { width: arcLength, height: arcWidth };
    case NestedDonutSegmentLabelAlignment.Straight:
      return { width: bandwidth, height: bandwidth };
  }
}
function createLabel2(selection2, arcGen) {
  selection2.attr("transform", (d18) => getLabelTransform2(d18, arcGen)).style("visibility", null).style("opacity", 0);
}
function updateLabel2(selection2, config, arcGen, duration) {
  selection2.text((d18) => {
    var _a;
    return (_a = getString(d18, config.segmentLabel)) !== null && _a !== void 0 ? _a : d18.data.key;
  }).style("transition", `fill ${duration}ms`).style("fill", (d18, i8, els) => {
    var _a;
    return (_a = getColor(d18, config.segmentLabelColor)) !== null && _a !== void 0 ? _a : getLabelFillColor2(d18, els[i8]);
  }).each((d18, i8, els) => {
    const bounds = getLabelBounds(d18);
    const label14 = select_default2(els[i8]).call(wrapSVGText, bounds.width);
    const { width, height } = label14.node().getBBox();
    if (config.hideOverflowingSegmentLabels && (width > bounds.width || height > bounds.height) && "hidden") {
      label14.attr("visibility", "hidden");
    } else {
      const fontSize = getCSSVariableValueInPixels(cssvar(variables18.nestedDonutSegmentLabelFontSize), els[i8]);
      const len = label14.selectChildren().size() - 1;
      label14.attr("dy", -fontSize / 2 * len);
    }
  });
  smartTransition(selection2, duration).attr("transform", (d18) => getLabelTransform2(d18, arcGen)).style("opacity", 1);
}
function removeLabel2(selection2, duration) {
  smartTransition(selection2, duration).style("opacity", 0).remove();
}

// node_modules/@unovis/ts/components/nested-donut/index.js
var NestedDonut = class extends ComponentCore {
  constructor(config) {
    super();
    this._defaultConfig = NestedDonutDefaultConfig;
    this.config = this._defaultConfig;
    this.datamodel = new SeriesDataModel();
    this.arcGen = arc_default();
    this.colorScale = linear3();
    this.events = {};
    if (config)
      this.setConfig(config);
    this.arcBackground = this.g.append("g");
    this.arcGroup = this.g.append("g").attr("class", segmentsGroup);
    this.centralLabel = this.g.append("text").attr("class", centralLabel2);
    this.centralSubLabel = this.g.append("text").attr("class", centralSubLabel2);
  }
  _render(customDuration) {
    var _a, _b;
    const { config } = this;
    const duration = isNumber(customDuration) ? customDuration : config.duration;
    if (config.layers === void 0 || config.layers.length === 0) {
      console.warn("Unovis | Nested Donut: No layers defined.");
      return;
    }
    const layers4 = this._getLayerSettings();
    const data = this._getHierarchyData(layers4);
    this.arcGen.startAngle((d18) => d18.x0).endAngle((d18) => d18.x1).innerRadius((d18) => d18.y0).outerRadius((d18) => d18.y1).cornerRadius(config.cornerRadius);
    this.arcGroup.attr("transform", `translate(${this._width / 2},${this._height / 2})`);
    this.arcBackground.attr("transform", `translate(${this._width / 2},${this._height / 2})`);
    this.centralLabel.attr("transform", `translate(${this._width / 2},${this._height / 2})`);
    this.centralSubLabel.attr("transform", `translate(${this._width / 2},${this._height / 2})`);
    const backgrounds = this.arcBackground.selectAll(`.${background9}`).data(layers4, (d18) => d18._id);
    const backgroundsEnter = backgrounds.enter().append("path").attr("class", background9).attr("visibility", config.showBackground ? null : "hidden");
    const backgroundsMerged = backgrounds.merge(backgroundsEnter).style("transition", `fill ${duration}ms`).style("fill", (d18) => d18.backgroundColor);
    smartTransition(backgroundsMerged, duration).attr("d", (d18) => {
      var _a2, _b2, _c, _d;
      return this.arcGen({
        x0: (_b2 = (_a2 = config.angleRange) === null || _a2 === void 0 ? void 0 : _a2[0]) !== null && _b2 !== void 0 ? _b2 : 0,
        x1: (_d = (_c = config.angleRange) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : 2 * Math.PI,
        y0: d18._innerRadius,
        y1: d18._outerRadius
      });
    });
    smartTransition(backgrounds.exit(), duration).style("opacity", 0).remove();
    const segments = this.arcGroup.selectAll(`${segment2}`).data(data, (d18) => d18._id);
    const segmentsEnter = segments.enter().append("g").attr("class", segment2);
    segments.merge(segmentsEnter);
    smartTransition(segments.exit(), duration).attr("class", segmentExit2).style("opacity", 0).remove();
    const arcs = this.arcGroup.selectAll(`.${segmentArc}`).data(data, (d18) => d18._id);
    const arcsEnter = segmentsEnter.append("path").attr("class", segmentArc).call(createArc2, config);
    arcs.merge(arcsEnter).call(updateArc2, config, this.arcGen, duration);
    arcs.exit().attr("class", segmentExit2).call(removeArc2, duration);
    if (config.showSegmentLabels) {
      const labels4 = this.arcGroup.selectAll(`.${segmentLabel}`).data(data, (d18) => d18._id);
      const labelsEnter = segmentsEnter.append("text").attr("class", segmentLabel).call(createLabel2, this.arcGen);
      labels4.merge(labelsEnter).call(updateLabel2, config, this.arcGen, duration);
      labels4.exit().call(removeLabel2, duration);
    }
    this.centralLabel.attr("dy", config.centralSubLabel ? "-0.55em" : null).text((_a = config.centralLabel) !== null && _a !== void 0 ? _a : null);
    this.centralSubLabel.attr("dy", config.centralLabel ? "0.55em" : null).text((_b = config.centralSubLabel) !== null && _b !== void 0 ? _b : null);
    if (config.centralSubLabelWrap)
      wrapSVGText(this.centralSubLabel, layers4[0]._innerRadius * 1.9, VerticalAlign.Top);
  }
  _getHierarchyData(layers4) {
    var _a;
    const { config, datamodel: { data } } = this;
    const layerAccessors = (_a = config.layers) === null || _a === void 0 ? void 0 : _a.map((layerAccessor) => (i8) => getString(data[i8], layerAccessor, i8));
    const nestedData = group(data.keys(), ...layerAccessors);
    const rootNode = config.value !== void 0 ? hierarchy(nestedData).sum((index3) => typeof index3 === "number" && getNumber(data[index3], config.value, index3)) : hierarchy(nestedData).count();
    const partitionData = partition_default().size([config.angleRange[1], 1])(rootNode);
    partitionData.each((node4) => {
      var _a2, _b, _c;
      const n = node4;
      node4.data = {
        key: n.data[0],
        values: Array.isArray(n.data[1]) ? n.data[1].map((i8) => data[i8]) : [],
        root: (_c = (_b = (_a2 = node4.parent) === null || _a2 === void 0 ? void 0 : _a2.data) === null || _b === void 0 ? void 0 : _b.root) !== null && _c !== void 0 ? _c : n.data[0]
      };
      node4._id = `root${partitionData.path(node4).map((d18) => d18.data.key).join("->")}`;
      if (isNumberWithinRange(node4.depth - 1, [0, layers4.length - 1])) {
        node4._layer = layers4[node4.depth - 1];
        node4.y0 = node4._layer._innerRadius;
        node4.y1 = node4._layer._outerRadius;
      }
    }).eachBefore((node4) => {
      var _a2, _b, _c, _d;
      if (!node4.children || node4.depth === rootNode.height - 1)
        return;
      const positions = pie_default().startAngle(node4.parent ? node4.x0 : (_a2 = config.angleRange) === null || _a2 === void 0 ? void 0 : _a2[0]).endAngle(node4.parent ? node4.x1 : (_b = config.angleRange) === null || _b === void 0 ? void 0 : _b[1]).value((d18) => config.showEmptySegments && d18.value === 0 ? config.emptySegmentAngle : d18.x1 - d18.x0).sort(config.sort)(node4.children);
      const opacity = linear3().domain([-1, node4.children.length]).range([(_d = (_c = node4._state) === null || _c === void 0 ? void 0 : _c.fillOpacity) !== null && _d !== void 0 ? _d : 1, 0]);
      node4.children.forEach((child, i8) => {
        child._index = i8;
        child.x0 = positions[i8].startAngle;
        child.x1 = positions[i8].endAngle;
        const color2 = getColor(child, config.segmentColor, positions[i8].index, child.depth !== 1);
        child._state = {
          fill: color2 !== null && color2 !== void 0 ? color2 : node4._state.fill,
          fillOpacity: color2 === null ? opacity(positions[i8].index) : null
        };
      });
    }).eachAfter((node4) => {
      var _a2;
      (_a2 = node4.children) === null || _a2 === void 0 ? void 0 : _a2.forEach((ch) => node4.data.values.push(...ch.data.values));
    });
    const segments = partitionData.descendants().filter((d18) => {
      var _a2;
      return ((_a2 = d18.parent) === null || _a2 === void 0 ? void 0 : _a2.value) && d18.data.key;
    });
    return segments;
  }
  _getLayerSettings() {
    const { direction, layers: layers4, layerPadding, layerSettings } = this.config;
    const outerRadius = Math.min(this._width, this._height) / 2;
    const defaultLayerSettings = {
      backgroundColor: cssvar(variables18.nestedDonutBackgroundColor),
      labelAlignment: NestedDonutSegmentLabelAlignment.Perpendicular,
      width: outerRadius * 0.75 / layers4.length
    };
    const layerItems = layers4.reduceRight((arr, _17, i8) => {
      const layerId = direction === NestedDonutDirection.Outwards ? i8 : arr.length;
      const layerConfig = merge2(defaultLayerSettings, getValue(layerId, layerSettings));
      const radius = arr.length ? arr[0]._innerRadius - layerPadding : outerRadius;
      const layerWidth = getPixelValue(layerConfig.width);
      if (layerWidth === null) {
        console.warn(`Unovis | Nested Donut: Could not parse width ${layerConfig.width}. Setting to default.`);
      }
      arr.unshift(Object.assign(Object.assign({}, layerConfig), { _id: layerId, _outerRadius: radius, _innerRadius: radius - (layerWidth !== null && layerWidth !== void 0 ? layerWidth : defaultLayerSettings.width) }));
      return arr;
    }, new Array());
    return direction === NestedDonutDirection.Inwards ? layerItems.reverse() : layerItems;
  }
};
NestedDonut.selectors = style_exports21;
NestedDonut.cssVariables = variables18;

// node_modules/@unovis/ts/components/annotations/config.js
var AnnotationsDefaultConfig = Object.assign(Object.assign({}, ComponentDefaultConfig), { items: [] });

// node_modules/@unovis/ts/components/annotations/style.js
var style_exports22 = {};
__export(style_exports22, {
  annotation: () => annotation,
  annotationContent: () => annotationContent,
  annotationSubject: () => annotationSubject,
  root: () => root25,
  variables: () => variables19
});
var cssVarDefaults6 = {
  "--vis-annotations-text-color": "#282C34",
  "--vis-annotations-connector-stroke-color": "#444",
  "--vis-annotations-connector-stroke-width": "1px",
  "--vis-annotations-connector-stroke-dasharray": "none",
  "--vis-annotations-subject-stroke-color": "#444",
  "--vis-annotations-subject-fill-color": "none",
  "--vis-annotations-subject-stroke-dasharray": "none",
  "--vis-dark-annotations-text-color": "#e8e9ef",
  "--vis-dark-annotations-connector-stroke-color": "#fff",
  "--vis-dark-annotations-subject-stroke-color": "#fff"
};
var root25 = css`
  label: annotations-component;
`;
var variables19 = getCssVarNames(cssVarDefaults6);
injectGlobalCssVariables(cssVarDefaults6, root25);
var annotation = css`
  label: annotation;
`;
var annotationSubject = css`
  label: annotationSubject;

  line {
    stroke: var(${variables19.annotationsConnectorStrokeColor});
    stroke-width: var(${variables19.annotationsConnectorStrokeWidth});
    stroke-dasharray: var(${variables19.annotationsConnectorStrokeDasharray});
  }

  circle {
    stroke: var(${variables19.annotationsSubjectStrokeColor});
    fill: var(${variables19.annotationsSubjectFillColor});
    stroke-dasharray: var(${variables19.annotationsSubjectStrokeDasharray});
  }
`;
var annotationContent = css`
  label: annotationContent;
  > text {
    fill: var(--vis-annotations-text-color);
  }
`;

// node_modules/@unovis/ts/components/annotations/index.js
var Annotations = class extends ComponentCore {
  constructor(config) {
    super();
    this._defaultConfig = AnnotationsDefaultConfig;
    this.config = this._defaultConfig;
    this.events = {};
    if (config)
      this.setConfig(config);
  }
  _render(customDuration) {
    super._render(customDuration);
    const { config } = this;
    const duration = isNumber(customDuration) ? customDuration : config.duration;
    const annotations = this.g.selectAll(`.${annotation}`).data(config.items, (d18) => JSON.stringify(d18));
    const annotationsEnter = annotations.enter().append("g").attr("class", annotation).style("opacity", 0);
    annotationsEnter.append("g").attr("class", annotationContent);
    const subject = annotationsEnter.append("g").attr("class", annotationSubject);
    subject.append("circle");
    subject.append("line");
    const annotationsMerged = annotationsEnter.merge(annotations).attr("cursor", (d18) => d18 === null || d18 === void 0 ? void 0 : d18.cursor).each((annotation2, i8, elements) => {
      if (annotation2.content) {
        const content = typeof annotation2.content === "string" ? Object.assign(Object.assign({}, UNOVIS_TEXT_DEFAULT), { text: annotation2.content }) : annotation2.content;
        const x21 = parseUnit(annotation2.x, this._width);
        const y25 = parseUnit(annotation2.y, this._height);
        const width = parseUnit(annotation2.width, this._width);
        const height = parseUnit(annotation2.height, this._height);
        const options = Object.assign(Object.assign({}, annotation2), { x: x21, y: y25, width, height });
        const contentGroupElement = select_default2(elements[i8]).select(`.${annotationContent}`);
        renderTextIntoFrame(contentGroupElement.node(), content, options);
      }
      if (annotation2.subject) {
        requestAnimationFrame(() => this._renderSubject(elements[i8], annotation2.subject));
      }
    });
    smartTransition(annotationsMerged, duration).style("opacity", 1);
    smartTransition(annotations.exit(), duration).style("opacity", 0).remove();
  }
  _renderSubject(annotationGroupElement, subject) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const contentGroup = select_default2(annotationGroupElement).select(`.${annotationContent}`);
    const subjectGroup = select_default2(annotationGroupElement).select(`.${annotationSubject}`);
    const subjectX = (_a = parseUnit(typeof (subject === null || subject === void 0 ? void 0 : subject.x) === "function" ? subject.x() : subject === null || subject === void 0 ? void 0 : subject.x, this._width)) !== null && _a !== void 0 ? _a : null;
    const subjectY = (_b = parseUnit(typeof (subject === null || subject === void 0 ? void 0 : subject.y) === "function" ? subject.y() : subject === null || subject === void 0 ? void 0 : subject.y, this._height)) !== null && _b !== void 0 ? _b : null;
    const subjectStrokeColor = (_c = subject === null || subject === void 0 ? void 0 : subject.strokeColor) !== null && _c !== void 0 ? _c : null;
    const subjectFillColor = (_d = subject === null || subject === void 0 ? void 0 : subject.fillColor) !== null && _d !== void 0 ? _d : null;
    const subjectStrokeDasharray = (_e = subject === null || subject === void 0 ? void 0 : subject.strokeDasharray) !== null && _e !== void 0 ? _e : null;
    const connectorLineColor = (_f = subject === null || subject === void 0 ? void 0 : subject.connectorLineColor) !== null && _f !== void 0 ? _f : null;
    const connectorLineStrokeDasharray = (_g = subject === null || subject === void 0 ? void 0 : subject.connectorLineStrokeDasharray) !== null && _g !== void 0 ? _g : null;
    const subjectRadius = (_h = subject === null || subject === void 0 ? void 0 : subject.radius) !== null && _h !== void 0 ? _h : 0;
    const padding = (_j = subject === null || subject === void 0 ? void 0 : subject.padding) !== null && _j !== void 0 ? _j : 5;
    const contentBbox = contentGroup.node().getBBox();
    const dy = Math.abs(subjectY - (contentBbox.y + contentBbox.height / 2));
    const dx = Math.abs(subjectX - (contentBbox.x + contentBbox.width / 2));
    const annotationPadding = 5;
    const x22 = dx < dy && (subjectY < contentBbox.y || subjectY > contentBbox.y + contentBbox.height) ? contentBbox.x + contentBbox.width / 2 : subjectX < contentBbox.x ? contentBbox.x - annotationPadding : contentBbox.x + contentBbox.width + annotationPadding;
    const y25 = dx >= dy || subjectY >= contentBbox.y && subjectY <= contentBbox.y + contentBbox.height ? contentBbox.y + contentBbox.height / 2 : subjectY < contentBbox.y ? contentBbox.y - annotationPadding : contentBbox.y + contentBbox.height + annotationPadding;
    const angle = Math.atan2(y25 - subjectY, x22 - subjectX) * 180 / Math.PI;
    const x110 = subjectX + Math.cos(angle * Math.PI / 180) * (subjectRadius + padding);
    const y110 = subjectY + Math.sin(angle * Math.PI / 180) * (subjectRadius + padding);
    subjectGroup.select("circle").attr("visibility", subject ? null : "hidden").attr("cx", subjectX).attr("cy", subjectY).attr("r", subjectRadius).style("stroke", subjectStrokeColor).style("fill", subjectFillColor).style("stroke-dasharray", subjectStrokeDasharray);
    subjectGroup.select("line").attr("visibility", subject ? null : "hidden").attr("x1", x110).attr("y1", y110).attr("x2", x110).attr("y2", y110).attr("x2", x22).attr("y2", y25).style("stroke", connectorLineColor).style("stroke-dasharray", connectorLineStrokeDasharray);
  }
};
Annotations.selectors = style_exports22;
Annotations.cssVariables = variables19;

// node_modules/@unovis/ts/components/plotband/constants.js
var HORIZONTAL_X = {
  [PlotbandLabelPosition.TopLeftOutside]: ({ startX, offsetX, offsetY }) => ({
    x: startX - offsetX,
    y: offsetY,
    textAnchor: "end",
    dominantBaseline: "text-before-edge"
  }),
  [PlotbandLabelPosition.TopLeftInside]: ({ startX, offsetX, offsetY }) => ({
    x: startX + offsetX,
    y: offsetY,
    textAnchor: "start",
    dominantBaseline: "text-before-edge"
  }),
  [PlotbandLabelPosition.TopOutside]: ({ startX, width, offsetY }) => ({
    x: startX + width / 2,
    y: offsetY,
    textAnchor: "middle",
    dominantBaseline: "text-before-edge"
  }),
  [PlotbandLabelPosition.TopInside]: ({ startX, width, offsetY }) => ({
    x: startX + width / 2,
    y: offsetY,
    textAnchor: "middle",
    dominantBaseline: "text-before-edge"
  }),
  [PlotbandLabelPosition.TopRightOutside]: ({ startX, width, offsetX, offsetY }) => ({
    x: startX + width + offsetX,
    y: offsetY,
    textAnchor: "start",
    dominantBaseline: "text-before-edge"
  }),
  [PlotbandLabelPosition.TopRightInside]: ({ startX, width, offsetX, offsetY }) => ({
    x: startX + width - offsetX,
    y: offsetY,
    textAnchor: "end",
    dominantBaseline: "text-before-edge"
  }),
  [PlotbandLabelPosition.RightOutside]: ({ startX, width, height, offsetX }) => ({
    x: startX + width + offsetX,
    y: height / 2,
    textAnchor: "start",
    dominantBaseline: "middle"
  }),
  [PlotbandLabelPosition.RightInside]: ({ startX, width, height, offsetX }) => ({
    x: startX + width - offsetX,
    y: height / 2,
    textAnchor: "end",
    dominantBaseline: "middle"
  }),
  [PlotbandLabelPosition.BottomRightOutside]: ({ startX, width, height, offsetX, offsetY }) => ({
    x: startX + width + offsetX,
    y: height - offsetY,
    textAnchor: "start",
    dominantBaseline: "text-after-edge"
  }),
  [PlotbandLabelPosition.BottomRightInside]: ({ startX, width, height, offsetX, offsetY }) => ({
    x: startX + width - offsetX,
    y: height - offsetY,
    textAnchor: "end",
    dominantBaseline: "text-after-edge"
  }),
  [PlotbandLabelPosition.BottomOutside]: ({ startX, width, height, offsetY }) => ({
    x: startX + width / 2,
    y: height - offsetY,
    textAnchor: "middle",
    dominantBaseline: "text-after-edge"
  }),
  [PlotbandLabelPosition.BottomInside]: ({ startX, width, height, offsetY }) => ({
    x: startX + width / 2,
    y: height - offsetY,
    textAnchor: "middle",
    dominantBaseline: "text-after-edge"
  }),
  [PlotbandLabelPosition.BottomLeftOutside]: ({ startX, height, offsetX, offsetY }) => ({
    x: startX - offsetX,
    y: height - offsetY,
    textAnchor: "end",
    dominantBaseline: "text-after-edge"
  }),
  [PlotbandLabelPosition.BottomLeftInside]: ({ startX, height, offsetX, offsetY }) => ({
    x: startX + offsetX,
    y: height - offsetY,
    textAnchor: "start",
    dominantBaseline: "text-after-edge"
  }),
  [PlotbandLabelPosition.LeftOutside]: ({ startX, height, offsetX }) => ({
    x: startX - offsetX,
    y: height / 2,
    textAnchor: "end",
    dominantBaseline: "middle"
  }),
  [PlotbandLabelPosition.LeftInside]: ({ startX, height, offsetX }) => ({
    x: startX + offsetX,
    y: height / 2,
    textAnchor: "start",
    dominantBaseline: "middle"
  })
};
var VERTICAL_X = {
  [PlotbandLabelPosition.TopLeftOutside]: ({ startX, offsetX, offsetY }) => ({
    x: startX - offsetX,
    y: offsetY,
    textAnchor: "end",
    dominantBaseline: "text-after-edge"
  }),
  [PlotbandLabelPosition.TopLeftInside]: ({ startX, offsetX, offsetY }) => ({
    x: startX + offsetX,
    y: offsetY,
    textAnchor: "end",
    dominantBaseline: "text-before-edge"
  }),
  [PlotbandLabelPosition.TopOutside]: ({ startX, width, offsetY }) => ({
    x: startX + width / 2,
    y: offsetY,
    textAnchor: "end",
    dominantBaseline: "middle"
  }),
  [PlotbandLabelPosition.TopInside]: ({ startX, width, offsetY }) => ({
    x: startX + width / 2,
    y: offsetY,
    textAnchor: "end",
    dominantBaseline: "middle"
  }),
  [PlotbandLabelPosition.TopRightOutside]: ({ startX, width, offsetX, offsetY }) => ({
    x: startX + width + offsetX,
    y: offsetY,
    textAnchor: "end",
    dominantBaseline: "text-before-edge"
  }),
  [PlotbandLabelPosition.TopRightInside]: ({ startX, width, offsetX, offsetY }) => ({
    x: startX + width - offsetX,
    y: offsetY,
    textAnchor: "end",
    dominantBaseline: "text-after-edge"
  }),
  [PlotbandLabelPosition.RightOutside]: ({ startX, width, height, offsetX }) => ({
    x: startX + width + offsetX,
    y: height / 2,
    textAnchor: "middle",
    dominantBaseline: "text-before-edge"
  }),
  [PlotbandLabelPosition.RightInside]: ({ startX, width, height, offsetX }) => ({
    x: startX + width - offsetX,
    y: height / 2,
    textAnchor: "middle",
    dominantBaseline: "text-after-edge"
  }),
  [PlotbandLabelPosition.BottomRightOutside]: ({ startX, width, height, offsetX, offsetY }) => ({
    x: startX + width + offsetX,
    y: height - offsetY,
    textAnchor: "start",
    dominantBaseline: "text-before-edge"
  }),
  [PlotbandLabelPosition.BottomRightInside]: ({ startX, width, height, offsetX, offsetY }) => ({
    x: startX + width - offsetX,
    y: height - offsetY,
    textAnchor: "start",
    dominantBaseline: "text-after-edge"
  }),
  [PlotbandLabelPosition.BottomOutside]: ({ startX, width, height, offsetY }) => ({
    x: startX + width / 2,
    y: height - offsetY,
    textAnchor: "start",
    dominantBaseline: "middle"
  }),
  [PlotbandLabelPosition.BottomInside]: ({ startX, width, height, offsetY }) => ({
    x: startX + width / 2,
    y: height - offsetY,
    textAnchor: "start",
    dominantBaseline: "middle"
  }),
  [PlotbandLabelPosition.BottomLeftOutside]: ({ startX, height, offsetX, offsetY }) => ({
    x: startX - offsetX,
    y: height - offsetY,
    textAnchor: "start",
    dominantBaseline: "text-after-edge"
  }),
  [PlotbandLabelPosition.BottomLeftInside]: ({ startX, height, offsetX, offsetY }) => ({
    x: startX + offsetX,
    y: height - offsetY,
    textAnchor: "start",
    dominantBaseline: "text-before-edge"
  }),
  [PlotbandLabelPosition.LeftOutside]: ({ startX, height, offsetX }) => ({
    x: startX - offsetX,
    y: height / 2,
    textAnchor: "middle",
    dominantBaseline: "text-after-edge"
  }),
  [PlotbandLabelPosition.LeftInside]: ({ startX, height, offsetX }) => ({
    x: startX + offsetX,
    y: height / 2,
    textAnchor: "middle",
    dominantBaseline: "text-before-edge"
  })
};
var HORIZONTAL_Y = {
  [PlotbandLabelPosition.TopLeftOutside]: ({ startY, offsetX, offsetY }) => ({
    x: offsetX,
    y: startY - offsetY,
    textAnchor: "start",
    dominantBaseline: "text-after-edge"
  }),
  [PlotbandLabelPosition.TopLeftInside]: ({ startY, offsetX, offsetY }) => ({
    x: offsetX,
    y: startY + offsetY,
    textAnchor: "start",
    dominantBaseline: "text-before-edge"
  }),
  [PlotbandLabelPosition.TopOutside]: ({ startX, width, startY, offsetY }) => ({
    x: startX + width / 2,
    y: startY - offsetY,
    textAnchor: "middle",
    dominantBaseline: "text-after-edge"
  }),
  [PlotbandLabelPosition.TopInside]: ({ startX, width, startY, offsetY }) => ({
    x: startX + width / 2,
    y: startY + offsetY,
    textAnchor: "middle",
    dominantBaseline: "text-before-edge"
  }),
  [PlotbandLabelPosition.TopRightOutside]: ({ startY, width, offsetX, offsetY }) => ({
    x: width - offsetX,
    y: startY - offsetY,
    textAnchor: "end",
    dominantBaseline: "text-after-edge"
  }),
  [PlotbandLabelPosition.TopRightInside]: ({ startY, width, offsetX, offsetY }) => ({
    x: width - offsetX,
    y: startY + offsetY,
    textAnchor: "end",
    dominantBaseline: "text-before-edge"
  }),
  [PlotbandLabelPosition.RightOutside]: ({ startY, height, width, offsetX }) => ({
    x: width - offsetX,
    y: startY + height / 2,
    textAnchor: "end",
    dominantBaseline: "middle"
  }),
  [PlotbandLabelPosition.RightInside]: ({ startY, height, width, offsetX }) => ({
    x: width - offsetX,
    y: startY + height / 2,
    textAnchor: "end",
    dominantBaseline: "middle"
  }),
  [PlotbandLabelPosition.BottomRightOutside]: ({ startY, height, width, offsetX, offsetY }) => ({
    x: width - offsetX,
    y: startY + height + offsetY,
    textAnchor: "end",
    dominantBaseline: "text-before-edge"
  }),
  [PlotbandLabelPosition.BottomRightInside]: ({ startY, height, width, offsetX, offsetY }) => ({
    x: width - offsetX,
    y: startY + height - offsetY,
    textAnchor: "end",
    dominantBaseline: "text-after-edge"
  }),
  [PlotbandLabelPosition.BottomOutside]: ({ startX, width, startY, height, offsetY }) => ({
    x: startX + width / 2,
    y: startY + height + offsetY,
    textAnchor: "middle",
    dominantBaseline: "text-before-edge"
  }),
  [PlotbandLabelPosition.BottomInside]: ({ startX, width, startY, height, offsetY }) => ({
    x: startX + width / 2,
    y: startY + height - offsetY,
    textAnchor: "middle",
    dominantBaseline: "text-after-edge"
  }),
  [PlotbandLabelPosition.BottomLeftOutside]: ({ startY, height, offsetX, offsetY }) => ({
    x: offsetX,
    y: startY + height + offsetY,
    textAnchor: "start",
    dominantBaseline: "text-before-edge"
  }),
  [PlotbandLabelPosition.BottomLeftInside]: ({ startY, height, offsetX, offsetY }) => ({
    x: offsetX,
    y: startY + height - offsetY,
    textAnchor: "start",
    dominantBaseline: "text-after-edge"
  }),
  [PlotbandLabelPosition.LeftOutside]: ({ startY, height, offsetX }) => ({
    x: offsetX,
    y: startY + height / 2,
    textAnchor: "start",
    dominantBaseline: "middle"
  }),
  [PlotbandLabelPosition.LeftInside]: ({ startY, height, offsetX }) => ({
    x: offsetX,
    y: startY + height / 2,
    textAnchor: "start",
    dominantBaseline: "middle"
  })
};
var VERTICAL_Y = {
  [PlotbandLabelPosition.TopLeftOutside]: ({ startY, offsetX, offsetY }) => ({
    x: offsetX,
    y: startY - offsetY,
    textAnchor: "start",
    dominantBaseline: "text-after-edge",
    rotation: -90
  }),
  [PlotbandLabelPosition.TopLeftInside]: ({ startY, offsetX, offsetY }) => ({
    x: offsetX,
    y: startY + offsetY,
    textAnchor: "end",
    dominantBaseline: "text-before-edge",
    rotation: -90
  }),
  [PlotbandLabelPosition.TopOutside]: ({ startX, width, startY, offsetY }) => ({
    x: startX + width / 2,
    y: startY - offsetY,
    textAnchor: "end",
    dominantBaseline: "middle",
    rotation: -90
  }),
  [PlotbandLabelPosition.TopInside]: ({ startX, width, startY, offsetY }) => ({
    x: startX + width / 2,
    y: startY + offsetY,
    textAnchor: "end",
    dominantBaseline: "middle",
    rotation: -90
  }),
  [PlotbandLabelPosition.TopRightOutside]: ({ startY, width, offsetX, offsetY }) => ({
    x: width - offsetX,
    y: startY - offsetY,
    textAnchor: "start",
    dominantBaseline: "text-after-edge",
    rotation: -90
  }),
  [PlotbandLabelPosition.TopRightInside]: ({ startY, width, offsetX, offsetY }) => ({
    x: width - offsetX,
    y: startY + offsetY,
    textAnchor: "end",
    dominantBaseline: "text-after-edge",
    rotation: -90
  }),
  [PlotbandLabelPosition.RightOutside]: ({ startY, height, width, offsetX }) => ({
    x: width - offsetX,
    y: startY + height / 2,
    textAnchor: "middle",
    dominantBaseline: "text-after-edge",
    rotation: -90
  }),
  [PlotbandLabelPosition.RightInside]: ({ startY, height, width, offsetX }) => ({
    x: width - offsetX,
    y: startY + height / 2,
    textAnchor: "middle",
    dominantBaseline: "text-after-edge",
    rotation: -90
  }),
  [PlotbandLabelPosition.BottomRightOutside]: ({ startY, height, width, offsetX, offsetY }) => ({
    x: width - offsetX,
    y: startY + height + offsetY,
    textAnchor: "start",
    dominantBaseline: "text-before-edge",
    rotation: -90
  }),
  [PlotbandLabelPosition.BottomRightInside]: ({ startY, height, width, offsetX, offsetY }) => ({
    x: width - offsetX,
    y: startY + height - offsetY,
    textAnchor: "start",
    dominantBaseline: "text-after-edge",
    rotation: -90
  }),
  [PlotbandLabelPosition.BottomOutside]: ({ startX, width, startY, height, offsetY }) => ({
    x: startX + width / 2,
    y: startY + height + offsetY,
    textAnchor: "start",
    dominantBaseline: "middle",
    rotation: -90
  }),
  [PlotbandLabelPosition.BottomInside]: ({ startX, width, startY, height, offsetY }) => ({
    x: startX + width / 2,
    y: startY + height - offsetY,
    textAnchor: "start",
    dominantBaseline: "middle",
    rotation: -90
  }),
  [PlotbandLabelPosition.BottomLeftOutside]: ({ startY, height, offsetX, offsetY }) => ({
    x: offsetX,
    y: startY + height + offsetY,
    textAnchor: "end",
    dominantBaseline: "text-before-edge",
    rotation: -90
  }),
  [PlotbandLabelPosition.BottomLeftInside]: ({ startY, height, offsetX, offsetY }) => ({
    x: offsetX,
    y: startY + height - offsetY,
    textAnchor: "start",
    dominantBaseline: "text-before-edge",
    rotation: -90
  }),
  [PlotbandLabelPosition.LeftOutside]: ({ startY, height, offsetX }) => ({
    x: offsetX,
    y: startY + height / 2,
    textAnchor: "middle",
    dominantBaseline: "text-before-edge",
    rotation: -90
  }),
  [PlotbandLabelPosition.LeftInside]: ({ startY, height, offsetX }) => ({
    x: offsetX,
    y: startY + height / 2,
    textAnchor: "middle",
    dominantBaseline: "text-before-edge",
    rotation: -90
  })
};

// node_modules/@unovis/ts/components/plotband/config.js
var PlotbandDefaultConfig = Object.assign(Object.assign({}, XYComponentDefaultConfig), { axis: AxisType.Y, from: 0, to: 0, color: void 0, duration: 300, labelPosition: PlotbandLabelPosition.TopLeftOutside, labelOffsetX: 14, labelOffsetY: 14, labelOrientation: PlotbandLabelOrientation.Horizontal });

// node_modules/@unovis/ts/components/plotband/style.js
var style_exports23 = {};
__export(style_exports23, {
  globalStyles: () => globalStyles10,
  label: () => label11,
  plotband: () => plotband,
  root: () => root26
});
var globalStyles10 = injectGlobal`
  :root {
    --vis-plotband-color: rgba(255, 255, 90, 0.2);
    --vis-plotband-label-font-size: 12px;
    --vis-plotband-label-color: #000;

    --vis-dark-plotband-color: rgba(220, 220, 90, 0.2);
    --vis-dark-plotband-label-color: #e5e9f7;
  }

  body.theme-dark {
    --vis-plotband-color: var(--vis-dark-plotband-color);
    --vis-plotband-label-color: var(--vis-dark-tooltip-text-color);
  }
`;
var root26 = css`
  label: plotband-component;
`;
var plotband = css`
  label: plotband-area;
  transition: opacity 200ms;
  cursor: var(--vis-line-cursor);
  fill: var(--vis-plotband-color);
`;
var label11 = css`
  label: plotline-label;

  user-select: none;
  text-anchor: middle;
  pointer-events: none;
  font-size: var(--vis-plotband-label-font-size);
  fill: var(--vis-plotband-label-color);
`;

// node_modules/@unovis/ts/components/plotband/index.js
var Plotband = class extends XYComponentCore {
  constructor(config) {
    super();
    this._defaultConfig = PlotbandDefaultConfig;
    if (config)
      this.setConfig(config);
    this.plotband = this.g.append("rect").attr("class", plotband);
    this.label = this.g.append("text").attr("class", label11);
  }
  _render(customDuration) {
    super._render(customDuration);
    const { config } = this;
    this.from = config.from;
    this.to = config.to;
    this.plotband.style("fill", config.color);
    if (this.from == null || this.to == null)
      return;
    let x21 = 0;
    let y25 = 0;
    let width = 0;
    let height = 0;
    if (config.axis === "y") {
      const y110 = this.yScale(this.from);
      const y26 = this.yScale(this.to);
      y25 = Math.min(y110, y26);
      height = Math.abs(y110 - y26);
      x21 = 0;
      width = this._width;
    } else {
      const x110 = this.xScale(this.from);
      const x22 = this.xScale(this.to);
      x21 = Math.min(x110, x22);
      width = Math.abs(x110 - x22);
      y25 = 0;
      height = this._height;
    }
    smartTransition(this.plotband, config.duration).attr("x", x21).attr("y", y25).attr("width", width).attr("height", height);
    if (config.labelText) {
      const labelProps = this.computeLabel(config.axis, x21, y25, width, height, config.labelPosition, config.labelOffsetX, config.labelOffsetY, config.labelOrientation);
      this.label.attr("dominant-baseline", labelProps.dominantBaseline).attr("transform", labelProps.transform).style("text-anchor", labelProps.textAnchor).style("fill", config.labelColor).style("font-size", config.labelSize ? `${config.labelSize}px` : void 0);
      smartTransition(this.label, config.duration).text(config.labelText).attr("x", labelProps.x).attr("y", labelProps.y);
    }
    smartTransition(this.plotband.exit()).style("opacity", 0).remove();
  }
  computeLabel(axis3, startX, startY, width, height, position, offsetX, offsetY, orientation) {
    const isVertical = orientation === "vertical";
    const rotation = isVertical ? -90 : 0;
    const args = { startX, startY, width, height, offsetX, offsetY };
    let layoutPartial;
    if (axis3 === AxisType.X) {
      layoutPartial = (isVertical ? VERTICAL_X : HORIZONTAL_X)[position](args);
    } else {
      layoutPartial = (isVertical ? VERTICAL_Y : HORIZONTAL_Y)[position](args);
    }
    const { x: x21, y: y25, textAnchor, dominantBaseline } = layoutPartial;
    const transform2 = rotation !== 0 ? `rotate(${rotation}, ${x21}, ${y25})` : "";
    return { x: x21, y: y25, rotation, textAnchor, transform: transform2, dominantBaseline };
  }
};
Plotband.selectors = style_exports23;

// node_modules/@unovis/ts/components/plotline/constants.js
var LINE_STYLE = {
  solid: "none",
  shortDash: "6,2",
  shortDot: "2,2",
  shortDashDot: "6,2,2,2",
  shortDashDotDot: "6,2,2,2,2,2",
  dot: "2,6",
  dash: "8,6",
  longDash: "16,6",
  dashDot: "8,6,2,6",
  longDashDot: "16,6,2,6",
  longDashDotDot: "16,6,2,6,2,6"
};
var HORIZONTAL_X2 = {
  [PlotlineLabelPosition.TopLeft]: ({ width, offsetX, offsetY }) => ({ x: width - offsetX, y: offsetY, textAnchor: "end", dominantBaseline: "text-before-edge" }),
  [PlotlineLabelPosition.Top]: ({ width, offsetY }) => ({ x: width, y: offsetY, textAnchor: "middle", dominantBaseline: "text-before-edge" }),
  [PlotlineLabelPosition.TopRight]: ({ width, offsetX, offsetY }) => ({ x: width + offsetX, y: offsetY, textAnchor: "start", dominantBaseline: "text-before-edge" }),
  [PlotlineLabelPosition.Right]: ({ width, height, offsetX }) => ({ x: width + offsetX, y: height / 2, textAnchor: "start", dominantBaseline: "middle" }),
  [PlotlineLabelPosition.BottomRight]: ({ width, height, offsetX, offsetY }) => ({ x: width + offsetX, y: height - offsetY, textAnchor: "start", dominantBaseline: "text-after-edge" }),
  [PlotlineLabelPosition.Bottom]: ({ width, height, offsetY }) => ({ x: width, y: height - offsetY, textAnchor: "middle", dominantBaseline: "text-after-edge" }),
  [PlotlineLabelPosition.BottomLeft]: ({ width, height, offsetX, offsetY }) => ({ x: width - offsetX, y: height - offsetY, textAnchor: "end", dominantBaseline: "text-after-edge" }),
  [PlotlineLabelPosition.Left]: ({ width, height, offsetX }) => ({ x: width - offsetX, y: height / 2, textAnchor: "end", dominantBaseline: "middle" })
};
var VERTICAL_X2 = {
  [PlotlineLabelPosition.TopLeft]: ({ width, offsetX, offsetY }) => ({ x: width - offsetX, y: offsetY, textAnchor: "end", dominantBaseline: "text-after-edge" }),
  [PlotlineLabelPosition.Top]: ({ width, offsetY }) => ({ x: width, y: offsetY, textAnchor: "end", dominantBaseline: "middle" }),
  [PlotlineLabelPosition.TopRight]: ({ width, offsetX, offsetY }) => ({ x: width + offsetX, y: offsetY, textAnchor: "end", dominantBaseline: "text-before-edge" }),
  [PlotlineLabelPosition.Right]: ({ width, height, offsetX }) => ({ x: width + offsetX, y: height / 2, textAnchor: "middle", dominantBaseline: "text-before-edge" }),
  [PlotlineLabelPosition.BottomRight]: ({ width, height, offsetX, offsetY }) => ({ x: width + offsetX, y: height - offsetY, textAnchor: "start", dominantBaseline: "text-before-edge" }),
  [PlotlineLabelPosition.Bottom]: ({ width, height, offsetY }) => ({ x: width, y: height - offsetY, textAnchor: "start", dominantBaseline: "middle" }),
  [PlotlineLabelPosition.BottomLeft]: ({ width, height, offsetX, offsetY }) => ({ x: width - offsetX, y: height - offsetY, textAnchor: "start", dominantBaseline: "text-after-edge" }),
  [PlotlineLabelPosition.Left]: ({ width, height, offsetX }) => ({ x: width - offsetX, y: height / 2, textAnchor: "middle", dominantBaseline: "text-after-edge" })
};
var HORIZONTAL_Y2 = {
  [PlotlineLabelPosition.TopLeft]: ({ offsetX, height, offsetY }) => ({ x: offsetX, y: height - offsetY, textAnchor: "start", dominantBaseline: "text-after-edge" }),
  [PlotlineLabelPosition.Top]: ({ width, height, offsetY }) => ({ x: width / 2, y: height - offsetY, textAnchor: "middle", dominantBaseline: "text-after-edge" }),
  [PlotlineLabelPosition.TopRight]: ({ width, offsetX, height, offsetY }) => ({ x: width - offsetX, y: height - offsetY, textAnchor: "end", dominantBaseline: "text-after-edge" }),
  [PlotlineLabelPosition.Right]: ({ width, offsetX, height }) => ({ x: width - offsetX, y: height, textAnchor: "end", dominantBaseline: "middle" }),
  [PlotlineLabelPosition.BottomRight]: ({ width, offsetX, height, offsetY }) => ({ x: width - offsetX, y: height + offsetY, textAnchor: "end", dominantBaseline: "text-before-edge" }),
  [PlotlineLabelPosition.Bottom]: ({ width, height, offsetY }) => ({ x: width / 2, y: height + offsetY, textAnchor: "middle", dominantBaseline: "text-before-edge" }),
  [PlotlineLabelPosition.BottomLeft]: ({ offsetX, height, offsetY }) => ({ x: offsetX, y: height + offsetY, textAnchor: "start", dominantBaseline: "text-before-edge" }),
  [PlotlineLabelPosition.Left]: ({ offsetX, height }) => ({ x: offsetX, y: height, textAnchor: "start", dominantBaseline: "middle" })
};
var VERTICAL_Y2 = {
  [PlotlineLabelPosition.TopLeft]: ({ offsetX, height, offsetY }) => ({ x: offsetX, y: height - offsetY, textAnchor: "start", dominantBaseline: "text-before-edge" }),
  [PlotlineLabelPosition.Top]: ({ width, height, offsetY }) => ({ x: width / 2, y: height - offsetY, textAnchor: "start", dominantBaseline: "central" }),
  [PlotlineLabelPosition.TopRight]: ({ width, offsetX, height, offsetY }) => ({ x: width - offsetX, y: height - offsetY, textAnchor: "start", dominantBaseline: "text-after-edge" }),
  [PlotlineLabelPosition.Right]: ({ width, offsetX, height }) => ({ x: width - offsetX, y: height, textAnchor: "middle", dominantBaseline: "text-after-edge" }),
  [PlotlineLabelPosition.BottomRight]: ({ width, offsetX, height, offsetY }) => ({ x: width - offsetX, y: height + offsetY, textAnchor: "end", dominantBaseline: "text-after-edge" }),
  [PlotlineLabelPosition.Bottom]: ({ width, height, offsetY }) => ({ x: width / 2, y: height + offsetY, textAnchor: "end", dominantBaseline: "central" }),
  [PlotlineLabelPosition.BottomLeft]: ({ offsetX, height, offsetY }) => ({ x: offsetX, y: height + offsetY, textAnchor: "end", dominantBaseline: "text-before-edge" }),
  [PlotlineLabelPosition.Left]: ({ offsetX, height }) => ({ x: offsetX, y: height, textAnchor: "middle", dominantBaseline: "text-before-edge" })
};

// node_modules/@unovis/ts/components/plotline/config.js
var PlotlineDefaultConfig = Object.assign(Object.assign({}, XYComponentDefaultConfig), { lineWidth: 2, axis: AxisType.Y, value: 0, duration: 300, color: void 0, lineStyle: PlotlineLineStylePresets.Solid, labelPosition: PlotlineLabelPosition.TopRight, labelOffsetX: 14, labelOffsetY: 14, labelOrientation: PlotlineLabelOrientation.Horizontal });

// node_modules/@unovis/ts/components/plotline/style.js
var style_exports24 = {};
__export(style_exports24, {
  globalStyles: () => globalStyles11,
  label: () => label12,
  plotline: () => plotline,
  root: () => root27
});
var globalStyles11 = injectGlobal`
  :root {
    --vis-plotline-color: rgb(226, 32, 58);
    --vis-plotline-width: 2;
    --vis-plotline-dasharray: none;
    --vis-plotline-stroke-dashoffset: 0;
    --vis-plotline-label-font-size: 12px;
    --vis-plotline-label-color: #000;

    --vis-dark-plotline-label-color: #e5e9f7;
  }

  body.theme-dark {
    --vis-plotline-label-color: var(--vis-dark-tooltip-text-color);
  }
`;
var root27 = css`
  label: plotline-component;
`;
var plotline = css`
  label: plotline;
  transition: opacity 200ms;
  stroke-linecap: round;
  stroke-linejoin: round;
  stroke: var(--vis-plotline-color);
  stroke-width: var(--vis-plotline-width);
  stroke-dasharray: var(--vis-plotline-dasharray);
  stroke-dashoffset: var(--vis-plotline-stroke-dashoffset);
`;
var label12 = css`
  label: plotline-label;
  text-anchor: middle;
  /* dominant-baseline: middle; */
  pointer-events: none;
  font-size: var(--vis-plotline-label-font-size);
  fill: var(--vis-plotline-label-color);
`;

// node_modules/@unovis/ts/components/plotline/index.js
var Plotline = class extends XYComponentCore {
  constructor(config) {
    super();
    this._defaultConfig = PlotlineDefaultConfig;
    if (config)
      this.setConfig(config);
    this.plotline = this.g.append("line").attr("class", plotline);
    this.label = this.g.append("text").attr("class", label12);
  }
  _render(customDuration) {
    super._render(customDuration);
    const { config } = this;
    this.value = config.value;
    let strokeDashArray;
    if (typeof (config === null || config === void 0 ? void 0 : config.lineStyle) === "string") {
      strokeDashArray = LINE_STYLE[config.lineStyle];
    } else if (Array.isArray(config.lineStyle)) {
      strokeDashArray = config.lineStyle.join(",");
    } else {
      strokeDashArray = "none";
    }
    this.value = config.value;
    this.plotline.attr("stroke-opacity", 1).style("stroke-width", config.lineWidth).style("stroke-dasharray", strokeDashArray).style("stroke", config.color);
    let x110 = 0;
    let x22 = 0;
    let y110 = 0;
    let y25 = 0;
    if (config.axis === AxisType.Y) {
      y110 = this.yScale(this.value);
      y25 = this.yScale(this.value);
      x110 = 0;
      x22 = this._width;
    } else {
      y110 = 0;
      y25 = this._height;
      x110 = this.xScale(this.value);
      x22 = this.xScale(this.value);
    }
    smartTransition(this.plotline, config.duration).attr("x1", x110).attr("x2", x22).attr("y1", y110).attr("y2", y25);
    if (config.labelText) {
      const labelProps = this.computeLabel(config.axis, x22, y25, config.labelPosition, config.labelOffsetX, config.labelOffsetY, config.labelOrientation);
      this.label.text(config.labelText).attr("transform", labelProps.transform).attr("dominant-baseline", labelProps.dominantBaseline).style("fill", config.labelColor).style("text-anchor", labelProps.textAnchor).style("font-size", config.labelSize ? `${config.labelSize}px` : void 0);
      smartTransition(this.label, config.duration).attr("x", labelProps.x).attr("y", labelProps.y);
    }
    smartTransition(this.plotline.exit()).style("opacity", 0).remove();
  }
  computeLabel(axis3, width, height, position, offsetX, offsetY, orientation) {
    const isVertical = orientation === PlotlineLabelOrientation.Vertical;
    const rotation = isVertical ? -90 : 0;
    let layout;
    if (axis3 === AxisType.X) {
      const map5 = isVertical ? VERTICAL_X2 : HORIZONTAL_X2;
      layout = map5[position]({ width, height, offsetX, offsetY });
    } else {
      const map5 = isVertical ? VERTICAL_Y2 : HORIZONTAL_Y2;
      layout = map5[position]({ width, height, offsetX, offsetY });
    }
    const transform2 = rotation ? `rotate(${rotation}, ${layout.x}, ${layout.y})` : "";
    return Object.assign(Object.assign({}, layout), {
      rotation,
      transform: transform2
    });
  }
};
Plotline.selectors = style_exports24;

// node_modules/@unovis/ts/components/treemap/config.js
var TreemapDefaultConfig = Object.assign(Object.assign({}, ComponentDefaultConfig), { id: (d18, i8) => {
  var _a;
  return (_a = d18.id) !== null && _a !== void 0 ? _a : i8;
}, value: void 0, tileColor: void 0, layers: [], tilePadding: 2, tilePaddingTop: void 0, labelInternalNodes: false, labelOffsetX: 4, labelOffsetY: 4, tileBorderRadius: 2, tileBorderRadiusFactor: 1 / 8, enableLightnessVariance: false, enableTileLabelFontSizeVariation: true, tileLabelSmallFontSize: 8, tileLabelMediumFontSize: 12, tileLabelLargeFontSize: 22, showTileClickAffordance: false, lightnessVariationAmount: 0.08, minTileSizeForLabel: 20, tileLabel: void 0 });

// node_modules/@unovis/ts/components/treemap/style.js
var style_exports25 = {};
__export(style_exports25, {
  clickableTile: () => clickableTile,
  internalLabel: () => internalLabel,
  label: () => label13,
  labelGroup: () => labelGroup3,
  root: () => root28,
  tile: () => tile,
  tileForeground: () => tileForeground,
  tileGroup: () => tileGroup,
  tiles: () => tiles,
  variables: () => variables20
});
var cssVarDefaults7 = {
  "--vis-treemap-tile-stroke-color": "#fff",
  "--vis-treemap-tile-stroke-width": "2px",
  "--vis-treemap-tile-hover-stroke-color": "#fff",
  "--vis-treemap-tile-hover-stroke-opacity": 0,
  "--vis-treemap-tile-fill-color": "#B9BEC3",
  "--vis-treemap-tile-background-color": "#fff",
  "--vis-treemap-tile-cursor": "default",
  "--vis-treemap-label-text-color": "#000",
  "--vis-treemap-label-font-size": "12px",
  /* Label opacity */
  "--vis-treemap-label-opacity": 0.8,
  "--vis-treemap-label-font-weight": "normal",
  /* Dark Theme */
  "--vis-dark-treemap-tile-stroke-color": "#2c2c2c",
  "--vis-dark-treemap-tile-fill-color": "#5b5f6d",
  "--vis-dark-treemap-label-text-color": "#5b5f6d"
};
var root28 = css`
  label: treemap-component;
`;
var variables20 = getCssVarNames(cssVarDefaults7);
injectGlobalCssVariables(cssVarDefaults7, root28);
var tiles = css`
  label: g-tiles;
`;
var tileGroup = css`
  label: tile-group;
`;
var tile = css`
  label: tile;
  stroke: var(${variables20.treemapTileHoverStrokeColor});
  stroke-opacity: 0;

  &:hover {
    stroke-opacity: var(--vis-treemap-tile-hover-stroke-opacity);
  }
`;
var clickableTile = css`
  label: clickable-tile;
  cursor: pointer;
`;
var tileForeground = css`
  label: tile-foreground;
`;
var label13 = css`
  label: label;
  text-anchor: start;
  dominant-baseline: hanging;
  user-select: none;
  pointer-events: none;
  font-size: var(--vis-treemap-label-font-size);
  opacity: var(--vis-treemap-label-opacity);
  fill: var(--vis-treemap-label-text-color);
  font-weight: var(--vis-treemap-label-font-weight);
`;
var internalLabel = css`
  font-weight: 500;
`;
var labelGroup3 = css`
  label: label-group;
`;

// node_modules/@unovis/ts/components/treemap/index.js
var Treemap = class extends ComponentCore {
  constructor(config) {
    super();
    this._defaultConfig = TreemapDefaultConfig;
    this.config = this._defaultConfig;
    this.datamodel = new SeriesDataModel();
    if (config)
      this.setConfig(config);
    this.tiles = this.g.append("g").attr("class", tiles);
  }
  /** Default number format for tile labels. */
  _defaultNumberFormat(value2) {
    return `${value2}`;
  }
  _isTileLargeEnough(d18) {
    const w14 = d18.x1 - d18.x0;
    const h17 = d18.y1 - d18.y0;
    return w14 >= this.config.minTileSizeForLabel && h17 >= this.config.minTileSizeForLabel;
  }
  _getTileLightness(node4, siblings) {
    const [minValue, maxValue] = extent(siblings, (d18) => d18.value);
    if (minValue === maxValue || !node4.value)
      return 0;
    return this.config.lightnessVariationAmount * ((maxValue - node4.value) / (maxValue - minValue));
  }
  _render(customDuration) {
    var _a, _b;
    super._render(customDuration);
    const { config, datamodel: { data }, _width, _height } = this;
    const { numberFormat } = config;
    const formatNumber = numberFormat !== null && numberFormat !== void 0 ? numberFormat : this._defaultNumberFormat.bind(this);
    const duration = isNumber(customDuration) ? customDuration : config.duration;
    if (!((_a = config.layers) === null || _a === void 0 ? void 0 : _a.length)) {
      console.warn("Unovis | Treemap: No layers defined");
      return;
    }
    const layerAccessors = config.layers.map((layerAccessor) => {
      return (i8) => getString(data[i8], layerAccessor, i8);
    });
    const nestedData = group(data.keys(), ...layerAccessors);
    const rootNode = hierarchy(nestedData);
    if (config.value) {
      rootNode.sum((index3) => typeof index3 === "number" && getNumber(data[index3], config.value, index3));
    } else {
      rootNode.count();
    }
    rootNode.each((node4) => {
      if (!node4.children && node4.parent) {
        node4.parent.children = null;
      }
    });
    const treemapLayout = treemap_default().size([_width, _height]).round(true).padding(config.tilePadding);
    if (this.config.tilePaddingTop !== void 0) {
      treemapLayout.paddingTop((d18) => d18.parent ? config.tilePaddingTop : 0);
    }
    const treemapData = treemapLayout(rootNode);
    let nodeId = 0;
    treemapData.each((node4) => {
      const n = node4;
      node4._id = `node-${nodeId++}`;
      const treemapDatum = {
        key: n.data[0]
      };
      const isLeafNode = !n.children;
      if (isLeafNode) {
        treemapDatum.index = n.data[1][0];
        treemapDatum.datum = data[treemapDatum.index];
      }
      node4.data = treemapDatum;
    });
    const descendants = treemapData.descendants();
    const maxDepth2 = max(descendants, (d18) => d18.depth);
    const brightnessIncrease = linear3().domain([1, maxDepth2]).range([0, 1]);
    const leafValues = descendants.filter((d18) => !d18.children).map((d18) => d18.value);
    const maxLeafValue = Math.sqrt(max(leafValues)) || 0;
    const fontSizeScale = threshold().domain([
      maxLeafValue / 3,
      maxLeafValue * 2 / 3
      // Second third of the max value
    ]).range([
      config.tileLabelSmallFontSize,
      config.tileLabelMediumFontSize,
      config.tileLabelLargeFontSize
    ]);
    treemapData.eachBefore((node4) => {
      var _a2, _b2, _c;
      let color2 = config.tileColor ? getColor(node4, config.tileColor) : getColor(node4, void 0, (_b2 = (_a2 = node4.parent) === null || _a2 === void 0 ? void 0 : _a2.children) === null || _b2 === void 0 ? void 0 : _b2.indexOf(node4), node4.depth !== 1);
      color2 = color2 !== null && color2 !== void 0 ? color2 : (_c = node4.parent) === null || _c === void 0 ? void 0 : _c._fill;
      const hexColor = color2 ? getHexValue(color2, this.g.node()) : null;
      if (hexColor) {
        const hslColor = hsl(hexColor);
        if (config.enableLightnessVariance && !node4.children && node4.parent) {
          const siblings = node4.parent.children;
          const lightnessAdjustment = this._getTileLightness(node4, siblings);
          hslColor.l = Math.min(1, hslColor.l + lightnessAdjustment);
        }
        node4._fill = brighter2(hslColor.toString(), brightnessIncrease(node4.depth));
      } else {
        node4._fill = null;
      }
    });
    const visibleNodes = descendants.filter((d18) => d18.depth > 0);
    const tiles2 = this.tiles.selectAll(`g.${tileGroup}`).data(visibleNodes, (d18) => `${d18.data.key}-${d18.depth}`);
    const tilesEnter = tiles2.enter().append("g").attr("class", tileGroup);
    const rx = (d18) => Math.min(config.tileBorderRadius, (d18.x1 - d18.x0) * config.tileBorderRadiusFactor);
    tilesEnter.append("rect").classed(tile, true).classed(clickableTile, (d18) => config.showTileClickAffordance && !d18.children).attr("rx", rx).attr("ry", rx).attr("x", (d18) => d18.x0).attr("y", (d18) => d18.y0).attr("width", (d18) => d18.x1 - d18.x0).attr("height", (d18) => d18.y1 - d18.y0).style("fill", (d18) => {
      var _a2;
      return (_a2 = d18._fill) !== null && _a2 !== void 0 ? _a2 : getColor(d18, config.tileColor);
    }).style("opacity", 0).style("cursor", config.showTileClickAffordance ? (d18) => !d18.children ? "pointer" : null : null);
    const mergedTiles = tiles2.merge(tilesEnter);
    smartTransition(mergedTiles.select(`rect.${tile}`), duration).style("fill", (d18) => {
      var _a2;
      return (_a2 = d18._fill) !== null && _a2 !== void 0 ? _a2 : getColor(d18, config.tileColor);
    }).style("opacity", 1).attr("x", (d18) => d18.x0).attr("y", (d18) => d18.y0).attr("width", (d18) => d18.x1 - d18.x0).attr("height", (d18) => d18.y1 - d18.y0);
    let svg = this.g.node();
    while (svg && !(svg instanceof SVGSVGElement))
      svg = svg.parentElement;
    const defs = svg ? select_default2(svg).select("defs").empty() ? select_default2(svg).append("defs") : select_default2(svg).select("defs") : null;
    if (!defs)
      return;
    const defsSelection = defs;
    const clipPaths = defsSelection.selectAll("clipPath").data(visibleNodes, (d18) => d18._id);
    clipPaths.enter().append("clipPath").attr("id", (d18) => `clip-${d18._id}`).append("rect").attr("x", (d18) => d18.x0).attr("y", (d18) => d18.y0).attr("width", (d18) => Math.max(0.1, d18.x1 - d18.x0)).attr("height", (d18) => Math.max(0.1, d18.y1 - d18.y0)).attr("rx", rx).attr("ry", rx);
    clipPaths.exit().remove();
    tilesEnter.append("g").attr("class", labelGroup3).attr("transform", (d18) => `translate(${d18.x0 + config.labelOffsetX},${d18.y0 + config.labelOffsetY})`).append("text").attr("class", label13).attr("x", 0).attr("y", 0).style("opacity", 0);
    const getTileLabel = (_b = config.tileLabel) !== null && _b !== void 0 ? _b : ((d18) => `${d18.data.key}: ${formatNumber(d18.value)}`);
    const textSelection = mergedTiles.selectAll(`g.${labelGroup3} text`);
    textSelection.text((d18) => getTileLabel(d18)).style("font-size", function(d18) {
      var _a2;
      const sqrtVal = Math.sqrt((_a2 = d18.value) !== null && _a2 !== void 0 ? _a2 : 0);
      return config.enableTileLabelFontSizeVariation && !d18.children ? `${fontSizeScale(sqrtVal)}px` : `${fontSizeScale.range()[1]}px`;
    }).attr("dominant-baseline", "middle");
    textSelection.each((d18, i8, nodes4) => {
      var _a2;
      const text = select_default2(nodes4[i8]);
      const tileWidth = d18.x1 - d18.x0 - ((_a2 = config.labelOffsetX) !== null && _a2 !== void 0 ? _a2 : 0) * 2;
      const fullLabel = text.text();
      let fontSize = parseFloat(text.style("font-size"));
      if (!fontSize) {
        fontSize = parseFloat(window.getComputedStyle(nodes4[i8]).fontSize);
      }
      trimSVGText(text, tileWidth, TrimMode.End, true, fontSize);
      text.attr("title", fullLabel);
      text.selectAll("tspan").attr("dominant-baseline", "middle");
    });
    smartTransition(mergedTiles.select(`g.${labelGroup3}`), duration).attr("transform", (d18) => `translate(${d18.x0 + config.labelOffsetX},${d18.y0 + config.labelOffsetY})`);
    smartTransition(mergedTiles.select(`g.${labelGroup3} text`), duration).style("opacity", 1);
    mergedTiles.select(`text.${label13}`).style("display", (d18) => {
      const isAllowedNode = config.labelInternalNodes ? true : !d18.children;
      return isAllowedNode && this._isTileLargeEnough(d18) ? null : "none";
    }).attr("class", (d18) => d18.children ? `${label13} ${internalLabel}` : label13);
    smartTransition(tiles2.exit(), duration).style("opacity", 0).remove();
  }
};
Treemap.selectors = style_exports25;

// node_modules/@unovis/ts/styles/sizes.js
var styleLargeSize = css`
  label: large-size;

  /* Axis */
  --vis-axis-label-font-size: 18px;
  --vis-axis-tick-label-font-size: 16px;

  /* Donut */
  --vis-donut-central-label-font-size: 20px;
  --vis-donut-central-sub-label-font-size: 16px;

  /* Graph */
  --vis-graph-node-bottom-icon-font-size: 18pt;
  --vis-graph-node-label-font-size: 12pt;
  --vis-graph-node-sublabel-font-size: 10pt;
  --vis-graph-panel-label-font-size: 14pt;

  /* LeafletMap */
  --vis-map-point-bottom-label-font-size: 14px;

  /* Legend */
  --vis-legend-label-font-size: 16px;
  --vis-legend-bullet-label-spacing: 10px;
  --vis-legend-bullet-size: 12px;

  /* Sankey */
  --vis-sankey-node-label-font-size: 16px;
  --vis-sankey-node-sublabel-font-size: 14px;
  --vis-sankey-icon-size: 28px;

  /* Scatter */
  --vis-scatter-point-label-text-font-size: 16px;

  /* Timeline */
  --vis-timeline-label-font-size: 18px;

  /* TopoJSONMap */
  --vis-map-point-label-font-size: 16px;

  /* XYLabels */
  --vis-xy-label-font-size: 16px;
  --vis-xy-label-cluster-font-size: 18px;

  /* Override leaflet.css */
  .leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out  {
    font-size: 28px;
  }
  .leaflet-control-attribution a {
    font-size: 10pt;
  }
  .leaflet-container .leaflet-control-attribution,
  .leaflet-container .leaflet-control-scale,
  .leaflet-control-scale-line {
    font-size: 14px;
  }
  `;
var styleExtraLargeSize = css`
  label: extra-large-size;

  /* Axis */
  --vis-axis-label-font-size: 28px;
  --vis-axis-tick-label-font-size: 24px;

  /* Donut */
  --vis-donut-central-label-font-size: 32px;
  --vis-donut-central-sub-label-font-size: 24px;

  /* Graph */
  --vis-graph-node-bottom-icon-font-size: 28pt;
  --vis-graph-node-label-font-size: 18pt;
  --vis-graph-node-sublabel-font-size: 16pt;
  --vis-graph-panel-label-font-size: 20pt;

  /* LeafletMap */
  --vis-map-point-bottom-label-font-size: 20px;

  /* Legend */
  --vis-legend-label-font-size: 24px;
  --vis-legend-bullet-label-spacing: 16px;
  --vis-legend-bullet-size: 18px;

  /* Sankey */
  --vis-sankey-node-label-font-size: 24px;
  --vis-sankey-node-sublabel-font-size: 20px;
  --vis-sankey-icon-size: 44px;

  /* Scatter */
  --vis-scatter-point-label-text-font-size: 24px;

  /* Timeline */
  --vis-timeline-label-font-size: 28px;

  /* TopoJSONMap */
  --vis-map-point-label-font-size: 24px;

  /* XYLabels */
  --vis-xy-label-font-size: 24px;
  --vis-xy-label-cluster-font-size: 28px;

  /* Override leaflet.css */
  .leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out  {
    font-size: 44px;
  }
  .leaflet-control-attribution a {
    font-size: 14pt;
  }
  .leaflet-container .leaflet-control-attribution,
  .leaflet-container .leaflet-control-scale,
  .leaflet-control-scale-line {
    font-size: 22px;
  }
`;

// node_modules/@unovis/vue/utils/context.js
var o = Symbol("componentAccessorKey");
var s3 = Symbol("tooltipAccessorKey");
var c3 = Symbol("crosshairAccessorKey");
var e = Symbol("axisAccessorKey");
var t = Symbol("annotationsAccessorKey");

// node_modules/@unovis/vue/utils/props.js
import { getCurrentInstance as a4, computed as u, camelize as s4 } from "vue";
function f(t4, r4) {
  return isEqual(t4, r4);
}
function m2(t4) {
  const r4 = a4(), n = r4.attrs;
  return u(() => {
    const o2 = {}, c6 = (r4 == null ? void 0 : r4.vnode.props) ?? {};
    return Object.keys(c6).forEach((e3) => {
      o2[s4(e3)] = t4[s4(e3)];
    }), { ...o2, ...n };
  });
}

// node_modules/@unovis/vue/containers/xy-container/index.js
var S = u2({
  __name: "index",
  props: {
    components: {},
    xScale: { type: [Object, Function] },
    xDomain: {},
    xDomainMinConstraint: {},
    xDomainMaxConstraint: {},
    xRange: {},
    yScale: { type: [Object, Function] },
    yDomain: {},
    yDomainMinConstraint: {},
    yDomainMaxConstraint: {},
    yRange: {},
    yDirection: {},
    xAxis: {},
    yAxis: {},
    autoMargin: { type: Boolean },
    tooltip: {},
    crosshair: {},
    preventEmptyDomain: { type: [Boolean, null] },
    scaleByDomain: { type: Boolean },
    annotations: {},
    clipPathExtend: {},
    duration: {},
    margin: {},
    padding: {},
    sizing: {},
    width: {},
    height: {},
    svgDefs: {},
    ariaLabel: {},
    data: {}
  },
  setup(d18, { expose: l7 }) {
    const c6 = d18, { data: t4 } = y3(c6), m30 = m2(c6), n = p(), e3 = v({
      components: [],
      annotations: void 0,
      crosshair: void 0,
      tooltip: void 0,
      xAxis: void 0,
      yAxis: void 0
    }), s12 = p();
    return f2(t4, () => {
      n.value && n.value.setData(t4.value, true);
    }), x3(() => {
      var o2;
      e3.components.map((i8) => i8.config), (o2 = n.value) == null || o2.updateContainer({ ...r(m30.value), ...r(e3) });
    }), h(() => {
      s12.value && (n.value = new XYContainer(s12.value, { ...r(e3) }, t4.value));
    }), D2(() => {
      var o2;
      return (o2 = n.value) == null ? void 0 : o2.destroy();
    }), a5(o, {
      data: t4,
      update: (o2) => e3.components = [...e3.components, o2],
      destroy: () => {
        var o2;
        return e3.components = (o2 = e3.components) == null ? void 0 : o2.filter((i8) => !i8.isDestroyed());
      }
    }), a5(e, {
      data: t4,
      update: (o2) => e3[`${o2.config.type}Axis`] = o2,
      destroy: (o2) => {
        e3[`${o2}Axis`] = void 0;
      }
    }), a5(c3, {
      data: t4,
      update: (o2) => e3.crosshair = o2,
      destroy: () => {
        e3.crosshair = void 0;
      }
    }), a5(s3, {
      data: t4,
      update: (o2) => e3.tooltip = o2,
      destroy: () => {
        e3.tooltip = void 0;
      }
    }), a5(t, {
      data: t4,
      update: (o2) => e3.annotations = o2,
      destroy: () => {
        e3.annotations = void 0;
      }
    }), l7({
      component: n
    }), (o2, i8) => (A6(), g("div", {
      "data-vis-xy-container": "",
      ref_key: "elRef",
      ref: s12,
      class: "unovis-xy-container"
    }, [
      C2(o2.$slots, "default")
    ], 512));
  }
});

// node_modules/@unovis/vue/containers/single-container/index.js
import { defineComponent as f3, toRefs as m3, reactive as u3, ref as v2, watchEffect as g2, watch as y4, onUnmounted as w2, provide as a6, createElementBlock as _, openBlock as h2, renderSlot as C3, toRaw as s5 } from "vue";
var b = f3({
  __name: "index",
  props: {
    component: {},
    tooltip: {},
    annotations: {},
    duration: {},
    margin: {},
    padding: {},
    sizing: {},
    width: {},
    height: {},
    svgDefs: {},
    ariaLabel: {},
    data: {}
  },
  setup(c6, { expose: d18 }) {
    const r4 = c6, { data: n } = m3(r4), l7 = m2(r4);
    let o2;
    const e3 = u3({
      component: void 0,
      tooltip: void 0,
      annotations: void 0
    }), i8 = v2(), p13 = () => {
      o2 || i8.value && e3.component && (o2 = new SingleContainer(i8.value, { ...s5(e3) }, n.value));
    };
    return g2(() => {
      var t4;
      p13(), (t4 = e3.component) == null || t4.config, o2 == null || o2.updateContainer({ ...s5(l7.value), ...s5(e3) });
    }), y4(n, () => {
      o2 ? o2.setData(n.value, true) : p13();
    }), w2(() => o2 == null ? void 0 : o2.destroy()), a6(o, {
      data: n,
      update: (t4) => e3.component = t4,
      destroy: () => e3.component = void 0
    }), a6(s3, {
      data: n,
      update: (t4) => e3.tooltip = t4,
      destroy: () => {
        e3.tooltip = void 0;
      }
    }), a6(t, {
      data: n,
      update: (t4) => e3.annotations = t4,
      destroy: () => {
        e3.annotations = void 0;
      }
    }), d18({
      component: o2
    }), (t4, B12) => (h2(), _("div", {
      "data-vis-single-container": "",
      ref_key: "elRef",
      ref: i8,
      class: "unovis-single-container"
    }, [
      C3(t4.$slots, "default")
    ], 512));
  }
});

// node_modules/@unovis/vue/components/area/index.js
import { defineComponent as m4, inject as d, computed as v3, ref as y5, onMounted as f4, nextTick as x4, onUnmounted as _2, watch as i, createElementBlock as h3, openBlock as F } from "vue";
var j = { "data-vis-component": "" };
var D3 = Area.selectors;
var P = m4({
  __name: "index",
  props: {
    color: {},
    curveType: {},
    baseline: {},
    opacity: {},
    cursor: {},
    minHeight1Px: { type: Boolean },
    minHeight: {},
    x: {},
    y: {},
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(l7, { expose: p13 }) {
    const o2 = d(o), c6 = l7, a7 = v3(() => o2.data.value ?? c6.data), n = m2(c6), t4 = y5();
    return f4(() => {
      x4(() => {
        var e3;
        t4.value = new Area(n.value), (e3 = t4.value) == null || e3.setData(a7.value), o2.update(t4.value);
      });
    }), _2(() => {
      var e3;
      (e3 = t4.value) == null || e3.destroy(), o2.destroy();
    }), i(n, (e3, r4) => {
      var s12;
      f(e3, r4) || (s12 = t4.value) == null || s12.setConfig(n.value);
    }), i(a7, () => {
      var e3;
      (e3 = t4.value) == null || e3.setData(a7.value);
    }), p13({
      component: t4
    }), (e3, r4) => (F(), h3("div", j));
  }
});

// node_modules/@unovis/vue/components/axis/index.js
import { defineComponent as d2, inject as x5, computed as m5, ref as y6, onMounted as k4, nextTick as T, onUnmounted as v4, watch as s6, createElementBlock as f5, openBlock as F2 } from "vue";
var _3 = { "data-vis-axis": "" };
var C4 = Axis.selectors;
var O = d2({
  __name: "index",
  props: {
    position: {},
    type: {},
    fullSize: { type: Boolean },
    label: {},
    labelFontSize: {},
    labelMargin: {},
    labelTextFitMode: {},
    labelTextTrimType: {},
    labelColor: {},
    gridLine: { type: Boolean },
    tickLine: { type: Boolean },
    domainLine: { type: Boolean },
    minMaxTicksOnly: { type: Boolean },
    minMaxTicksOnlyWhenWidthIsLess: {},
    tickFormat: { type: Function },
    tickValues: {},
    numTicks: {},
    tickTextFitMode: {},
    tickTextWidth: {},
    tickTextSeparator: {},
    tickTextForceWordBreak: { type: Boolean },
    tickTextTrimType: {},
    tickTextFontSize: {},
    tickTextAlign: {},
    tickTextColor: {},
    tickTextAngle: {},
    tickTextHideOverlapping: { type: Boolean },
    tickPadding: {},
    x: {},
    y: {},
    id: { type: Function },
    color: {},
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(p13, { expose: u15 }) {
    const o2 = x5(e), a7 = p13, i8 = m5(() => o2.data.value ?? a7.data), n = m2(a7), t4 = y6();
    return k4(() => {
      T(() => {
        var e3;
        t4.value = new Axis(n.value), (e3 = t4.value) == null || e3.setData(i8.value), o2.update(t4.value);
      });
    }), v4(() => {
      var e3;
      (e3 = t4.value) == null || e3.destroy(), o2.destroy(a7.type);
    }), s6(n, (e3, c6) => {
      var l7;
      f(e3, c6) || (l7 = t4.value) == null || l7.setConfig(n.value);
    }), s6(i8, () => {
      var e3;
      (e3 = t4.value) == null || e3.setData(i8.value);
    }), u15({
      component: t4
    }), (e3, c6) => (F2(), f5("div", _3));
  }
});

// node_modules/@unovis/vue/components/brush/index.js
import { defineComponent as d3, inject as m6, computed as v5, ref as y7, onMounted as h4, nextTick as f6, onUnmounted as B3, watch as u4, createElementBlock as F3, openBlock as x6 } from "vue";
var S2 = { "data-vis-component": "" };
var D4 = Brush.selectors;
var E2 = d3({
  __name: "index",
  props: {
    onBrush: { type: Function },
    onBrushStart: { type: Function },
    onBrushMove: { type: Function },
    onBrushEnd: { type: Function },
    handleWidth: {},
    selection: {},
    draggable: { type: Boolean },
    handlePosition: {},
    selectionMinLength: {},
    x: {},
    y: {},
    id: { type: Function },
    color: {},
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(l7, { expose: p13 }) {
    const o2 = m6(o), c6 = l7, n = v5(() => o2.data.value ?? c6.data), a7 = m2(c6), t4 = y7();
    return h4(() => {
      f6(() => {
        var e3;
        t4.value = new Brush(a7.value), (e3 = t4.value) == null || e3.setData(n.value), o2.update(t4.value);
      });
    }), B3(() => {
      var e3;
      (e3 = t4.value) == null || e3.destroy(), o2.destroy();
    }), u4(a7, (e3, s12) => {
      var r4;
      f(e3, s12) || (r4 = t4.value) == null || r4.setConfig(a7.value);
    }), u4(n, () => {
      var e3;
      (e3 = t4.value) == null || e3.setData(n.value);
    }), p13({
      component: t4
    }), (e3, s12) => (x6(), F3("div", S2));
  }
});

// node_modules/@unovis/vue/components/crosshair/index.js
import { defineComponent as d4, inject as m7, computed as v6, ref as f7, onMounted as _4, nextTick as h5, onUnmounted as x7, watch as u5, createElementBlock as C5, openBlock as k5 } from "vue";
var B4 = { "data-vis-crosshair": "" };
var q = Crosshair.selectors;
var A7 = d4({
  __name: "index",
  props: {
    data: {}
  },
  setup(l7, { expose: p13 }) {
    const t4 = m7(c3), r4 = l7, a7 = v6(() => t4.data.value ?? r4.data), s12 = m2(r4), o2 = f7();
    return _4(() => {
      h5(() => {
        var e3;
        o2.value = new Crosshair(s12.value), (e3 = o2.value) == null || e3.setData(a7.value), t4.update(o2.value);
      });
    }), x7(() => {
      var e3;
      (e3 = o2.value) == null || e3.destroy(), t4.destroy();
    }), u5(s12, (e3, n) => {
      var c6;
      f(e3, n) || (c6 = o2.value) == null || c6.setConfig(s12.value);
    }), u5(a7, () => {
      var e3;
      (e3 = o2.value) == null || e3.setData(a7.value);
    }), p13({
      component: o2
    }), (e3, n) => (k5(), C5("div", B4));
  }
});

// node_modules/@unovis/vue/components/free-brush/index.js
import { defineComponent as d5, inject as m8, computed as v7, ref as y8, onMounted as h6, nextTick as f8, onUnmounted as F4, watch as u6, createElementBlock as B5, openBlock as x8 } from "vue";
var g3 = { "data-vis-component": "" };
var D5 = FreeBrush.selectors;
var E3 = d5({
  __name: "index",
  props: {
    mode: {},
    onBrush: { type: Function },
    onBrushStart: { type: Function },
    onBrushMove: { type: Function },
    onBrushEnd: { type: Function },
    handleWidth: {},
    selection: {},
    selectionMinLength: {},
    autoHide: { type: Boolean },
    x: {},
    y: {},
    id: { type: Function },
    color: {},
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(l7, { expose: p13 }) {
    const o2 = m8(o), c6 = l7, n = v7(() => o2.data.value ?? c6.data), a7 = m2(c6), t4 = y8();
    return h6(() => {
      f8(() => {
        var e3;
        t4.value = new FreeBrush(a7.value), (e3 = t4.value) == null || e3.setData(n.value), o2.update(t4.value);
      });
    }), F4(() => {
      var e3;
      (e3 = t4.value) == null || e3.destroy(), o2.destroy();
    }), u6(a7, (e3, s12) => {
      var r4;
      f(e3, s12) || (r4 = t4.value) == null || r4.setConfig(a7.value);
    }), u6(n, () => {
      var e3;
      (e3 = t4.value) == null || e3.setData(n.value);
    }), p13({
      component: t4
    }), (e3, s12) => (x8(), B5("div", g3));
  }
});

// node_modules/@unovis/vue/components/grouped-bar/index.js
import { defineComponent as l, inject as m9, computed as v8, ref as f9, onMounted as y9, nextTick as x9, onUnmounted as g4, watch as u7, createElementBlock as _5, openBlock as b10 } from "vue";
var C6 = { "data-vis-component": "" };
var w3 = GroupedBar.selectors;
var D6 = l({
  __name: "index",
  props: {
    color: {},
    groupWidth: {},
    groupMaxWidth: {},
    dataStep: {},
    groupPadding: {},
    barPadding: {},
    roundedCorners: { type: [Number, Boolean] },
    barMinHeight: {},
    cursor: {},
    orientation: {},
    x: {},
    y: {},
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(d18, { expose: p13 }) {
    const t4 = m9(o), r4 = d18, a7 = v8(() => t4.data.value ?? r4.data), n = m2(r4), o2 = f9();
    return y9(() => {
      x9(() => {
        var e3;
        o2.value = new GroupedBar(n.value), (e3 = o2.value) == null || e3.setData(a7.value), t4.update(o2.value);
      });
    }), g4(() => {
      var e3;
      (e3 = o2.value) == null || e3.destroy(), t4.destroy();
    }), u7(n, (e3, c6) => {
      var s12;
      f(e3, c6) || (s12 = o2.value) == null || s12.setConfig(n.value);
    }), u7(a7, () => {
      var e3;
      (e3 = o2.value) == null || e3.setData(a7.value);
    }), p13({
      component: o2
    }), (e3, c6) => (b10(), _5("div", C6));
  }
});

// node_modules/@unovis/vue/components/line/index.js
import { defineComponent as d6, inject as m10, computed as v9, ref as y10, onMounted as f10, nextTick as h7, onUnmounted as x10, watch as i2, createElementBlock as _6, openBlock as g5 } from "vue";
var b11 = { "data-vis-component": "" };
var O2 = Line.selectors;
var S3 = d6({
  __name: "index",
  props: {
    color: {},
    curveType: {},
    lineWidth: {},
    lineDashArray: {},
    fallbackValue: {},
    highlightOnHover: { type: Boolean },
    cursor: {},
    interpolateMissingData: { type: Boolean },
    x: {},
    y: {},
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(u15, { expose: p13 }) {
    const o2 = m10(o), c6 = u15, a7 = v9(() => o2.data.value ?? c6.data), n = m2(c6), t4 = y10();
    return f10(() => {
      h7(() => {
        var e3;
        t4.value = new Line(n.value), (e3 = t4.value) == null || e3.setData(a7.value), o2.update(t4.value);
      });
    }), x10(() => {
      var e3;
      (e3 = t4.value) == null || e3.destroy(), o2.destroy();
    }), i2(n, (e3, r4) => {
      var s12;
      f(e3, r4) || (s12 = t4.value) == null || s12.setConfig(n.value);
    }), i2(a7, () => {
      var e3;
      (e3 = t4.value) == null || e3.setData(a7.value);
    }), p13({
      component: t4
    }), (e3, r4) => (g5(), _6("div", b11));
  }
});

// node_modules/@unovis/vue/components/scatter/index.js
import { defineComponent as d7, inject as m11, computed as v10, ref as y11, onMounted as f11, nextTick as b12, onUnmounted as x11, watch as l2, createElementBlock as _7, openBlock as F5 } from "vue";
var k6 = { "data-vis-component": "" };
var w4 = Scatter.selectors;
var z = d7({
  __name: "index",
  props: {
    color: {},
    size: {},
    sizeScale: { type: [Object, Function] },
    sizeRange: {},
    shape: { type: [Function, String] },
    label: {},
    labelColor: {},
    labelHideOverlapping: { type: Boolean },
    cursor: {},
    labelTextBrightnessRatio: {},
    labelPosition: {},
    strokeColor: {},
    strokeWidth: {},
    x: {},
    y: {},
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(u15, { expose: p13 }) {
    const o2 = m11(o), c6 = u15, a7 = v10(() => o2.data.value ?? c6.data), n = m2(c6), t4 = y11();
    return f11(() => {
      b12(() => {
        var e3;
        t4.value = new Scatter(n.value), (e3 = t4.value) == null || e3.setData(a7.value), o2.update(t4.value);
      });
    }), x11(() => {
      var e3;
      (e3 = t4.value) == null || e3.destroy(), o2.destroy();
    }), l2(n, (e3, s12) => {
      var r4;
      f(e3, s12) || (r4 = t4.value) == null || r4.setConfig(n.value);
    }), l2(a7, () => {
      var e3;
      (e3 = t4.value) == null || e3.setData(a7.value);
    }), p13({
      component: t4
    }), (e3, s12) => (F5(), _7("div", k6));
  }
});

// node_modules/@unovis/vue/components/stacked-bar/index.js
import { defineComponent as p2, inject as m12, computed as v11, ref as f12, onMounted as y13, nextTick as x13, onUnmounted as b13, watch as i3, createElementBlock as _8, openBlock as h8 } from "vue";
var k7 = { "data-vis-component": "" };
var j2 = StackedBar.selectors;
var w5 = p2({
  __name: "index",
  props: {
    color: {},
    barWidth: {},
    barMaxWidth: {},
    dataStep: {},
    barPadding: {},
    roundedCorners: { type: [Number, Boolean] },
    cursor: {},
    barMinHeight1Px: { type: Boolean },
    barMinHeightZeroValue: {},
    orientation: {},
    x: {},
    y: {},
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(d18, { expose: l7 }) {
    const o2 = m12(o), r4 = d18, a7 = v11(() => o2.data.value ?? r4.data), n = m2(r4), t4 = f12();
    return y13(() => {
      x13(() => {
        var e3;
        t4.value = new StackedBar(n.value), (e3 = t4.value) == null || e3.setData(a7.value), o2.update(t4.value);
      });
    }), b13(() => {
      var e3;
      (e3 = t4.value) == null || e3.destroy(), o2.destroy();
    }), i3(n, (e3, c6) => {
      var s12;
      f(e3, c6) || (s12 = t4.value) == null || s12.setConfig(n.value);
    }), i3(a7, () => {
      var e3;
      (e3 = t4.value) == null || e3.setData(a7.value);
    }), l7({
      component: t4
    }), (e3, c6) => (h8(), _8("div", k7));
  }
});

// node_modules/@unovis/vue/components/timeline/index.js
import { defineComponent as m13, inject as d8, computed as v12, ref as f13, onMounted as _9, nextTick as x14, onUnmounted as h9, watch as u8, createElementBlock as k8, openBlock as w6 } from "vue";
var B6 = { "data-vis-component": "" };
var j3 = Timeline.selectors;
var q2 = m13({
  __name: "index",
  props: {
    data: {}
  },
  setup(l7, { expose: p13 }) {
    const t4 = d8(o), s12 = l7, a7 = v12(() => t4.data.value ?? s12.data), n = m2(s12), o2 = f13();
    return _9(() => {
      x14(() => {
        var e3;
        o2.value = new Timeline(n.value), (e3 = o2.value) == null || e3.setData(a7.value), t4.update(o2.value);
      });
    }), h9(() => {
      var e3;
      (e3 = o2.value) == null || e3.destroy(), t4.destroy();
    }), u8(n, (e3, c6) => {
      var r4;
      f(e3, c6) || (r4 = o2.value) == null || r4.setConfig(n.value);
    }), u8(a7, () => {
      var e3;
      (e3 = o2.value) == null || e3.setData(a7.value);
    }), p13({
      component: o2
    }), (e3, c6) => (w6(), k8("div", B6));
  }
});

// node_modules/@unovis/vue/components/xy-labels/index.js
import { defineComponent as d9, inject as m14, computed as v13, ref as b14, onMounted as f14, nextTick as y14, onUnmounted as x15, watch as l3, createElementBlock as g6, openBlock as _10 } from "vue";
var k9 = { "data-vis-component": "" };
var j4 = XYLabels.selectors;
var w7 = d9({
  __name: "index",
  props: {
    color: {},
    y: {},
    xPositioning: {},
    yPositioning: {},
    labelFontSize: {},
    label: {},
    backgroundColor: {},
    cursor: {},
    labelTextBrightnessRatio: {},
    clustering: { type: Boolean },
    clusterLabel: {},
    clusterFontSize: {},
    clusterBackgroundColor: {},
    clusterCursor: {},
    clusterLabelColor: {},
    x: {},
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(i8, { expose: p13 }) {
    const t4 = m14(o), c6 = i8, a7 = v13(() => t4.data.value ?? c6.data), n = m2(c6), o2 = b14();
    return f14(() => {
      y14(() => {
        var e3;
        o2.value = new XYLabels(n.value), (e3 = o2.value) == null || e3.setData(a7.value), t4.update(o2.value);
      });
    }), x15(() => {
      var e3;
      (e3 = o2.value) == null || e3.destroy(), t4.destroy();
    }), l3(n, (e3, r4) => {
      var s12;
      f(e3, r4) || (s12 = o2.value) == null || s12.setConfig(n.value);
    }), l3(a7, () => {
      var e3;
      (e3 = o2.value) == null || e3.setData(a7.value);
    }), p13({
      component: o2
    }), (e3, r4) => (_10(), g6("div", k9));
  }
});

// node_modules/@unovis/vue/components/plotband/index.js
import { defineComponent as i4, inject as p3, ref as u9, onMounted as m15, nextTick as d10, onUnmounted as f15, watch as b15, createElementBlock as x16, openBlock as v14 } from "vue";
var O3 = { "data-vis-component": "" };
var k10 = Plotband.selectors;
var w8 = i4({
  __name: "index",
  props: {
    color: {},
    axis: {},
    from: {},
    to: {},
    duration: {},
    labelText: {},
    labelPosition: {},
    labelOffsetX: {},
    labelOffsetY: {},
    labelOrientation: {},
    labelColor: {},
    labelSize: {},
    x: {},
    y: {},
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    events: {},
    attributes: {},
    data: {}
  },
  setup(r4, { expose: s12 }) {
    const n = p3(o), t4 = m2(r4), e3 = u9();
    return m15(() => {
      d10(() => {
        e3.value = new Plotband(t4.value), n.update(e3.value);
      });
    }), f15(() => {
      var o2;
      (o2 = e3.value) == null || o2.destroy(), n.destroy();
    }), b15(t4, (o2, a7) => {
      var c6;
      f(o2, a7) || (c6 = e3.value) == null || c6.setConfig(t4.value);
    }), s12({
      component: e3
    }), (o2, a7) => (v14(), x16("div", O3));
  }
});

// node_modules/@unovis/vue/components/plotline/index.js
import { defineComponent as r2, inject as p4, ref as u10, onMounted as m16, nextTick as d11, onUnmounted as f16, watch as b16, createElementBlock as v15, openBlock as x17 } from "vue";
var O4 = { "data-vis-component": "" };
var k11 = Plotline.selectors;
var w9 = r2({
  __name: "index",
  props: {
    color: {},
    lineWidth: {},
    axis: {},
    value: {},
    duration: {},
    lineStyle: {},
    labelText: {},
    labelPosition: {},
    labelOffsetX: {},
    labelOffsetY: {},
    labelOrientation: {},
    labelColor: {},
    labelSize: {},
    x: {},
    y: {},
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    events: {},
    attributes: {},
    data: {}
  },
  setup(s12, { expose: i8 }) {
    const n = p4(o), t4 = m2(s12), e3 = u10();
    return m16(() => {
      d11(() => {
        e3.value = new Plotline(t4.value), n.update(e3.value);
      });
    }), f16(() => {
      var o2;
      (o2 = e3.value) == null || o2.destroy(), n.destroy();
    }), b16(t4, (o2, l7) => {
      var a7;
      f(o2, l7) || (a7 = e3.value) == null || a7.setConfig(t4.value);
    }), i8({
      component: e3
    }), (o2, l7) => (x17(), v15("div", O4));
  }
});

// node_modules/@unovis/vue/components/chord-diagram/index.js
import { defineComponent as p5, inject as m17, computed as v16, ref as g7, onMounted as h10, nextTick as f17, onUnmounted as _11, watch as l4, createElementBlock as C7, openBlock as k12 } from "vue";
var D7 = { "data-vis-component": "" };
var B7 = ChordDiagram.selectors;
var I = p5({
  __name: "index",
  props: {
    angleRange: {},
    cornerRadius: {},
    highlightedNodeId: {},
    highlightedLinkIds: {},
    linkColor: {},
    linkValue: {},
    nodeLevels: {},
    nodeWidth: {},
    nodeColor: {},
    nodeLabel: {},
    nodeLabelColor: {},
    nodeLabelAlignment: {},
    padAngle: {},
    radiusScaleExponent: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(i8, { expose: u15 }) {
    const t4 = m17(o), r4 = i8, a7 = v16(() => t4.data.value ?? r4.data), n = m2(r4), o2 = g7();
    return h10(() => {
      f17(() => {
        var e3;
        o2.value = new ChordDiagram(n.value), (e3 = o2.value) == null || e3.setData(a7.value), t4.update(o2.value);
      });
    }), _11(() => {
      var e3;
      (e3 = o2.value) == null || e3.destroy(), t4.destroy();
    }), l4(n, (e3, s12) => {
      var d18;
      f(e3, s12) || (d18 = o2.value) == null || d18.setConfig(n.value);
    }), l4(a7, () => {
      var e3;
      (e3 = o2.value) == null || e3.setData(a7.value);
    }), u15({
      component: o2
    }), (e3, s12) => (k12(), C7("div", D7));
  }
});

// node_modules/@unovis/vue/components/donut/index.js
import { defineComponent as i5, inject as m18, computed as f18, ref as v17, onMounted as g8, nextTick as y15, onUnmounted as b17, watch as l5, createElementBlock as _12, openBlock as h11 } from "vue";
var x18 = { "data-vis-component": "" };
var F6 = Donut.selectors;
var E4 = i5({
  __name: "index",
  props: {
    id: { type: Function },
    value: {},
    angleRange: {},
    padAngle: {},
    sortFunction: { type: Function },
    cornerRadius: {},
    color: {},
    radius: {},
    arcWidth: {},
    centralLabel: {},
    centralSubLabel: {},
    centralSubLabelWrap: { type: Boolean },
    showEmptySegments: { type: Boolean },
    emptySegmentAngle: {},
    showBackground: { type: Boolean },
    backgroundAngleRange: {},
    centralLabelOffsetX: {},
    centralLabelOffsetY: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(p13, { expose: d18 }) {
    const o2 = m18(o), r4 = p13, a7 = f18(() => o2.data.value ?? r4.data), n = m2(r4), t4 = v17();
    return g8(() => {
      y15(() => {
        var e3;
        t4.value = new Donut(n.value), (e3 = t4.value) == null || e3.setData(a7.value), o2.update(t4.value);
      });
    }), b17(() => {
      var e3;
      (e3 = t4.value) == null || e3.destroy(), o2.destroy();
    }), l5(n, (e3, c6) => {
      var s12;
      f(e3, c6) || (s12 = t4.value) == null || s12.setConfig(n.value);
    }), l5(a7, () => {
      var e3;
      (e3 = t4.value) == null || e3.setData(a7.value);
    }), d18({
      component: t4
    }), (e3, c6) => (h11(), _12("div", x18));
  }
});

// node_modules/@unovis/vue/components/graph/index.js
import { defineComponent as s7, inject as y16, computed as m19, ref as S4, onMounted as F7, nextTick as g9, onUnmounted as k13, watch as u11, createElementBlock as b18, openBlock as h12 } from "vue";
var L = { "data-vis-component": "" };
var B8 = Graph.selectors;
var D8 = s7({
  __name: "index",
  props: {
    zoomScaleExtent: {},
    disableZoom: { type: Boolean },
    zoomEventFilter: { type: Function },
    disableDrag: { type: Boolean },
    disableBrush: { type: Boolean },
    zoomThrottledUpdateNodeThreshold: {},
    fitViewPadding: {},
    fitViewAlign: {},
    layoutType: {},
    layoutAutofit: { type: Boolean },
    layoutAutofitTolerance: {},
    layoutNonConnectedAside: { type: Boolean },
    layoutNodeGroup: {},
    layoutGroupOrder: {},
    layoutParallelNodesPerColumn: {},
    layoutParallelNodeSubGroup: {},
    layoutParallelSubGroupsPerRow: {},
    layoutParallelNodeSpacing: {},
    layoutParallelSubGroupSpacing: {},
    layoutParallelGroupSpacing: {},
    layoutParallelSortConnectionsByGroup: {},
    forceLayoutSettings: {},
    dagreLayoutSettings: {},
    layoutElkSettings: {},
    layoutElkNodeGroups: {},
    layoutElkGetNodeShape: { type: Function },
    linkWidth: {},
    linkStyle: {},
    linkBandWidth: {},
    linkArrow: {},
    linkStroke: {},
    linkDisabled: {},
    linkFlow: {},
    linkFlowAnimDuration: {},
    linkFlowParticleSize: {},
    linkFlowParticleSpeed: {},
    linkLabel: {},
    linkLabelShiftFromCenter: {},
    linkNeighborSpacing: {},
    linkCurvature: {},
    linkHighlightOnHover: { type: Boolean },
    linkSourcePointOffset: {},
    linkTargetPointOffset: {},
    selectedLinkId: {},
    nodeSize: {},
    nodeStrokeWidth: {},
    nodeShape: {},
    nodeGaugeValue: {},
    nodeGaugeFill: {},
    nodeGaugeAnimDuration: {},
    nodeIcon: {},
    nodeIconSize: {},
    nodeLabel: {},
    nodeLabelTrim: {},
    nodeLabelTrimMode: {},
    nodeLabelTrimLength: {},
    nodeSubLabel: {},
    nodeSubLabelTrim: {},
    nodeSubLabelTrimMode: {},
    nodeSubLabelTrimLength: {},
    nodeSideLabels: {},
    nodeBottomIcon: {},
    nodeDisabled: {},
    nodeFill: {},
    nodeStroke: {},
    nodeSort: { type: Function },
    nodeEnterPosition: {},
    nodeEnterScale: {},
    nodeExitPosition: {},
    nodeExitScale: {},
    nodeEnterCustomRenderFunction: { type: Function },
    nodeUpdateCustomRenderFunction: { type: Function },
    nodePartialUpdateCustomRenderFunction: { type: Function },
    nodeExitCustomRenderFunction: { type: Function },
    nodeOnZoomCustomRenderFunction: { type: Function },
    nodeSelectionHighlightMode: {},
    selectedNodeId: {},
    selectedNodeIds: {},
    panels: {},
    onNodeDragStart: { type: Function },
    onNodeDrag: { type: Function },
    onNodeDragEnd: { type: Function },
    onZoom: { type: Function },
    onZoomStart: { type: Function },
    onZoomEnd: { type: Function },
    onLayoutCalculated: { type: Function },
    onNodeSelectionBrush: { type: Function },
    onNodeSelectionDrag: { type: Function },
    onRenderComplete: { type: Function },
    shouldDataUpdate: { type: Function },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(c6, { expose: p13 }) {
    const n = y16(o), l7 = c6, t4 = m19(() => n.data.value ?? l7.data), a7 = m2(l7), o2 = S4();
    return F7(() => {
      g9(() => {
        var e3;
        o2.value = new Graph(a7.value), (e3 = o2.value) == null || e3.setData(t4.value), n.update(o2.value);
      });
    }), k13(() => {
      var e3;
      (e3 = o2.value) == null || e3.destroy(), n.destroy();
    }), u11(a7, (e3, i8) => {
      var d18;
      f(e3, i8) || (d18 = o2.value) == null || d18.setConfig(a7.value);
    }), u11(t4, () => {
      var e3;
      (e3 = o2.value) == null || e3.setData(t4.value);
    }), p13({
      component: o2
    }), (e3, i8) => (h12(), b18("div", L));
  }
});

// node_modules/@unovis/vue/components/nested-donut/index.js
import { defineComponent as i6, inject as m20, computed as g10, ref as v18, onMounted as y17, nextTick as f19, onUnmounted as b19, watch as c4, createElementBlock as B9, openBlock as S5 } from "vue";
var L2 = { "data-vis-component": "" };
var E5 = NestedDonut.selectors;
var P2 = i6({
  __name: "index",
  props: {
    angleRange: {},
    direction: {},
    value: {},
    centralLabel: {},
    centralSubLabel: {},
    centralSubLabelWrap: { type: Boolean },
    showBackground: { type: Boolean },
    sort: { type: Function },
    layers: {},
    layerSettings: {},
    layerPadding: {},
    cornerRadius: {},
    emptySegmentAngle: {},
    hideOverflowingSegmentLabels: { type: Boolean },
    segmentColor: {},
    segmentLabel: {},
    segmentLabelColor: {},
    showEmptySegments: { type: Boolean },
    showSegmentLabels: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(p13, { expose: d18 }) {
    const o2 = m20(o), s12 = p13, a7 = g10(() => o2.data.value ?? s12.data), n = m2(s12), t4 = v18();
    return y17(() => {
      f19(() => {
        var e3;
        t4.value = new NestedDonut(n.value), (e3 = t4.value) == null || e3.setData(a7.value), o2.update(t4.value);
      });
    }), b19(() => {
      var e3;
      (e3 = t4.value) == null || e3.destroy(), o2.destroy();
    }), c4(n, (e3, r4) => {
      var l7;
      f(e3, r4) || (l7 = t4.value) == null || l7.setConfig(n.value);
    }), c4(a7, () => {
      var e3;
      (e3 = t4.value) == null || e3.setData(a7.value);
    }), d18({
      component: t4
    }), (e3, r4) => (S5(), B9("div", L2));
  }
});

// node_modules/@unovis/vue/components/sankey/index.js
import { defineComponent as p6, inject as b20, computed as m21, ref as h13, onMounted as y18, nextTick as g11, onUnmounted as v19, watch as s8, createElementBlock as f20, openBlock as k14 } from "vue";
var F8 = { "data-vis-component": "" };
var H = Sankey2.selectors;
var M2 = p6({
  __name: "index",
  props: {
    id: { type: Function },
    heightNormalizationCoeff: {},
    exitTransitionType: {},
    enterTransitionType: {},
    highlightSubtreeOnHover: { type: Boolean },
    highlightDuration: {},
    highlightDelay: {},
    iterations: {},
    nodeSort: { type: [Function, null] },
    linkSort: { type: [Function, null] },
    nodeWidth: {},
    nodeAlign: {},
    nodeHorizontalSpacing: {},
    nodeMinHeight: {},
    nodeMaxHeight: {},
    nodePadding: {},
    showSingleNode: { type: Boolean },
    nodeCursor: {},
    nodeIcon: {},
    nodeColor: {},
    nodeFixedValue: {},
    nodeIconColor: {},
    linkColor: {},
    linkValue: {},
    linkCursor: {},
    label: {},
    subLabel: {},
    labelPosition: {},
    labelVerticalAlign: {},
    labelBackground: { type: Boolean },
    labelFit: {},
    labelMaxWidth: {},
    labelExpandTrimmedOnHover: { type: Boolean },
    labelTrimMode: {},
    labelFontSize: {},
    labelTextSeparator: {},
    labelForceWordBreak: { type: Boolean },
    labelColor: {},
    labelCursor: {},
    labelVisibility: { type: Function },
    subLabelFontSize: {},
    subLabelColor: {},
    subLabelPlacement: {},
    subLabelToLabelInlineWidthRatio: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(u15, { expose: c6 }) {
    const n = b20(o), l7 = u15, t4 = m21(() => n.data.value ?? l7.data), a7 = m2(l7), o2 = h13();
    return y18(() => {
      g11(() => {
        var e3;
        o2.value = new Sankey2(a7.value), (e3 = o2.value) == null || e3.setData(t4.value), n.update(o2.value);
      });
    }), v19(() => {
      var e3;
      (e3 = o2.value) == null || e3.destroy(), n.destroy();
    }), s8(a7, (e3, i8) => {
      var r4;
      f(e3, i8) || (r4 = o2.value) == null || r4.setConfig(a7.value);
    }), s8(t4, () => {
      var e3;
      (e3 = o2.value) == null || e3.setData(t4.value);
    }), c6({
      component: o2
    }), (e3, i8) => (k14(), f20("div", F8));
  }
});

// node_modules/@unovis/vue/components/topojson-map/index.js
import { defineComponent as d12, inject as m22, computed as v20, ref as f21, onMounted as h14, nextTick as k15, onUnmounted as y19, watch as s9, createElementBlock as C8, openBlock as F9 } from "vue";
var T2 = { "data-vis-component": "" };
var j5 = TopoJSONMap.selectors;
var D9 = d12({
  __name: "index",
  props: {
    projection: { type: [Function, Object] },
    topojson: {},
    mapFeatureName: {},
    mapFitToPoints: { type: Boolean },
    zoomFactor: {},
    disableZoom: { type: Boolean },
    zoomExtent: {},
    zoomDuration: {},
    linkWidth: {},
    linkColor: {},
    linkCursor: {},
    linkId: {},
    linkSource: { type: Function },
    linkTarget: { type: Function },
    areaId: {},
    areaColor: {},
    areaCursor: {},
    pointColor: {},
    pointRadius: {},
    pointStrokeWidth: {},
    pointCursor: {},
    longitude: {},
    latitude: {},
    pointLabel: {},
    pointLabelPosition: {},
    pointLabelTextBrightnessRatio: {},
    pointId: { type: Function },
    heatmapMode: { type: Boolean },
    heatmapModeBlurStdDeviation: {},
    heatmapModeZoomLevelThreshold: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(c6, { expose: u15 }) {
    const t4 = m22(o), i8 = c6, a7 = v20(() => t4.data.value ?? i8.data), n = m2(i8), e3 = f21();
    return h14(() => {
      k15(() => {
        var o2;
        e3.value = new TopoJSONMap(n.value), (o2 = e3.value) == null || o2.setData(a7.value), t4.update(e3.value);
      });
    }), y19(() => {
      var o2;
      (o2 = e3.value) == null || o2.destroy(), t4.destroy();
    }), s9(n, (o2, r4) => {
      var p13;
      f(o2, r4) || (p13 = e3.value) == null || p13.setConfig(n.value);
    }), s9(a7, () => {
      var o2;
      (o2 = e3.value) == null || o2.setData(a7.value);
    }), u15({
      component: e3
    }), (o2, r4) => (F9(), C8("div", T2));
  }
});

// node_modules/@unovis/vue/components/treemap/index.js
import { defineComponent as p7, inject as m23, computed as f22, ref as v21, onMounted as b21, nextTick as y20, onUnmounted as F10, watch as s10, createElementBlock as B10, openBlock as L3 } from "vue";
var T3 = { "data-vis-component": "" };
var w10 = Treemap.selectors;
var C9 = p7({
  __name: "index",
  props: {
    id: { type: Function },
    value: {},
    layers: {},
    numberFormat: { type: Function },
    tileColor: {},
    tilePadding: {},
    tilePaddingTop: {},
    labelInternalNodes: { type: Boolean },
    labelOffsetX: {},
    labelOffsetY: {},
    tileBorderRadius: {},
    tileBorderRadiusFactor: {},
    enableLightnessVariance: { type: Boolean },
    enableTileLabelFontSizeVariation: { type: Boolean },
    tileLabelSmallFontSize: {},
    tileLabelMediumFontSize: {},
    tileLabelLargeFontSize: {},
    showTileClickAffordance: { type: Boolean },
    lightnessVariationAmount: {},
    minTileSizeForLabel: {},
    tileLabel: { type: Function },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(u15, { expose: d18 }) {
    const o2 = m23(o), l7 = u15, a7 = f22(() => o2.data.value ?? l7.data), n = m2(l7), t4 = v21();
    return b21(() => {
      y20(() => {
        var e3;
        t4.value = new Treemap(n.value), (e3 = t4.value) == null || e3.setData(a7.value), o2.update(t4.value);
      });
    }), F10(() => {
      var e3;
      (e3 = t4.value) == null || e3.destroy(), o2.destroy();
    }), s10(n, (e3, i8) => {
      var r4;
      f(e3, i8) || (r4 = t4.value) == null || r4.setConfig(n.value);
    }), s10(a7, () => {
      var e3;
      (e3 = t4.value) == null || e3.setData(a7.value);
    }), d18({
      component: t4
    }), (e3, i8) => (L3(), B10("div", T3));
  }
});

// node_modules/@unovis/vue/components/tooltip/index.js
import { defineComponent as i7, inject as p8, ref as m24, onMounted as u12, nextTick as d13, onUnmounted as f23, watch as v22, createElementBlock as h15, openBlock as _13 } from "vue";
var g12 = { "data-vis-tooltip": "" };
var T4 = Tooltip.selectors;
var z2 = i7({
  __name: "index",
  props: {
    components: {},
    container: {},
    followCursor: { type: Boolean },
    allowHover: { type: Boolean },
    horizontalPlacement: {},
    horizontalShift: {},
    verticalPlacement: {},
    verticalShift: {},
    triggers: {},
    attributes: {},
    className: {},
    hideDelay: {},
    showDelay: {},
    data: {}
  },
  setup(c6, { expose: l7 }) {
    const r4 = p8(s3), t4 = m2(c6), o2 = m24();
    return u12(() => {
      d13(() => {
        o2.value = new Tooltip(t4.value), r4.update(o2.value);
      });
    }), f23(() => {
      var e3;
      (e3 = o2.value) == null || e3.destroy(), r4.destroy();
    }), v22(t4, (e3, n) => {
      var a7;
      f(e3, n) || (a7 = o2.value) == null || a7.setConfig(t4.value);
    }), l7({
      component: o2
    }), (e3, n) => (_13(), h15("div", g12));
  }
});

// node_modules/@unovis/vue/components/annotations/index.js
import { defineComponent as p9, inject as u13, ref as m25, onMounted as d14, nextTick as l6, onUnmounted as f24, watch as v23, createElementBlock as _14, openBlock as x19 } from "vue";
var y21 = { "data-vis-annotations": "" };
var P3 = Annotations.selectors;
var b22 = p9({
  __name: "index",
  props: {
    items: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(c6, { expose: i8 }) {
    const n = u13(t), t4 = m2(c6), o2 = m25();
    return d14(() => {
      l6(() => {
        o2.value = new Annotations(t4.value), n.update(o2.value);
      });
    }), f24(() => {
      var e3;
      (e3 = o2.value) == null || e3.destroy(), n.destroy();
    }), v23(t4, (e3, s12) => {
      var r4;
      f(e3, s12) || (r4 = o2.value) == null || r4.setConfig(t4.value);
    }), i8({
      component: o2
    }), (e3, s12) => (x19(), _14("div", y21));
  }
});

// node_modules/@unovis/vue/html-components/leaflet-map/index.js
import { defineComponent as d15, computed as f25, ref as p10, onMounted as m26, nextTick as y22, onUnmounted as v24, watch as M3, createElementBlock as L4, openBlock as B11 } from "vue";
var F11 = LeafletMap.selectors;
var w11 = d15({
  __name: "index",
  props: {
    width: {},
    height: {},
    flyToDuration: {},
    fitViewPadding: {},
    zoomDuration: {},
    initialBounds: {},
    fitBoundsOnUpdate: {},
    fitViewOnInit: { type: Boolean },
    fitViewOnUpdate: { type: Boolean },
    style: {},
    styleDarkTheme: {},
    accessToken: {},
    attribution: {},
    renderer: {},
    onMapInitialized: { type: Function },
    onMapMoveZoom: { type: Function },
    onMapMoveStart: { type: Function },
    onMapMoveEnd: { type: Function },
    onMapZoomStart: { type: Function },
    onMapZoomEnd: { type: Function },
    onMapClick: { type: Function },
    pointLongitude: {},
    pointLatitude: {},
    pointId: {},
    pointShape: {},
    pointColor: {},
    pointRadius: {},
    pointLabel: {},
    pointLabelColor: {},
    pointBottomLabel: {},
    pointCursor: {},
    pointRingWidth: {},
    selectedPointId: {},
    clusterColor: {},
    clusterRadius: {},
    clusterLabel: {},
    clusterLabelColor: {},
    clusterBottomLabel: {},
    clusterRingWidth: {},
    clusterBackground: { type: Boolean },
    clusterExpandOnClick: { type: Boolean },
    clusteringDistance: {},
    colorMap: {},
    topoJSONLayer: {},
    tooltip: {},
    ariaLabel: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(u15, { expose: c6 }) {
    const a7 = u15, s12 = f25(() => a7.data), o2 = m2(a7), e3 = p10(), n = p10();
    return m26(() => {
      y22(() => {
        n.value && (e3.value = new LeafletMap(n.value, o2.value, s12.value));
      });
    }), v24(() => {
      var t4;
      (t4 = e3.value) == null || t4.destroy();
    }), M3(o2, (t4, i8) => {
      var l7;
      f(t4, i8) || (l7 = e3.value) == null || l7.setConfig(o2.value);
    }), c6({
      component: e3
    }), (t4, i8) => (B11(), L4("div", {
      "data-vis-leaflet-map": "",
      ref_key: "elRef",
      ref: n
    }, null, 512));
  }
});

// node_modules/@unovis/vue/html-components/leaflet-flow-map/index.js
import { defineComponent as d16, computed as f26, ref as r3, onMounted as m27, nextTick as y23, onUnmounted as L5, watch as M4, createElementBlock as v25, openBlock as w12 } from "vue";
var k16 = LeafletFlowMap.selectors;
var b23 = d16({
  __name: "index",
  props: {
    sourceLongitude: {},
    sourceLatitude: {},
    targetLongitude: {},
    targetLatitude: {},
    sourcePointRadius: {},
    sourcePointColor: {},
    flowParticleColor: {},
    flowParticleRadius: {},
    flowParticleSpeed: {},
    flowParticleDensity: {},
    onSourcePointClick: { type: Function },
    onSourcePointMouseEnter: { type: Function },
    onSourcePointMouseLeave: { type: Function },
    width: {},
    height: {},
    flyToDuration: {},
    fitViewPadding: {},
    zoomDuration: {},
    initialBounds: {},
    fitBoundsOnUpdate: {},
    fitViewOnInit: { type: Boolean },
    fitViewOnUpdate: { type: Boolean },
    style: {},
    styleDarkTheme: {},
    accessToken: {},
    attribution: {},
    renderer: {},
    onMapInitialized: { type: Function },
    onMapMoveZoom: { type: Function },
    onMapMoveStart: { type: Function },
    onMapMoveEnd: { type: Function },
    onMapZoomStart: { type: Function },
    onMapZoomEnd: { type: Function },
    onMapClick: { type: Function },
    pointLongitude: {},
    pointLatitude: {},
    pointId: {},
    pointShape: {},
    pointColor: {},
    pointRadius: {},
    pointLabel: {},
    pointLabelColor: {},
    pointBottomLabel: {},
    pointCursor: {},
    pointRingWidth: {},
    selectedPointId: {},
    clusterColor: {},
    clusterRadius: {},
    clusterLabel: {},
    clusterLabelColor: {},
    clusterBottomLabel: {},
    clusterRingWidth: {},
    clusterBackground: { type: Boolean },
    clusterExpandOnClick: { type: Boolean },
    clusteringDistance: {},
    colorMap: {},
    topoJSONLayer: {},
    tooltip: {},
    ariaLabel: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(c6, { expose: p13 }) {
    const i8 = c6, s12 = f26(() => i8.data), t4 = m2(i8), e3 = r3(), n = r3();
    return m27(() => {
      y23(() => {
        n.value && (e3.value = new LeafletFlowMap(n.value, t4.value, s12.value));
      });
    }), L5(() => {
      var o2;
      (o2 = e3.value) == null || o2.destroy();
    }), M4(t4, (o2, a7) => {
      var l7;
      f(o2, a7) || (l7 = e3.value) == null || l7.setConfig(t4.value);
    }), p13({
      component: e3
    }), (o2, a7) => (w12(), v25("div", {
      "data-vis-leaflet-flow-map": "",
      ref_key: "elRef",
      ref: n
    }, null, 512));
  }
});

// node_modules/@unovis/vue/html-components/bullet-legend/index.js
import { defineComponent as c5, computed as p11, ref as d17, onMounted as m28, nextTick as f27, onUnmounted as v26, watch as b24, createElementBlock as _15, openBlock as g13 } from "vue";
var y24 = BulletLegend.selectors;
var P4 = c5({
  __name: "index",
  props: {
    items: {},
    labelClassName: {},
    onLegendItemClick: { type: Function },
    labelFontSize: {},
    labelMaxWidth: {},
    bulletSize: {},
    bulletSpacing: {},
    bulletShape: {},
    orientation: {},
    renderIntoProvidedDomNode: { type: Boolean },
    data: {}
  },
  setup(i8, { expose: s12 }) {
    const l7 = i8;
    p11(() => l7.data);
    const t4 = m2(l7), o2 = d17(), n = d17();
    return m28(() => {
      f27(() => {
        n.value && (o2.value = new BulletLegend(n.value, { ...t4.value, renderIntoProvidedDomNode: true }));
      });
    }), v26(() => {
      var e3;
      (e3 = o2.value) == null || e3.destroy();
    }), b24(t4, (e3, a7) => {
      var r4;
      f(e3, a7) || (r4 = o2.value) == null || r4.update(t4.value);
    }), s12({
      component: o2
    }), (e3, a7) => (g13(), _15("div", {
      "data-vis-bullet-legend": "",
      ref_key: "elRef",
      ref: n
    }, null, 512));
  }
});

// node_modules/@unovis/vue/html-components/rolling-pin-legend/index.js
import { defineComponent as p12, computed as u14, ref as s11, onMounted as f28, nextTick as m29, onUnmounted as v27, watch as g14, createElementBlock as x20, openBlock as _16 } from "vue";
var h16 = RollingPinLegend.selectors;
var w13 = p12({
  __name: "index",
  props: {
    rects: {},
    leftLabelText: {},
    rightLabelText: {},
    labelClassName: {},
    labelFontSize: {},
    renderIntoProvidedDomNode: { type: Boolean },
    data: {}
  },
  setup(c6, { expose: d18 }) {
    const l7 = c6;
    u14(() => l7.data);
    const n = m2(l7), o2 = s11(), t4 = s11();
    return f28(() => {
      m29(() => {
        t4.value && (o2.value = new RollingPinLegend(t4.value, n.value));
      });
    }), v27(() => {
      var e3;
      (e3 = o2.value) == null || e3.destroy();
    }), g14(n, (e3, r4) => {
      var a7;
      f(e3, r4) || (a7 = o2.value) == null || a7.setConfig(n.value);
    }), d18({
      component: o2
    }), (e3, r4) => (_16(), x20("div", {
      "data-vis-rolling-pin-legend": "",
      ref_key: "elRef",
      ref: t4
    }, null, 512));
  }
});

// node_modules/@unovis/vue/index.js
(function() {
  "use strict";
  try {
    if (typeof document < "u") {
      var e3 = document.createElement("style");
      e3.appendChild(document.createTextNode(".unovis-xy-container,.unovis-single-container{display:block;position:relative;width:100%}[data-vis-leaflet-map],[data-vis-leaflet-flow-map]{display:block;position:relative}[data-vis-bullet-legend],[data-vis-rolling-pin-legend]{display:block}")), document.head.appendChild(e3);
    }
  } catch (i8) {
    console.error("vite-plugin-css-injected-by-js", i8);
  }
})();
export {
  b22 as VisAnnotations,
  P3 as VisAnnotationsSelectors,
  P as VisArea,
  D3 as VisAreaSelectors,
  O as VisAxis,
  C4 as VisAxisSelectors,
  E2 as VisBrush,
  D4 as VisBrushSelectors,
  P4 as VisBulletLegend,
  y24 as VisBulletLegendSelectors,
  I as VisChordDiagram,
  B7 as VisChordDiagramSelectors,
  A7 as VisCrosshair,
  q as VisCrosshairSelectors,
  E4 as VisDonut,
  F6 as VisDonutSelectors,
  E3 as VisFreeBrush,
  D5 as VisFreeBrushSelectors,
  D8 as VisGraph,
  B8 as VisGraphSelectors,
  D6 as VisGroupedBar,
  w3 as VisGroupedBarSelectors,
  b23 as VisLeafletFlowMap,
  k16 as VisLeafletFlowMapSelectors,
  w11 as VisLeafletMap,
  F11 as VisLeafletMapSelectors,
  S3 as VisLine,
  O2 as VisLineSelectors,
  P2 as VisNestedDonut,
  E5 as VisNestedDonutSelectors,
  w8 as VisPlotband,
  k10 as VisPlotbandSelectors,
  w9 as VisPlotline,
  k11 as VisPlotlineSelectors,
  w13 as VisRollingPinLegend,
  h16 as VisRollingPinLegendSelectors,
  M2 as VisSankey,
  H as VisSankeySelectors,
  z as VisScatter,
  w4 as VisScatterSelectors,
  b as VisSingleContainer,
  w5 as VisStackedBar,
  j2 as VisStackedBarSelectors,
  q2 as VisTimeline,
  j3 as VisTimelineSelectors,
  z2 as VisTooltip,
  T4 as VisTooltipSelectors,
  D9 as VisTopoJSONMap,
  j5 as VisTopoJSONMapSelectors,
  C9 as VisTreemap,
  w10 as VisTreemapSelectors,
  S as VisXYContainer,
  w7 as VisXYLabels,
  j4 as VisXYLabelsSelectors
};
//# sourceMappingURL=@unovis_vue.js.map
