import { select } from 'd3-selection';
import { hierarchy, treemap } from 'd3-hierarchy';
import { extent, group, max } from 'd3-array';
import { scaleLinear, scaleThreshold } from 'd3-scale';
import { hsl } from 'd3-color';
import { ComponentCore } from '../../core/component/index.js';
import { SeriesDataModel } from '../../data-models/series.js';
import { getColor, getHexValue, brighter } from '../../utils/color.js';
import { isNumber, getString, getNumber } from '../../utils/data.js';
import { smartTransition } from '../../utils/d3.js';
import { trimSVGText } from '../../utils/text.js';
import { TrimMode } from '../../types/text.js';
import { TreemapDefaultConfig } from './config.js';
import * as style from './style.js';
import { tiles, tileGroup, tile, clickableTile, labelGroup, label, internalLabel } from './style.js';

class Treemap extends ComponentCore {
    constructor(config) {
        super();
        this._defaultConfig = TreemapDefaultConfig;
        this.config = this._defaultConfig;
        this.datamodel = new SeriesDataModel();
        if (config)
            this.setConfig(config);
        this.tiles = this.g.append('g').attr('class', tiles);
    }
    /** Default number format for tile labels. */
    _defaultNumberFormat(value) {
        return `${value}`;
    }
    _isTileLargeEnough(d) {
        const w = d.x1 - d.x0;
        const h = d.y1 - d.y0;
        return (w >= this.config.minTileSizeForLabel) && (h >= this.config.minTileSizeForLabel);
    }
    _getTileLightness(node, siblings) {
        // Get the value extent of the sibling group
        const [minValue, maxValue] = extent(siblings, d => d.value);
        // If there's no range or no value, return default lightness
        if (minValue === maxValue || !node.value)
            return 0;
        // Calculate relative position in the range (0 to 1)
        // Larger values will be closer to 0 (darker)
        return this.config.lightnessVariationAmount * ((maxValue - node.value) / (maxValue - minValue));
    }
    _render(customDuration) {
        var _a, _b;
        super._render(customDuration);
        const { config, datamodel: { data }, _width, _height } = this;
        const { numberFormat } = config;
        const formatNumber = numberFormat !== null && numberFormat !== void 0 ? numberFormat : this._defaultNumberFormat.bind(this);
        const duration = isNumber(customDuration) ? customDuration : config.duration;
        if (!((_a = config.layers) === null || _a === void 0 ? void 0 : _a.length)) {
            console.warn('Unovis | Treemap: No layers defined');
            return;
        }
        // Map each layer accessor function to get string values from the data array
        const layerAccessors = config.layers.map(layerAccessor => {
            return (i) => getString(data[i], layerAccessor, i);
        });
        // Group the data indices by the layer accessors to create a hierarchical structure
        const nestedData = group(data.keys(), ...layerAccessors);
        // Create the hierarchy from the grouped data,
        // which by itself is not quite right because there is an extra
        // level of nesting that we don't want, just above the leaf nodes.
        const rootNode = hierarchy(nestedData);
        // Compute the aggregation
        if (config.value) {
            rootNode.sum(index => typeof index === 'number' && getNumber(data[index], config.value, index));
        }
        else {
            rootNode.count();
        }
        // Fix the hierarchy by removing the extra level of nesting
        rootNode.each(node => {
            if (!node.children && node.parent) {
                node.parent.children = null;
            }
        });
        const treemapLayout = treemap()
            .size([_width, _height])
            .round(true)
            .padding(config.tilePadding);
        // Apply padding to the top of each tile,
        // but not for the root node.
        if (this.config.tilePaddingTop !== undefined) {
            treemapLayout.paddingTop(d => d.parent ? config.tilePaddingTop : 0);
        }
        // Compute the treemap layout
        const treemapData = treemapLayout(rootNode);
        // Process the resulting hierarchy into the type we need
        let nodeId = 0;
        treemapData.each(node => {
            const n = node;
            // Generate unique IDs for each node
            node._id = `node-${nodeId++}`;
            const treemapDatum = {
                key: n.data[0],
            };
            // Populate the index and datum for leaf nodes
            const isLeafNode = !n.children;
            if (isLeafNode) {
                treemapDatum.index = n.data[1][0];
                treemapDatum.datum = data[treemapDatum.index];
            }
            node.data = treemapDatum;
        });
        const descendants = treemapData.descendants();
        // Set up the brightness increase scale based on depth
        const maxDepth = max(descendants, d => d.depth);
        const brightnessIncrease = scaleLinear()
            .domain([1, maxDepth])
            .range([0, 1]);
        // Get all leaf node values and calculate their square roots
        // (since area is proportional to value)
        const leafValues = descendants.filter(d => !d.children).map(d => d.value);
        const maxLeafValue = Math.sqrt(max(leafValues)) || 0;
        // Divide the range into three equal intervals based on the square root of values
        // This accounts for the fact that area is proportional to value
        const fontSizeScale = scaleThreshold()
            .domain([
            maxLeafValue / 3,
            (maxLeafValue * 2) / 3, // Second third of the max value
        ])
            .range([
            config.tileLabelSmallFontSize,
            config.tileLabelMediumFontSize,
            config.tileLabelLargeFontSize,
        ]);
        // First pass: Set base colors without considering tileColor config
        treemapData.eachBefore((node) => {
            var _a, _b, _c;
            // Get base color: user accessor or default
            let color = config.tileColor
                ? getColor(node, config.tileColor)
                : getColor(node, undefined, (_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b.indexOf(node), node.depth !== 1);
            // Fallback to parent color if needed
            color = color !== null && color !== void 0 ? color : (_c = node.parent) === null || _c === void 0 ? void 0 : _c._fill;
            const hexColor = color ? getHexValue(color, this.g.node()) : null;
            if (hexColor) {
                const hslColor = hsl(hexColor);
                // Lightness adjustment for siblings (if enabled)
                if (config.enableLightnessVariance && !node.children && node.parent) {
                    const siblings = node.parent.children;
                    const lightnessAdjustment = this._getTileLightness(node, siblings);
                    hslColor.l = Math.min(1, hslColor.l + lightnessAdjustment);
                }
                // Brightness increase for depth
                node._fill = brighter(hslColor.toString(), brightnessIncrease(node.depth));
            }
            else {
                node._fill = null;
            }
        });
        // Render tiles
        const visibleNodes = descendants.filter(d => d.depth > 0);
        const tiles = this.tiles
            .selectAll(`g.${tileGroup}`)
            .data(visibleNodes, d => `${d.data.key}-${d.depth}`);
        const tilesEnter = tiles
            .enter()
            .append('g')
            .attr('class', tileGroup);
        // Computes the rect border radius for a given tile.
        // The rx and ry values are the minimum of the tile
        // border radius and some fraction the width of the tile,
        // based on the tileBorderRadiusFactor config.
        // This ensures that the tile border radius is not
        // larger than the tile size, which makes small tiles
        // look better.
        const rx = (d) => Math.min(config.tileBorderRadius, (d.x1 - d.x0) * config.tileBorderRadiusFactor);
        // Tile rectangles
        tilesEnter
            .append('rect')
            .classed(tile, true)
            // Make the leaf tiles clickable if a click handler is provided
            .classed(clickableTile, d => config.showTileClickAffordance && !d.children)
            .attr('rx', rx)
            .attr('ry', rx)
            // Initialize tile positions so that the initial transition is smooth
            .attr('x', d => d.x0)
            .attr('y', d => d.y0)
            .attr('width', d => d.x1 - d.x0)
            .attr('height', d => d.y1 - d.y0)
            .style('fill', d => { var _a; return (_a = d._fill) !== null && _a !== void 0 ? _a : getColor(d, config.tileColor); })
            .style('opacity', 0)
            .style('cursor', config.showTileClickAffordance ? d => !d.children ? 'pointer' : null : null);
        const mergedTiles = tiles.merge(tilesEnter);
        smartTransition(mergedTiles.select(`rect.${tile}`), duration)
            .style('fill', d => { var _a; return (_a = d._fill) !== null && _a !== void 0 ? _a : getColor(d, config.tileColor); })
            .style('opacity', 1)
            .attr('x', d => d.x0)
            .attr('y', d => d.y0)
            .attr('width', d => d.x1 - d.x0)
            .attr('height', d => d.y1 - d.y0);
        // Update clipPath rects
        let svg = this.g.node();
        while (svg && !(svg instanceof SVGSVGElement))
            svg = svg.parentElement;
        const defs = svg ? (select(svg).select('defs').empty() ? select(svg).append('defs') : select(svg).select('defs')) : null;
        if (!defs)
            return;
        const defsSelection = defs;
        const clipPaths = defsSelection.selectAll('clipPath')
            .data(visibleNodes, (d) => d._id);
        clipPaths.enter()
            .append('clipPath')
            .attr('id', (d) => `clip-${d._id}`)
            .append('rect')
            .attr('x', (d) => d.x0)
            .attr('y', (d) => d.y0)
            .attr('width', (d) => Math.max(0.1, d.x1 - d.x0))
            .attr('height', (d) => Math.max(0.1, d.y1 - d.y0))
            .attr('rx', rx)
            .attr('ry', rx);
        clipPaths.exit().remove();
        tilesEnter
            .append('g')
            .attr('class', labelGroup)
            .attr('transform', d => `translate(${d.x0 + config.labelOffsetX},${d.y0 + config.labelOffsetY})`)
            .append('text')
            .attr('class', label)
            .attr('x', 0)
            .attr('y', 0)
            .style('opacity', 0);
        const getTileLabel = (_b = config.tileLabel) !== null && _b !== void 0 ? _b : ((d) => `${d.data.key}: ${formatNumber(d.value)}`);
        const textSelection = mergedTiles.selectAll(`g.${labelGroup} text`);
        textSelection
            .text(d => getTileLabel(d))
            .style('font-size', function (d) {
            var _a;
            const sqrtVal = Math.sqrt((_a = d.value) !== null && _a !== void 0 ? _a : 0);
            return config.enableTileLabelFontSizeVariation && !d.children
                ? `${fontSizeScale(sqrtVal)}px`
                : `${fontSizeScale.range()[1]}px`;
        })
            .attr('dominant-baseline', 'middle');
        // Trim label and set dominant-baseline for tspans in one pass
        textSelection.each((d, i, nodes) => {
            var _a;
            const text = select(nodes[i]);
            const tileWidth = d.x1 - d.x0 - ((_a = config.labelOffsetX) !== null && _a !== void 0 ? _a : 0) * 2;
            const fullLabel = text.text();
            let fontSize = parseFloat(text.style('font-size'));
            if (!fontSize) {
                fontSize = parseFloat(window.getComputedStyle(nodes[i]).fontSize);
            }
            trimSVGText(text, tileWidth, TrimMode.End, true, fontSize);
            text.attr('title', fullLabel);
            text.selectAll('tspan').attr('dominant-baseline', 'middle');
        });
        // Transition group position
        smartTransition(mergedTiles.select(`g.${labelGroup}`), duration)
            .attr('transform', d => `translate(${d.x0 + config.labelOffsetX},${d.y0 + config.labelOffsetY})`);
        // Transition text opacity only (fade-in)
        smartTransition(mergedTiles.select(`g.${labelGroup} text`), duration)
            .style('opacity', 1);
        // Hide labels that don't meet criteria
        mergedTiles.select(`text.${label}`)
            .style('display', d => {
            const isAllowedNode = config.labelInternalNodes ? true : !d.children;
            return isAllowedNode && this._isTileLargeEnough(d) ? null : 'none';
        })
            // Make the internal labels semibold via class
            .attr('class', d => d.children ? `${label} ${internalLabel}` : label);
        smartTransition(tiles.exit(), duration)
            .style('opacity', 0)
            .remove();
    }
}
Treemap.selectors = style;

export { Treemap };
//# sourceMappingURL=index.js.map
